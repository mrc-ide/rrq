% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rrq_create.R
\name{rrq_task_create_expr}
\alias{rrq_task_create_expr}
\title{Create a task based on an expression}
\usage{
rrq_task_create_expr(
  expr,
  queue = NULL,
  separate_process = FALSE,
  timeout_task_run = NULL,
  depends_on = NULL,
  controller = NULL
)
}
\arguments{
\item{expr}{The expression, does not need quoting. See Details.}

\item{queue}{The queue to add the task to; if not specified the
"default" queue (which all workers listen to) will be used. If
you have configured workers to listen to more than one queue you
can specify that here. Be warned that if you push jobs onto a
queue with no worker, it will queue forever.}

\item{separate_process}{Logical, indicating if the task should be
run in a separate process on the worker. If \code{TRUE}, then the
worker runs the task in a separate process using the \code{callr}
package. This means that the worker environment is completely
clean, subsequent runs are not affected by preceding ones.  The
downside of this approach is a considerable overhead in starting
the external process and transferring data back.}

\item{timeout_task_run}{Optionally, a maximum allowed running
time, in seconds. This parameter only has an effect if
\code{separate_process} is \code{TRUE}. If given, then if the task takes
longer than this time it will be stopped and the task status set
to \code{TIMEOUT}.}

\item{depends_on}{Vector or list of IDs of tasks which must have
completed before this job can be run. Once all dependent tasks
have been successfully run, this task will get added to the
queue. If the dependent task fails then this task will be
removed from the queue.}

\item{controller}{The controller to use.  If not given (or \code{NULL})
we'll use the controller registered with
\code{\link[=rrq_default_controller_set]{rrq_default_controller_set()}}.}
}
\description{
Create a task based on an expression.  The expression passed as
\code{expr} will typically be a function call (e.g., \code{f(x)}).  We will
analyse the expression and find all variables that you reference
(in the case of \code{f(x)} this is \code{x}) and combine this with the
function name to run on the worker.  If \code{x} cannot be found in
your calling environment we will error.
}
\details{
Alternatively you may provide a multiline statement by using \code{{}}
to surround multiple lines, such as:

\if{html}{\out{<div class="sourceCode">}}\preformatted{task_create_expr(\{
  x <- runif(1)
  f(x)
\}, ...)
}\if{html}{\out{</div>}}

in this case, we apply a simple heuristic to work out that \code{x} is
locally assigned and should not be saved with the expression.
}
\examples{
\dontshow{if (rrq:::enable_examples(require_queue = "rrq:example")) (if (getRversion() >= "3.4") withAutoprint else force)(\{ # examplesIf}
obj <- rrq_controller("rrq:example")

# Simple use of the function to create a task based on a function call
t <- rrq_task_create_expr(sqrt(2), controller = obj)
rrq_task_wait(t, controller = obj)
rrq_task_result(t, controller = obj)

# The expression can contain calls to other variables, and these
# will be included in the call:
a <- 3
t <- rrq_task_create_expr(sqrt(a), controller = obj)
rrq_task_wait(t, controller = obj)
rrq_task_result(t, controller = obj)

# You can pass in an expression _as_ a symbol too:
expr <- quote(sqrt(4))
t <- rrq_task_create_expr(expr, controller = obj)
rrq_task_wait(t, controller = obj)
rrq_task_result(t, controller = obj)

# If you queue tasks into separate processes you can use a timeout
# to kill the task if it takes too long:
t <- rrq_task_create_expr(Sys.sleep(3),
                          separate_process = TRUE,
                          timeout_task_run = 1,
                          controller = obj)
rrq_task_wait(t, controller = obj)
rrq_task_result(t, controller = obj)
\dontshow{\}) # examplesIf}
}
\seealso{
\link{rrq_task_create_call} for creating a task from a
function and arguments to the function, and
\link{rrq_task_create_bulk_expr} for creating many tasks from a call
and a data.frame
}
