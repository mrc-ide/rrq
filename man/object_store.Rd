% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/object_store.R
\name{object_store}
\alias{object_store}
\title{rrq object store}
\description{
When you create a task with rrq and that task uses local variables
these need to be copied over to the worker that will evaluate the
task. So, if we had\preformatted{obj$enqueue(f(a, b))
}

that would be the objects \code{a} and \code{b} from the context where
\code{enqueue} was called. There are a few considerations here:
\itemize{
\item The names \code{a} and \code{b} are only useful in the immediate context
of the controller at the point the task is sent and so we need
to store the \emph{values} referenced by \code{a} and \code{b} without
reference to the names - we do this by naming the new values
after their value. That is, the name becomes the hash of the
object, computed by \code{\link[openssl:hash]{openssl::sha256()}} after serialisation, as
a form of \href{https://en.wikipedia.org/wiki/Content-addressable_storage}{content-addressable storage}.
\item When doing this we note that we might end up using the value
referenced by \code{a} or \code{b} many times in different tasks so we
should not re-save the data more than needed, and we should not
necessarily delete it when a task is deleted unless nothing else
uses that value.
\item The objects might tiny or could be large; if small we tend to
care about how quickly they can be resolved (i.e., latency) and
if large we need to be careful not to overfull Redis' database
as it's a memory-based system.
}

To make this robust and flexible, we use a \code{object_store} object,
which will allow objects to be stored either directly in Redis, or
offloaded onto some "large" data store based on their
size. Currently, we provide support only for offloading to disk,
but in future hope to expand this.

When we create a value in the store (or reference a value that
already exists) we assign a tag into the database; this means that
we have for a value with hash \code{abc123} and tag \code{def789}
\itemize{
\item \verb{prefix:data["abc123"] => [1] f5 26 a5 b7 26 93 b3 41 b7 d0 b0...}
(the data stored, serialised into a redis hash by its hash, as a
binary object.
\item \verb{prefix:tag_hash:def789 => \{abc123\}} (a set of hashes used by our tag)
\item \verb{prefix:hash_tag:abc123 => \{def789\}} (a set of tags that
reference our hash)
}

If we also used the value with hash \code{abc123} with tag \code{fed987}
this would look like
\itemize{
\item \verb{prefix:data[abc123] => [1] f5 26 a5 b7 26 93 b3 41 b7 d0 b0...}
hash, as a binary object.
\item \verb{prefix:tag_hash:def789 => \{abc123\}}
\item \verb{prefix:tag_hash:fed987 => \{abc123\}}
\item \verb{prefix:hash_tag:abc123 => \{def789, fed987\}}
}

As tags are dropped, then the references are dropped from the set
\code{prefix:hash_tag:abc123} and when that set becomes empty then we
can delete \code{prefix:data[abc123]} as simple form of \href{https://en.wikipedia.org/wiki/Reference_counting}{reference counting}.

For \code{rrq} we will use \code{task_id}s as a tag.

For dealing with large data, we "offload" large data into a
secondary store. This replaces the redis hash of \verb{hash => value}
with something else. Currently the only alternative we offer is
\code{\link{object_store_offload_disk}} which will save the binary
representation of the object at the path \verb{<path>/<hash>} and will
allow large values to be shared between controller and worker so
long as they share a common filesystem.
}
\details{
Create an object store. Typically this is not used by end-users,
and is used internally by \link{rrq_controller}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{object_store$new()}}
\item \href{#method-list}{\code{object_store$list()}}
\item \href{#method-tags}{\code{object_store$tags()}}
\item \href{#method-get}{\code{object_store$get()}}
\item \href{#method-mget}{\code{object_store$mget()}}
\item \href{#method-set}{\code{object_store$set()}}
\item \href{#method-mset}{\code{object_store$mset()}}
\item \href{#method-location}{\code{object_store$location()}}
\item \href{#method-drop}{\code{object_store$drop()}}
\item \href{#method-destroy}{\code{object_store$destroy()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
Create a new object store (or connect to an existing one)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{object_store$new(con, prefix, max_size = Inf, offload = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{con}}{A redis connection object}

\item{\code{prefix}}{A key prefix to use; we will make a number of keys
that start with this prefix.}

\item{\code{max_size}}{The maximum serialised object size, in bytes.
If the serialised object is larger than this size it will
be placed into the offload storage, as provided by the
\code{offload} argument. By default this is \code{Inf} so all values will
be stored in the redis database.}

\item{\code{offload}}{An offload storage object. We provide one of
these \code{\link{object_store_offload_disk}}, which saves objects
to on disk after serialisation). This interface is
subject to change. If not given but an object exceeds \code{max_size}
an error will be thrown.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-list"></a>}}
\if{latex}{\out{\hypertarget{method-list}{}}}
\subsection{Method \code{list()}}{
List all hashes of data known to this data store
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{object_store$list()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-tags"></a>}}
\if{latex}{\out{\hypertarget{method-tags}{}}}
\subsection{Method \code{tags()}}{
List all tags known to this data store
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{object_store$tags()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get"></a>}}
\if{latex}{\out{\hypertarget{method-get}{}}}
\subsection{Method \code{get()}}{
Get a single object by its hash
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{object_store$get(hash)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{hash}}{a single hash to use}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-mget"></a>}}
\if{latex}{\out{\hypertarget{method-mget}{}}}
\subsection{Method \code{mget()}}{
Get a number objects by their hashes. Unlike \verb{$get()} this
method accepts a vector of hash (length 0, 1, or more than 1)
and returns a list of the same length.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{object_store$mget(hash)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{hash}}{A vector of object hashes}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-set"></a>}}
\if{latex}{\out{\hypertarget{method-set}{}}}
\subsection{Method \code{set()}}{
Set an object into the object store, returning the hash
of that object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{object_store$set(value, tag, serialize = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{value}}{The object to save}

\item{\code{tag}}{A string used to associate with the object. When
all tags that point to a particular object value have been
removed, then the object will be deleted from the store.}

\item{\code{serialize}}{Logical, indicating if the values should be
serialised first. Typically this should be \code{TRUE}, but for
advanced use if you already have a serialised object you can
pass that in and set to \code{FALSE}. Note that only objects
serialised with \code{redux::object_to_bin} (or with
\code{serialize(..., xdr = FALSE)}) will be accepted.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-mset"></a>}}
\if{latex}{\out{\hypertarget{method-mset}{}}}
\subsection{Method \code{mset()}}{
Set a number of objects into the store. Unlike \verb{$set()},
this method sets a list of objects into the store at once,
and returns a character vector of hashes the same length as the
list of values.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{object_store$mset(value, tag, serialize = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{value}}{A list of objects to save}

\item{\code{tag}}{A string used to associate with the object. When
all tags that point to a particular object value have been
removed, then the object will be deleted from the store.
The same tag is used for all objects.}

\item{\code{serialize}}{Logical, indicating if the values should be
serialised first. Typically this should be \code{TRUE}, but for
advanced use if you already have a serialised object you can
pass that in and set to \code{FALSE}. Note that only objects
serialised with \code{redux::object_to_bin} (or with
\code{serialize(..., xdr = FALSE)}) will be accepted.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-location"></a>}}
\if{latex}{\out{\hypertarget{method-location}{}}}
\subsection{Method \code{location()}}{
Return the storage locations of a set of hashes. Currently
the location may be \code{redis} (stored directly in the redis server),
\code{offload} (stored in the offload storage) or \code{NA} (if not found,
and if \code{error = FALSE}).
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{object_store$location(hash, error = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{hash}}{A vector of hashes}

\item{\code{error}}{A logical, indicating if we should throw an error if
a hash is unknown}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-drop"></a>}}
\if{latex}{\out{\hypertarget{method-drop}{}}}
\subsection{Method \code{drop()}}{
Delete tags from the store. This will dissociate the
tags from any hashes they references and if that means that no tag
points to a hash then the data at that hash will be removed. We return
(invisibly) a character vector of any dropped hashes.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{object_store$drop(tag)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{tag}}{Vector of tags to drop}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-destroy"></a>}}
\if{latex}{\out{\hypertarget{method-destroy}{}}}
\subsection{Method \code{destroy()}}{
Remove all data from the store, and all the stores
metadata
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{object_store$destroy()}\if{html}{\out{</div>}}
}

}
}
