% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rrq_controller.R
\name{rrq_controller}
\alias{rrq_controller}
\title{rrq queue controller}
\description{
rrq queue controller

rrq queue controller
}
\details{
A queue controller.  Use this to interact with a queue/cluster.

The \code{type} parameter indicates the strategy used to stop
workers, and interacts with other parameters. The strategies used by
the different values are:
\itemize{
\item \code{message}, in which case a \code{STOP} message will be sent to the
worker, which they will receive after finishing any currently
running task (if \code{RUNNING}; \code{IDLE} workers will stop immediately).
\item \code{kill}, in which case a kill signal will be sent via the heartbeat
(if the worker is using one). This will kill the worker even if
is currently working on a task, eventually leaving that task with
a status of \code{DIED}.
\item \code{kill_local}, in which case a kill signal is sent using operating
system signals, which requires that the worker is on the same
machine as the controller.
}
}
\section{Task lifecycle}{

\itemize{
\item A task is queued with \verb{$enqueue()}, at which point it becomes \code{PENDING}
\item Once a worker selects the task to run, it becomes \code{RUNNING}
\item If the task completes successfully without error it becomes \code{COMPLETE}
\item If the task throws an error, it becomes \code{ERROR}
\item If the task was cancelled (e.g., via \verb{$task_cancel()}) it becomes
\code{CANCELLED}
\item If the task is killed by an external process, crashes or the worker
dies (and is running a heartbeat) then the task becomes \code{DIED}.
\item The status of an unknown task is \code{MISSING}
}
}

\section{Worker lifecycle}{

\itemize{
\item A worker appears and is \code{IDLE}
\item When running a task it is \code{BUSY}
\item If it receives a \code{PAUSE} message it becomes \code{PAUSED} until it
receives a \code{RESUME} message
\item If it exits cleanly (e.g., via a \code{STOP} message or a timeout) it
becomes \code{EXITED}
\item If it crashes and was running a heartbeat, it becomes \code{LOST}
}
}

\section{Messages}{


Most of the time workers process tasks, but you can also send them
"messages". Messages take priority over tasks, so if a worker
becomes idle (by coming online or by finishing a task) it will
consume all available messages before starting on a new task,
even if both are available.

Each message has a "command" and may have "arguments" to that
command. The supported messages are:
\itemize{
\item \code{PING} (no args): "ping" the worker, if alive it will respond
with "PONG"
\item \code{ECHO} (accepts an argument of a string): Print a string to the
terminal and log of the worker. Will respond with \code{OK} once the
message has been printed.
\item \code{EVAL} (accepts a string or a quoted expression): Evaluate an
arbitrary R expression on the worker. Responds with the value of
this expression.
\item \code{STOP} (accepts a string to print as the worker exits, defaults
to "BYE"): Tells the worker to stop.
\item \code{INFO} (no args): Returns information about the worker (versions
of packages, hostname, pid, etc).
\item \code{PAUSE} (no args): Tells the worker to stop accepting tasks
(until it receives a \code{RESUME} message). Messages are processed
as normal.
\item \code{RESUME} (no args): Tells a paused worker to resume accepting
tasks.
\item \code{REFRESH} (no args): Tells the worker to rebuild their
environment with the \code{create} method.
\item \code{TIMEOUT_SET} (accepts a number, representing seconds): Updates
the worker timeout - the length of time after which it will exit
if it has not processed a task.
\item \code{TIMEOUT_GET} (no args): Tells the worker to respond with its
current timeout.
}
}

\section{Bulk interface (\code{lapply})}{


The bulk interface is a bit more complicated than the basic
\code{enqueue} interface. In the majority of cases you can ignore the
details and use the \code{lapply} method in much the same way as you
would in normal R. Assuming that \code{obj} is your \code{rrq_controller}
object, you might write:

\if{html}{\out{<div class="sourceCode">}}\preformatted{ans <- obj$lapply(1:10, sqrt)
}\if{html}{\out{</div>}}

which will return the same thing as \code{lapply(1:10, sqrt)} (provided
that you have a Redis server running and workers registered)

There is some sleight of hand here, though as we need to identify
that it is the \emph{symbol} \code{sqrt} that matters there corresponding
to the builtin \link{sqrt} function. You can make this more explicit
by passing in the name of the function using \verb{$lapply_()}

\if{html}{\out{<div class="sourceCode">}}\preformatted{ans <- obj$lapply(1:10, quote(sqrt))
}\if{html}{\out{</div>}}

The same treatment applies to the dots; this is allowed:

\if{html}{\out{<div class="sourceCode">}}\preformatted{b <- 2
ans <- obj$lapply(1:10, log, base = b)
}\if{html}{\out{</div>}}

But this will look up the bindings of \code{log} and \code{b} in the context
in which the call is made. This may not always do what is
expected, so you can use the names directly:

\if{html}{\out{<div class="sourceCode">}}\preformatted{b <- 2
ans <- obj$lapply_(1:10, quote(log), base = quote(b))
}\if{html}{\out{</div>}}
}

\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{con}}{The redis connection. This is part of the
public API and can be used to access the same redis database
as the queue.}

\item{\code{queue_id}}{The queue id used on creation. This is read-only
after creation.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-rrq_controller-new}{\code{rrq_controller$new()}}
\item \href{#method-rrq_controller-destroy}{\code{rrq_controller$destroy()}}
\item \href{#method-rrq_controller-envir}{\code{rrq_controller$envir()}}
\item \href{#method-rrq_controller-enqueue}{\code{rrq_controller$enqueue()}}
\item \href{#method-rrq_controller-enqueue_}{\code{rrq_controller$enqueue_()}}
\item \href{#method-rrq_controller-lapply}{\code{rrq_controller$lapply()}}
\item \href{#method-rrq_controller-lapply_}{\code{rrq_controller$lapply_()}}
\item \href{#method-rrq_controller-enqueue_bulk}{\code{rrq_controller$enqueue_bulk()}}
\item \href{#method-rrq_controller-enqueue_bulk_}{\code{rrq_controller$enqueue_bulk_()}}
\item \href{#method-rrq_controller-bulk_wait}{\code{rrq_controller$bulk_wait()}}
\item \href{#method-rrq_controller-task_list}{\code{rrq_controller$task_list()}}
\item \href{#method-rrq_controller-task_exists}{\code{rrq_controller$task_exists()}}
\item \href{#method-rrq_controller-task_status}{\code{rrq_controller$task_status()}}
\item \href{#method-rrq_controller-task_progress}{\code{rrq_controller$task_progress()}}
\item \href{#method-rrq_controller-task_overview}{\code{rrq_controller$task_overview()}}
\item \href{#method-rrq_controller-task_position}{\code{rrq_controller$task_position()}}
\item \href{#method-rrq_controller-task_preceeding}{\code{rrq_controller$task_preceeding()}}
\item \href{#method-rrq_controller-task_result}{\code{rrq_controller$task_result()}}
\item \href{#method-rrq_controller-tasks_result}{\code{rrq_controller$tasks_result()}}
\item \href{#method-rrq_controller-task_wait}{\code{rrq_controller$task_wait()}}
\item \href{#method-rrq_controller-tasks_wait}{\code{rrq_controller$tasks_wait()}}
\item \href{#method-rrq_controller-task_delete}{\code{rrq_controller$task_delete()}}
\item \href{#method-rrq_controller-task_cancel}{\code{rrq_controller$task_cancel()}}
\item \href{#method-rrq_controller-task_data}{\code{rrq_controller$task_data()}}
\item \href{#method-rrq_controller-task_times}{\code{rrq_controller$task_times()}}
\item \href{#method-rrq_controller-queue_length}{\code{rrq_controller$queue_length()}}
\item \href{#method-rrq_controller-queue_list}{\code{rrq_controller$queue_list()}}
\item \href{#method-rrq_controller-queue_remove}{\code{rrq_controller$queue_remove()}}
\item \href{#method-rrq_controller-deferred_list}{\code{rrq_controller$deferred_list()}}
\item \href{#method-rrq_controller-worker_len}{\code{rrq_controller$worker_len()}}
\item \href{#method-rrq_controller-worker_list}{\code{rrq_controller$worker_list()}}
\item \href{#method-rrq_controller-worker_list_exited}{\code{rrq_controller$worker_list_exited()}}
\item \href{#method-rrq_controller-worker_info}{\code{rrq_controller$worker_info()}}
\item \href{#method-rrq_controller-worker_status}{\code{rrq_controller$worker_status()}}
\item \href{#method-rrq_controller-worker_log_tail}{\code{rrq_controller$worker_log_tail()}}
\item \href{#method-rrq_controller-worker_task_id}{\code{rrq_controller$worker_task_id()}}
\item \href{#method-rrq_controller-worker_delete_exited}{\code{rrq_controller$worker_delete_exited()}}
\item \href{#method-rrq_controller-worker_stop}{\code{rrq_controller$worker_stop()}}
\item \href{#method-rrq_controller-worker_detect_exited}{\code{rrq_controller$worker_detect_exited()}}
\item \href{#method-rrq_controller-worker_process_log}{\code{rrq_controller$worker_process_log()}}
\item \href{#method-rrq_controller-worker_config_save}{\code{rrq_controller$worker_config_save()}}
\item \href{#method-rrq_controller-worker_config_list}{\code{rrq_controller$worker_config_list()}}
\item \href{#method-rrq_controller-worker_config_read}{\code{rrq_controller$worker_config_read()}}
\item \href{#method-rrq_controller-worker_load}{\code{rrq_controller$worker_load()}}
\item \href{#method-rrq_controller-message_send}{\code{rrq_controller$message_send()}}
\item \href{#method-rrq_controller-message_has_response}{\code{rrq_controller$message_has_response()}}
\item \href{#method-rrq_controller-message_get_response}{\code{rrq_controller$message_get_response()}}
\item \href{#method-rrq_controller-message_response_ids}{\code{rrq_controller$message_response_ids()}}
\item \href{#method-rrq_controller-message_send_and_wait}{\code{rrq_controller$message_send_and_wait()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-new"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-new}{}}}
\subsection{Method \code{new()}}{
Constructor
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$new(queue_id, con = redux::hiredis())}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{queue_id}}{An identifier for the queue.  This will prefix all
keys in redis, so a prefix might be useful here depending on
your use case (e.g. \code{rrq:<user>:<id>})}

\item{\code{con}}{A redis connection. The default tries to create a redis
connection using default ports, or environment variables set as in
\code{\link[redux:hiredis]{redux::hiredis()}}}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-destroy"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-destroy}{}}}
\subsection{Method \code{destroy()}}{
Entirely destroy a queue, by deleting all keys
associated with it from the Redis database. This is a very
destructive action and cannot be undone.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$destroy(
  delete = TRUE,
  worker_stop_type = "message",
  worker_stop_timeout = 0
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{delete}}{Either \code{TRUE} (the default) indicating that the
keys should be immediately deleted. Alternatively, provide an
integer value and the keys will instead be marked for future
deletion by "expiring" after this many seconds, using Redis'
\code{EXPIRE} command.}

\item{\code{worker_stop_type}}{Passed to \verb{$worker_stop}; Can be one of
"message", "kill" or "kill_local". The "kill" method requires that
the workers are using a heartbeat, and "kill_local" requires that
the workers are on the same machine as the controller. However,
these may be faster to stop workers than "message", which will
wait until any task is finished.}

\item{\code{worker_stop_timeout}}{A timeout to pass to the worker if
using \code{type = "message"}}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-envir"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-envir}{}}}
\subsection{Method \code{envir()}}{
Register a function to create an environment when
creating a worker. When a worker starts, they will run this
function.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$envir(create, notify = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{create}}{A function that will create an environment. It will
be called with one parameter (an environment), in a fresh R
session. The function \code{\link[=rrq_envir]{rrq_envir()}} can be used to
create a suitable function for the most common case (loading
packages and sourcing scripts).}

\item{\code{notify}}{Boolean, indicating if we should send a \code{REFRESH}
message to all workers to update their environment.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-enqueue"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-enqueue}{}}}
\subsection{Method \code{enqueue()}}{
Queue an expression
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$enqueue(
  expr,
  envir = parent.frame(),
  queue = NULL,
  separate_process = FALSE,
  timeout = NULL,
  depends_on = NULL,
  export = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{expr}}{Any R expression, unevaluated}

\item{\code{envir}}{The environment that you would run this expression in
locally. This will be used to copy across any dependent variables.
For example, if your expression is \code{sum(1 + a)}, we will also send
the value of \code{a} to the worker along with the expression.}

\item{\code{queue}}{The queue to add the task to; if not specified the
"default" queue (which all workers listen to) will be
used. If you have configured workers to listen to more than
one queue you can specify that here. Be warned that if you
push jobs onto a queue with no worker, it will queue forever.}

\item{\code{separate_process}}{Logical, indicating if the task should be
run in a separate process on the worker. If \code{TRUE}, then the
worker runs the task in a separate process using the \code{callr}
package. This means that the worker environment is completely
clean, subsequent runs are not affected by preceding ones.
The downside of this approach is a considerable overhead in
starting the external process and transferring data back.}

\item{\code{timeout}}{Optionally, a maximum allowed running time, in
seconds. This parameter only has an effect if \code{separate_process}
is \code{TRUE}. If given, then if the task takes longer than this
time it will be stopped and the task status set to \code{TIMEOUT}.}

\item{\code{depends_on}}{Vector or list of IDs of tasks which must have
completed before this job can be run. Once all dependent tasks
have been successfully run, this task will get added to the
queue. If the dependent task fails then this task will be
removed from the queue.}

\item{\code{export}}{Optionally a list of variables to export for the
calculation. If given then no automatic analysis of the
expression is done. It should be either a named list (name
being the variable name, value being the value) or a
character vector of variables that can be found immediately
within \code{envir}. Use this where you have already done analysis
of the expression (e.g., with the future package / globals)
or where you want to avoid moving large objects through Redis
that will be available on the remote workers due to how you
have configured your worker environment.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-enqueue_"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-enqueue_}{}}}
\subsection{Method \code{enqueue_()}}{
Queue an expression
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$enqueue_(
  expr,
  envir = parent.frame(),
  queue = NULL,
  separate_process = FALSE,
  timeout = NULL,
  depends_on = NULL,
  export = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{expr}}{Any R expression, quoted; use this to use \verb{$enqueue}
in a programmatic context where you want to construct expressions
directly (e.g., \code{bquote(log(.(x)), list(x = 10))}}

\item{\code{envir}}{The environment that you would run this expression in
locally. This will be used to copy across any dependent variables.
For example, if your expression is \code{sum(1 + a)}, we will also send
the value of \code{a} to the worker along with the expression.}

\item{\code{queue}}{The queue to add the task to; if not specified the
"default" queue (which all workers listen to) will be
used. If you have configured workers to listen to more than
one queue you can specify that here. Be warned that if you
push jobs onto a queue with no worker, it will queue forever.}

\item{\code{separate_process}}{Logical, indicating if the task should be
run in a separate process on the worker (see \verb{$enqueue} for
details).}

\item{\code{timeout}}{Optionally, a maximum allowed running time, in
seconds (see \verb{$enqueue} for details).}

\item{\code{depends_on}}{Vector or list of IDs of tasks which must have
completed before this job can be run. Once all dependent tasks
have been successfully run, this task will get added to the
queue. If the dependent task fails then this task will be
removed from the queue.}

\item{\code{export}}{Optionally a list of variables to export for the
calculation. See \verb{$enqueue} for details.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-lapply"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-lapply}{}}}
\subsection{Method \code{lapply()}}{
Apply a function over a list of data. This is
equivalent to using \verb{$enqueue()} over each element in the list.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$lapply(
  X,
  FUN,
  ...,
  dots = NULL,
  envir = parent.frame(),
  queue = NULL,
  separate_process = FALSE,
  task_timeout = NULL,
  depends_on = NULL,
  collect_timeout = Inf,
  time_poll = 1,
  progress = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{X}}{A list of data to apply our function against}

\item{\code{FUN}}{A function to be applied to each element of \code{X}}

\item{\code{...}}{Additional arguments to \code{FUN}}

\item{\code{dots}}{As an alternative to \code{...}, you can provide the dots
as a list of additional arguments. This may be easier to program
against.}

\item{\code{envir}}{The environment to use to try and find the function}

\item{\code{queue}}{The queue to add the tasks to (see \verb{$enqueue} for
details).}

\item{\code{separate_process}}{Logical, indicating if the task should be
run in a separate process on the worker (see \verb{$enqueue} for
details).}

\item{\code{task_timeout}}{Optionally, a maximum allowed running time, in
seconds (see the \code{timeout} argument of \verb{$enqueue} for details).}

\item{\code{depends_on}}{Vector or list of IDs of tasks which must have
completed before this job can be run. Once all dependent tasks
have been successfully run, this task will get added to the
queue. If the dependent task fails then this task will be
removed from the queue. Dependencies are applied to all
tasks added to the queue.}

\item{\code{collect_timeout}}{Optional timeout, in seconds, after which an
error will be thrown if all tasks have not completed. If given  as
\code{0}, then we return a handle that can be used to check for tasks
using \code{bulk_wait}}

\item{\code{time_poll}}{Optional time with which to "poll" for
completion (default is 1s, see \verb{$task_wait()} for details)}

\item{\code{progress}}{Optional logical indicating if a progress bar
should be displayed. If \code{NULL} we fall back on the value of the
global option \code{rrq.progress}, and if that is unset display a
progress bar if in an interactive session.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-lapply_"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-lapply_}{}}}
\subsection{Method \code{lapply_()}}{
The "standard evaluation" version of \verb{$lapply()}.
This differs in how the function is found and how dots are passed.
With this version, both are passed by value; this may create more
overhead on the redis server as the values of the variables will
be copied over rather than using their names if possible.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$lapply_(
  X,
  FUN,
  ...,
  dots = NULL,
  envir = parent.frame(),
  queue = NULL,
  separate_process = FALSE,
  task_timeout = NULL,
  depends_on = NULL,
  collect_timeout = Inf,
  time_poll = 1,
  progress = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{X}}{A list of data to apply our function against}

\item{\code{FUN}}{A function to be applied to each element of \code{X}}

\item{\code{...}}{Additional arguments to \code{FUN}}

\item{\code{dots}}{As an alternative to \code{...}, you can provide the dots
as a list of additional arguments. This may be easier to program
against.}

\item{\code{envir}}{The environment to use to try and find the function}

\item{\code{queue}}{The queue to add the tasks to (see \verb{$enqueue} for
details).}

\item{\code{separate_process}}{Logical, indicating if the task should be
run in a separate process on the worker (see \verb{$enqueue} for
details).}

\item{\code{task_timeout}}{Optionally, a maximum allowed running time, in
seconds (see the \code{timeout} argument of \verb{$enqueue} for details).}

\item{\code{depends_on}}{Vector or list of IDs of tasks which must have
completed before this job can be run. Once all dependent tasks
have been successfully run, this task will get added to the
queue. If the dependent task fails then this task will be
removed from the queue. Dependencies are applied to all
tasks added to the queue.}

\item{\code{collect_timeout}}{Optional timeout, in seconds, after which an
error will be thrown if all tasks have not completed. If given  as
\code{0}, then we return a handle that can be used to check for tasks
using \code{bulk_wait}}

\item{\code{time_poll}}{Optional time with which to "poll" for
completion (default is 1s, see \verb{$task_wait()} for details)}

\item{\code{progress}}{Optional logical indicating if a progress bar
should be displayed. If \code{NULL} we fall back on the value of the
global option \code{rrq.progress}, and if that is unset display a
progress bar if in an interactive session.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-enqueue_bulk"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-enqueue_bulk}{}}}
\subsection{Method \code{enqueue_bulk()}}{
Send a bulk set of tasks to your workers.
This function is a bit like a mash-up of \link{Map} and \link{do.call},
when used with a \link{data.frame} argument, which is typically what
is provided. Rather than \verb{$lapply()} which applies \code{FUN} to each
element of \code{X}, \verb{enqueue_bulk will apply over each row of }X\verb{, spreading the columms out as arguments. If you have a function }f(a, b)\verb{and a [data.frame] with columns}a\code{and}b` this
should feel intuitive.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$enqueue_bulk(
  X,
  FUN,
  ...,
  dots = NULL,
  envir = parent.frame(),
  queue = NULL,
  separate_process = FALSE,
  task_timeout = NULL,
  depends_on = NULL,
  collect_timeout = Inf,
  time_poll = 1,
  progress = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{X}}{Typically a \link{data.frame}, which you want to apply \code{FUN}
over, row-wise. The names of the \code{data.frame} must match the
arguments of your function.}

\item{\code{FUN}}{A function}

\item{\code{...}}{Additional arguments to add to every call to \code{FUN}}

\item{\code{dots}}{As an alternative to \code{...}, you can provide the dots
as a list of additional arguments. This may be easier to program
against.}

\item{\code{envir}}{The environment to use to try and find the function}

\item{\code{queue}}{The queue to add the tasks to (see \verb{$enqueue} for
details).}

\item{\code{separate_process}}{Logical, indicating if the task should be
run in a separate process on the worker (see \verb{$enqueue} for
details).}

\item{\code{task_timeout}}{Optionally, a maximum allowed running time, in
seconds (see the \code{timeout} argument of \verb{$enqueue} for details).}

\item{\code{depends_on}}{Vector or list of IDs of tasks which must have
completed before this job can be run. Once all dependent tasks
have been successfully run, this task will get added to the
queue. If the dependent task fails then this task will be
removed from the queue. Dependencies are applied to all
tasks added to the queue.}

\item{\code{collect_timeout}}{Optional timeout, in seconds, after which an
error will be thrown if all tasks have not completed. If given  as
\code{0}, then we return a handle that can be used to check for tasks
using \code{bulk_wait}}

\item{\code{time_poll}}{Optional time with which to "poll" for
completion (default is 1s, see \verb{$task_wait()} for details)}

\item{\code{progress}}{Optional logical indicating if a progress bar
should be displayed. If \code{NULL} we fall back on the value of the
global option \code{rrq.progress}, and if that is unset display a
progress bar if in an interactive session.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-enqueue_bulk_"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-enqueue_bulk_}{}}}
\subsection{Method \code{enqueue_bulk_()}}{
The "standard evaluation" version of \verb{$enqueue_bulk()}.
This differs in how the function is found and how dots are passed.
With this version, both are passed by value; this may create more
overhead on the redis server as the values of the variables will
be copied over rather than using their names if possible.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$enqueue_bulk_(
  X,
  FUN,
  ...,
  dots = NULL,
  envir = parent.frame(),
  queue = NULL,
  separate_process = FALSE,
  task_timeout = NULL,
  depends_on = NULL,
  collect_timeout = Inf,
  time_poll = 1,
  progress = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{X}}{Typically a \link{data.frame}, which you want to apply \code{FUN}
over, row-wise. The names of the \code{data.frame} must match the
arguments of your function.}

\item{\code{FUN}}{A function}

\item{\code{...}}{Additional arguments to add to every call to \code{FUN}}

\item{\code{dots}}{As an alternative to \code{...}, you can provide the dots
as a list of additional arguments. This may be easier to program
against.}

\item{\code{envir}}{The environment to use to try and find the function}

\item{\code{queue}}{The queue to add the tasks to (see \verb{$enqueue} for
details).}

\item{\code{separate_process}}{Logical, indicating if the task should be
run in a separate process on the worker (see \verb{$enqueue} for
details).}

\item{\code{task_timeout}}{Optionally, a maximum allowed running time, in
seconds (see the \code{timeout} argument of \verb{$enqueue} for details).}

\item{\code{depends_on}}{Vector or list of IDs of tasks which must have
completed before this job can be run. Once all dependent tasks
have been successfully run, this task will get added to the
queue. If the dependent task fails then this task will be
removed from the queue. Dependencies are applied to all
tasks added to the queue.}

\item{\code{collect_timeout}}{Optional timeout, in seconds, after which an
error will be thrown if all tasks have not completed. If given  as
\code{0}, then we return a handle that can be used to check for tasks
using \code{bulk_wait}}

\item{\code{time_poll}}{Optional time with which to "poll" for
completion (default is 1s, see \verb{$task_wait()} for details)}

\item{\code{progress}}{Optional logical indicating if a progress bar
should be displayed. If \code{NULL} we fall back on the value of the
global option \code{rrq.progress}, and if that is unset display a
progress bar if in an interactive session.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-bulk_wait"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-bulk_wait}{}}}
\subsection{Method \code{bulk_wait()}}{
Wait for a group of tasks
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$bulk_wait(
  x,
  timeout = Inf,
  time_poll = 1,
  progress = NULL,
  delete = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{x}}{An object of class \code{rrq_bulk}, as created by \verb{$lapply()}}

\item{\code{timeout}}{Optional timeout, in seconds, after which an
error will be thrown if the task has not completed.}

\item{\code{time_poll}}{Optional time with which to "poll" for
completion (default is 1s, see \verb{$task_wait()} for details)}

\item{\code{progress}}{Optional logical indicating if a progress bar
should be displayed. If \code{NULL} we fall back on the value of the
global option \code{rrq.progress}, and if that is unset display a
progress bar if in an interactive session.}

\item{\code{delete}}{Optional logical, indicating if the tasks
should be deleted after collection. Typically this is \code{TRUE}
to prevent build-up of lots of task information in Redis.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-task_list"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-task_list}{}}}
\subsection{Method \code{task_list()}}{
List ids of all tasks known to this rrq controller
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$task_list()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-task_exists"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-task_exists}{}}}
\subsection{Method \code{task_exists()}}{
Test if task with id \code{task_ids} is known to this
rrq controller
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$task_exists(task_ids = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{task_ids}}{Character vector of task ids to check for existence.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-task_status"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-task_status}{}}}
\subsection{Method \code{task_status()}}{
Return a character vector of task statuses. The name
of each element corresponds to a task id, and the value will be
one of the possible statuses ("PENDING", "COMPLETE", etc).
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$task_status(task_ids = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{task_ids}}{Optional character vector of task ids for which you
would like statuses. If not given (or \code{NULL}) then the status of
all task ids known to this rrq controller is returned.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-task_progress"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-task_progress}{}}}
\subsection{Method \code{task_progress()}}{
Retrieve task progress, if set. This will be \code{NULL}
if progress has never been registered, otherwise whatever value
was set - can be an arbitrary R object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$task_progress(task_id)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{task_id}}{A single task id for which the progress is wanted.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-task_overview"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-task_overview}{}}}
\subsection{Method \code{task_overview()}}{
Provide a high level overview of task statuses
for a set of task ids, being the count in major categories of
\code{PENDING}, \code{RUNNING}, \code{COMPLETE} and \code{ERROR}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$task_overview(task_ids = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{task_ids}}{Optional character vector of task ids for which you
would like the overview. If not given (or \code{NULL}) then the status of
all task ids known to this rrq controller is used.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-task_position"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-task_position}{}}}
\subsection{Method \code{task_position()}}{
Find the position of one or more tasks in the queue.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$task_position(task_ids, missing = 0L, queue = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{task_ids}}{Character vector of tasks to find the position for.}

\item{\code{missing}}{Value to return if the task is not found in the queue.
A task will take value \code{missing} if it is running, complete,
errored, deferred etc and a positive integer if it is in the queue,
indicating its position (with 1) being the next task to run.}

\item{\code{queue}}{The name of the queue to query (defaults to the
"default" queue).}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-task_preceeding"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-task_preceeding}{}}}
\subsection{Method \code{task_preceeding()}}{
List the tasks in front of \code{task_id} in the queue.
If the task is missing from the queue this will return NULL. If
the task is next in the queue this will return an empty character
vector.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$task_preceeding(task_id, queue = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{task_id}}{Task to find the position for.}

\item{\code{queue}}{The name of the queue to query (defaults to the
"default" queue).}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-task_result"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-task_result}{}}}
\subsection{Method \code{task_result()}}{
Get the result for a single task (see \verb{$tasks_result}
for a method for efficiently getting multiple results at once).
Returns the value of running the task if it is complete, and an
error otherwise.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$task_result(task_id)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{task_id}}{The single id for which the result is wanted.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-tasks_result"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-tasks_result}{}}}
\subsection{Method \code{tasks_result()}}{
Get the results of a group of tasks, returning them as a
list.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$tasks_result(task_ids)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{task_ids}}{A vector of task ids for which the task result
is wanted.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-task_wait"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-task_wait}{}}}
\subsection{Method \code{task_wait()}}{
Poll for a task to complete, returning the result
when completed. If the task has already completed this is
roughly equivalent to \code{task_result}. See \verb{$tasks_wait} for an
efficient way of doing this for a group of tasks.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$task_wait(
  task_id,
  timeout = Inf,
  time_poll = 1,
  progress = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{task_id}}{The single id that we will wait for}

\item{\code{timeout}}{Optional timeout, in seconds, after which an
error will be thrown if the task has not completed.}

\item{\code{time_poll}}{Optional time with which to "poll" for completion.
By default this will be 1 second; this is the time that each
request for a completed task may block for (however, if the task
is finished before this, the actual time waited for will be less).
Increasing this will reduce the responsiveness of your R session
to interrupting, but will cause slightly less network load.
Values less than 1s are not currently supported as this requires
a very recent Redis server.}

\item{\code{progress}}{Optional logical indicating if a progress bar
should be displayed. If \code{NULL} we fall back on the value of the
global option \code{rrq.progress}, and if that is unset display a
progress bar if in an interactive session.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-tasks_wait"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-tasks_wait}{}}}
\subsection{Method \code{tasks_wait()}}{
Poll for a group of tasks to complete, returning the
result as list when completed. If the tasks have already completed
this is roughly equivalent to \code{tasks_result}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$tasks_wait(
  task_ids,
  timeout = Inf,
  time_poll = 1,
  progress = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{task_ids}}{A vector of task ids to poll for}

\item{\code{timeout}}{Optional timeout, in seconds, after which an
error will be thrown if the task has not completed.}

\item{\code{time_poll}}{Optional time with which to "poll" for
completion (default is 1s, see \verb{$task_wait()} for details)}

\item{\code{progress}}{Optional logical indicating if a progress bar
should be displayed. If \code{NULL} we fall back on the value of the
global option \code{rrq.progress}, and if that is unset display a
progress bar if in an interactive session.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-task_delete"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-task_delete}{}}}
\subsection{Method \code{task_delete()}}{
Delete one or more tasks
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$task_delete(task_ids, check = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{task_ids}}{Vector of task ids to delete}

\item{\code{check}}{Logical indicating if we should check that the tasks
are not running. Deleting running tasks is unlikely to result in
desirable behaviour.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-task_cancel"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-task_cancel}{}}}
\subsection{Method \code{task_cancel()}}{
Cancel a single task. If the task is \code{PENDING} it
will be deleted. If \code{RUNNING} then the task will be stopped if
it was set to run in a separate process (i.e., queued with
\code{separate_process = TRUE}). Dependent tasks will be marked as
impossible.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$task_cancel(task_id, wait = TRUE, delete = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{task_id}}{Id of the task to cancel}

\item{\code{wait}}{Wait for the task to be stopped, if it was running. If
\code{delete} is \code{TRUE}, then we will always wait for the task to stop.}

\item{\code{delete}}{Delete the task after cancelling (if cancelling
was successful).}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Nothing if successfully cancelled, otherwise throws an
error with task_id and status e.g. Task 123 is not running (MISSING)
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-task_data"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-task_data}{}}}
\subsection{Method \code{task_data()}}{
Fetch internal data about a task from Redis
(expert use only).
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$task_data(task_id)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{task_id}}{The id of the task}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-task_times"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-task_times}{}}}
\subsection{Method \code{task_times()}}{
Fetch times for tasks at points in their life cycle.
For each task returns the time of submission, starting
and completion (not necessarily successfully; this includes
errors and interruptions).  If a task has not reached a point
yet (e.g., submitted but not run, or running but not finished)
the time will be \code{NA}).  Times are returned in unix timestamp
format in UTC; you can use \link[redux:redis_time]{redux::redis_time_to_r} to convert
them to a POSIXt object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$task_times(task_ids)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{task_ids}}{Task ids to fetch times for.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-queue_length"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-queue_length}{}}}
\subsection{Method \code{queue_length()}}{
Returns the number of tasks in the queue (waiting for
an available worker).
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$queue_length(queue = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{queue}}{The name of the queue to query (defaults to the
"default" queue).}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-queue_list"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-queue_list}{}}}
\subsection{Method \code{queue_list()}}{
Returns the keys in the task queue.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$queue_list(queue = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{queue}}{The name of the queue to query (defaults to the
"default" queue).}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-queue_remove"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-queue_remove}{}}}
\subsection{Method \code{queue_remove()}}{
Remove task ids from a queue.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$queue_remove(task_ids, queue = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{task_ids}}{Task ids to remove}

\item{\code{queue}}{The name of the queue to query (defaults to the
"default" queue).}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-deferred_list"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-deferred_list}{}}}
\subsection{Method \code{deferred_list()}}{
Return deferred tasks and what they are waiting on.
Note this is in an arbitrary order, tasks will be added to the
queue as their dependencies are satisfied.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$deferred_list()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-worker_len"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-worker_len}{}}}
\subsection{Method \code{worker_len()}}{
Returns the number of active workers
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$worker_len()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-worker_list"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-worker_list}{}}}
\subsection{Method \code{worker_list()}}{
Returns the ids of active workers
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$worker_list()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-worker_list_exited"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-worker_list_exited}{}}}
\subsection{Method \code{worker_list_exited()}}{
Returns the ids of workers known to have exited
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$worker_list_exited()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-worker_info"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-worker_info}{}}}
\subsection{Method \code{worker_info()}}{
Returns a list of information about active
workers (or exited workers if \code{worker_ids} includes them).
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$worker_info(worker_ids = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{worker_ids}}{Optional vector of worker ids. If \code{NULL} then
all active workers are used.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-worker_status"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-worker_status}{}}}
\subsection{Method \code{worker_status()}}{
Returns a character vector of current worker statuses
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$worker_status(worker_ids = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{worker_ids}}{Optional vector of worker ids. If \code{NULL} then
all active workers are used.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-worker_log_tail"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-worker_log_tail}{}}}
\subsection{Method \code{worker_log_tail()}}{
Returns the last (few) elements in the worker
log. The log will be returned as a \link{data.frame} of entries
\code{worker_id} (the worker id), \code{time} (the time in Redis when the
event happened; see \link[redux:redis_time]{redux::redis_time} to convert this to an R
time), \code{command} (the worker command) and \code{message} (the message
corresponding to that command).
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$worker_log_tail(worker_ids = NULL, n = 1)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{worker_ids}}{Optional vector of worker ids. If \code{NULL} then
all active workers are used.}

\item{\code{n}}{Number of elements to select, the default being the single
last entry. Use \code{Inf} or \code{0} to indicate that you want all log entries}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-worker_task_id"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-worker_task_id}{}}}
\subsection{Method \code{worker_task_id()}}{
Returns the task id that each worker is working on,
if any.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$worker_task_id(worker_ids = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{worker_ids}}{Optional vector of worker ids. If \code{NULL} then
all active workers are used.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-worker_delete_exited"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-worker_delete_exited}{}}}
\subsection{Method \code{worker_delete_exited()}}{
Cleans up workers known to have exited
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$worker_delete_exited(worker_ids = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{worker_ids}}{Optional vector of worker ids. If \code{NULL} then
rrq looks for exited workers.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-worker_stop"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-worker_stop}{}}}
\subsection{Method \code{worker_stop()}}{
Stop workers.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$worker_stop(
  worker_ids = NULL,
  type = "message",
  timeout = 0,
  time_poll = 0.05,
  progress = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{worker_ids}}{Optional vector of worker ids. If \code{NULL} then
all active workers will be stopped.}

\item{\code{type}}{The strategy used to stop the workers. Can be \code{message},
\code{kill} or \code{kill_local} (see details).}

\item{\code{timeout}}{Optional timeout; if greater than zero then we poll
for a response from the worker for this many seconds until they
acknowledge the message and stop (only has an effect if \code{type}
is \code{message}).}

\item{\code{time_poll}}{If \code{type} is \code{message} and \code{timeout} is greater
than zero, this is the polling interval used between redis calls.
Increasing this reduces network load but decreases the ability
to interrupt the process.}

\item{\code{progress}}{Optional logical indicating if a progress bar
should be displayed. If \code{NULL} we fall back on the value of the
global option \code{rrq.progress}, and if that is unset display a
progress bar if in an interactive session.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-worker_detect_exited"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-worker_detect_exited}{}}}
\subsection{Method \code{worker_detect_exited()}}{
Detects exited workers through a lapsed heartbeat
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$worker_detect_exited()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-worker_process_log"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-worker_process_log}{}}}
\subsection{Method \code{worker_process_log()}}{
Return the contents of a worker's process log, if
it is located on the same physical storage (including network
storage) as the controller. This will generally behave for
workers started with \link{rrq_worker_spawn} but may require significant
care otherwise.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$worker_process_log(worker_id)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{worker_id}}{The worker for which the log is required}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-worker_config_save"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-worker_config_save}{}}}
\subsection{Method \code{worker_config_save()}}{
Save a worker configuration, which can be used to
start workers with a set of options with the cli. These
correspond to arguments to \link{rrq_worker}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$worker_config_save(
  name,
  time_poll = NULL,
  timeout = NULL,
  queue = NULL,
  heartbeat_period = NULL,
  verbose = NULL,
  overwrite = TRUE,
  timeout_poll = 1,
  timeout_die = 2
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{name}}{Name for this configuration}

\item{\code{time_poll}}{Poll time.  Longer values here will reduce the
impact on the database but make workers less responsive to being
killed with an interrupt.  The default should be good for most
uses, but shorter values are used for debugging.}

\item{\code{timeout}}{Optional timeout to set for the worker.  This is
(roughly) equivalent to issuing a \code{TIMEOUT_SET} message
after initialising the worker, except that it's guaranteed to be
run by all workers.}

\item{\code{queue}}{Optional character vector of queues to listen on
for jobs. There is a default queue which is always listened
on (called 'default'). You can specify additional names here
and jobs put onto these queues with \verb{$enqueue()} will have
\emph{higher} priority than the default. You can explicitly list
the "default" queue (e.g., \code{queue = c("high", "default", "low")}) to set the position of the default queue.}

\item{\code{heartbeat_period}}{Optional period for the heartbeat.  If
non-NULL then a heartbeat process will be started (using
\code{\link{rrq_heartbeat}} which can be used to build fault tolerant queues.}

\item{\code{verbose}}{Logical, indicating if the worker should print
logging output to the screen.  Logging to screen has a small but
measurable performance cost, and if you will not collect system
logs from the worker then it is wasted time.  Logging to the
redis server is always enabled.}

\item{\code{overwrite}}{Logical, indicating if an existing configuration
with this \code{name} should be overwritten if it exists (if
\code{overwrite = FALSE} and the configuration exists an error will
be thrown).}

\item{\code{timeout_poll}}{Optional timeout indicating how long to wait
for a background process to produce stdout or stderr. Only used
for tasks queued with \code{separate_process} \code{TRUE}.}

\item{\code{timeout_die}}{Optional timeout indicating how long to wait
wait for the background process to respond to SIGTERM before
we stop the worker. Only used for tasks queued with
\code{separate_process} \code{TRUE}.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-worker_config_list"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-worker_config_list}{}}}
\subsection{Method \code{worker_config_list()}}{
Return names of worker configurations saved by
\verb{$worker_config_save}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$worker_config_list()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-worker_config_read"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-worker_config_read}{}}}
\subsection{Method \code{worker_config_read()}}{
Return the value of a of worker configuration saved by
\verb{$worker_config_save}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$worker_config_read(name)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{name}}{Name of the configuration
Report on worker "load" (the number of workers being used over
time). Reruns an object of class \code{worker_load}, for which a
\code{mean} method exists (this method is a work in progress and the
interface may change).}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-worker_load"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-worker_load}{}}}
\subsection{Method \code{worker_load()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$worker_load(worker_ids = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{worker_ids}}{Optional vector of worker ids. If \code{NULL} then
all active workers are used.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-message_send"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-message_send}{}}}
\subsection{Method \code{message_send()}}{
Send a message to workers. Sending a message returns
a message id, which can be used to poll for a response with the
other \verb{message_*} methods.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$message_send(command, args = NULL, worker_ids = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{command}}{A command, such as \code{PING}, \code{PAUSE}; see the Messages
section of the Details for al messages.}

\item{\code{args}}{Arguments to the command, if supported}

\item{\code{worker_ids}}{Optional vector of worker ids to send the message
to. If \code{NULL} then the message will be sent to all active workers.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-message_has_response"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-message_has_response}{}}}
\subsection{Method \code{message_has_response()}}{
Detect if a response is available for a message
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$message_has_response(
  message_id,
  worker_ids = NULL,
  named = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{message_id}}{The message id}

\item{\code{worker_ids}}{Optional vector of worker ids. If \code{NULL} then
all active workers are used (note that this may differ to the set
of workers that the message was sent to!)}

\item{\code{named}}{Logical, indicating if the return vector should be named}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-message_get_response"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-message_get_response}{}}}
\subsection{Method \code{message_get_response()}}{
Get response to messages, waiting until the
message has been responded to.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$message_get_response(
  message_id,
  worker_ids = NULL,
  named = TRUE,
  delete = FALSE,
  timeout = 0,
  time_poll = 0.05,
  progress = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{message_id}}{The message id}

\item{\code{worker_ids}}{Optional vector of worker ids. If \code{NULL} then
all active workers are used (note that this may differ to the set
of workers that the message was sent to!)}

\item{\code{named}}{Logical, indicating if the return value should be
named by worker id.}

\item{\code{delete}}{Logical, indicating if messages should be deleted
after retrieval}

\item{\code{timeout}}{Integer, representing seconds to wait until the
response has been received. An error will be thrown if a
response has not been received in this time.}

\item{\code{time_poll}}{If \code{timeout} is greater
than zero, this is the polling interval used between redis calls.
Increasing this reduces network load but increases the time that
may be waited for.}

\item{\code{progress}}{Optional logical indicating if a progress bar
should be displayed. If \code{NULL} we fall back on the value of the
global option \code{rrq.progress}, and if that is unset display a
progress bar if in an interactive session.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-message_response_ids"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-message_response_ids}{}}}
\subsection{Method \code{message_response_ids()}}{
Return ids for messages with responses for a
particular worker.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$message_response_ids(worker_id)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{worker_id}}{The worker id}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-message_send_and_wait"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-message_send_and_wait}{}}}
\subsection{Method \code{message_send_and_wait()}}{
Send a message and wait for responses.
This is a helper function around \code{message_send} and
\code{message_get_response}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$message_send_and_wait(
  command,
  args = NULL,
  worker_ids = NULL,
  named = TRUE,
  delete = TRUE,
  timeout = 600,
  time_poll = 0.05,
  progress = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{command}}{A command, such as \code{PING}, \code{PAUSE}; see the Messages
section of the Details for al messages.}

\item{\code{args}}{Arguments to the command, if supported}

\item{\code{worker_ids}}{Optional vector of worker ids to send the message
to. If \code{NULL} then the message will be sent to all active workers.}

\item{\code{named}}{Logical, indicating if the return value should be
named by worker id.}

\item{\code{delete}}{Logical, indicating if messages should be deleted
after retrieval}

\item{\code{timeout}}{Integer, representing seconds to wait until the
response has been received. An error will be thrown if a
response has not been received in this time.}

\item{\code{time_poll}}{If \code{timeout} is greater
than zero, this is the polling interval used between redis calls.
Increasing this reduces network load but increases the time that
may be waited for.}

\item{\code{progress}}{Optional logical indicating if a progress bar
should be displayed. If \code{NULL} we fall back on the value of the
global option \code{rrq.progress}, and if that is unset display a
progress bar if in an interactive session.}
}
\if{html}{\out{</div>}}
}
}
}
