% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rrq_controller.R
\name{rrq_controller}
\alias{rrq_controller}
\title{rrq queue controller}
\description{
A queue controller.  Use this to interact with a queue/cluster.
}
\section{Task lifecycle}{

\itemize{
\item A task is queued with \verb{$enqueue()}, at which point it becomes \code{PENDING}
\item Once a worker selects the task to run, it becomes \code{RUNNING}
\item If the task completes successfully without error it becomes \code{COMPLETE}
\item If the task throws an error, it becomes \code{ERROR}
\item If the task was cancelled (e.g., via \verb{$task_cancel()}) it becomes
\code{CANCELLED}
\item If the task is killed by an external process, crashes or the worker
dies (and is running a heartbeat) then the task becomes \code{DIED}.
\item The status of an unknown task is \code{MISSING}
\item Tasks in any terminal state (except \code{IMPOSSIBLE}) may be retried
with \code{task_retry} at which point they become \code{MOVED}, see
\code{vignette("fault-tolerance")} for details
}
}

\section{Worker lifecycle}{

\itemize{
\item A worker appears and is \code{IDLE}
\item When running a task it is \code{BUSY}
\item If it receives a \code{PAUSE} message it becomes \code{PAUSED} until it
receives a \code{RESUME} message
\item If it exits cleanly (e.g., via a \code{STOP} message or a timeout) it
becomes \code{EXITED}
\item If it crashes and was running a heartbeat, it becomes \code{LOST}
}
}

\section{Messages}{


Most of the time workers process tasks, but you can also send them
"messages". Messages take priority over tasks, so if a worker
becomes idle (by coming online or by finishing a task) it will
consume all available messages before starting on a new task,
even if both are available.

Each message has a "command" and may have "arguments" to that
command. The supported messages are:
\itemize{
\item \code{PING} (no args): "ping" the worker, if alive it will respond
with "PONG"
\item \code{ECHO} (accepts an argument of a string): Print a string to the
terminal and log of the worker. Will respond with \code{OK} once the
message has been printed.
\item \code{EVAL} (accepts a string or a quoted expression): Evaluate an
arbitrary R expression on the worker. Responds with the value of
this expression.
\item \code{STOP} (accepts a string to print as the worker exits, defaults
to "BYE"): Tells the worker to stop.
\item \code{INFO} (no args): Returns information about the worker (versions
of packages, hostname, pid, etc).
\item \code{PAUSE} (no args): Tells the worker to stop accepting tasks
(until it receives a \code{RESUME} message). Messages are processed
as normal.
\item \code{RESUME} (no args): Tells a paused worker to resume accepting
tasks.
\item \code{REFRESH} (no args): Tells the worker to rebuild their
environment with the \code{create} method.
\item \code{TIMEOUT_SET} (accepts a number, representing seconds): Updates
the worker timeout - the length of time after which it will exit
if it has not processed a task.
\item \code{TIMEOUT_GET} (no args): Tells the worker to respond with its
current timeout.
}
}

\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{con}}{The redis connection. This is part of the
public API and can be used to access the same redis database
as the queue.}

\item{\code{queue_id}}{The queue id used on creation. This is read-only
after creation.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-rrq_controller-new}{\code{rrq_controller$new()}}
\item \href{#method-rrq_controller-to_v2}{\code{rrq_controller$to_v2()}}
\item \href{#method-rrq_controller-envir}{\code{rrq_controller$envir()}}
\item \href{#method-rrq_controller-enqueue}{\code{rrq_controller$enqueue()}}
\item \href{#method-rrq_controller-enqueue_}{\code{rrq_controller$enqueue_()}}
\item \href{#method-rrq_controller-task_status}{\code{rrq_controller$task_status()}}
\item \href{#method-rrq_controller-task_result}{\code{rrq_controller$task_result()}}
\item \href{#method-rrq_controller-tasks_result}{\code{rrq_controller$tasks_result()}}
\item \href{#method-rrq_controller-task_wait}{\code{rrq_controller$task_wait()}}
\item \href{#method-rrq_controller-task_retry}{\code{rrq_controller$task_retry()}}
\item \href{#method-rrq_controller-queue_length}{\code{rrq_controller$queue_length()}}
\item \href{#method-rrq_controller-queue_list}{\code{rrq_controller$queue_list()}}
\item \href{#method-rrq_controller-worker_log_tail}{\code{rrq_controller$worker_log_tail()}}
\item \href{#method-rrq_controller-worker_stop}{\code{rrq_controller$worker_stop()}}
\item \href{#method-rrq_controller-worker_detect_exited}{\code{rrq_controller$worker_detect_exited()}}
\item \href{#method-rrq_controller-worker_config_save}{\code{rrq_controller$worker_config_save()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-new"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-new}{}}}
\subsection{Method \code{new()}}{
Constructor
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$new(
  queue_id,
  con = redux::hiredis(),
  timeout_task_wait = NULL,
  follow = NULL,
  check_version = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{queue_id}}{An identifier for the queue.  This will prefix all
keys in redis, so a prefix might be useful here depending on
your use case (e.g. \code{rrq:<user>:<id>})}

\item{\code{con}}{A redis connection. The default tries to create a redis
connection using default ports, or environment variables set as in
\code{\link[redux:hiredis]{redux::hiredis()}}}

\item{\code{timeout_task_wait}}{An optional default timeout to use when
waiting for tasks (e.g., with \verb{$task_wait()}, \verb{$tasks_wait()},
etc). If not given, then we fall back on the
global option \code{rrq.timeout_task_wait}, and if that is not set,}

\item{\code{follow}}{An optional default logical to use for tasks
that may (or may not) be retried. If not given we fall back
on the global option \code{rrq.follow}, and if that is not set then
\code{TRUE} (i.e., we do follow). The value \code{follow = TRUE} is
potentially slower than \code{follow = FALSE} for some operations
because we need to dereference every task id. If you never use
\verb{$task_retry} then this dereference never has an effect and we
can skip it. See \code{vignette("fault-tolerance")} for more
information.}

\item{\code{check_version}}{Check that the schema version is correct}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-to_v2"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-to_v2}{}}}
\subsection{Method \code{to_v2()}}{
Convert controller to the new-style object.
Please don't use this in packages directly
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$to_v2()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-envir"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-envir}{}}}
\subsection{Method \code{envir()}}{
Register a function to create an environment when
creating a worker. When a worker starts, they will run this
function.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$envir(create, notify = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{create}}{A function that will create an environment. It will
be called with one parameter (an environment), in a fresh R
session. The function \code{\link[=rrq_envir]{rrq_envir()}} can be used to
create a suitable function for the most common case (loading
packages and sourcing scripts).}

\item{\code{notify}}{Boolean, indicating if we should send a \code{REFRESH}
message to all workers to update their environment.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-enqueue"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-enqueue}{}}}
\subsection{Method \code{enqueue()}}{
Queue an expression
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$enqueue(
  expr,
  envir = parent.frame(),
  queue = NULL,
  separate_process = FALSE,
  timeout_task_run = NULL,
  depends_on = NULL,
  export = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{expr}}{Any R expression, unevaluated}

\item{\code{envir}}{The environment that you would run this expression in
locally. This will be used to copy across any dependent variables.
For example, if your expression is \code{sum(1 + a)}, we will also send
the value of \code{a} to the worker along with the expression.}

\item{\code{queue}}{The queue to add the task to; if not specified the
"default" queue (which all workers listen to) will be
used. If you have configured workers to listen to more than
one queue you can specify that here. Be warned that if you
push jobs onto a queue with no worker, it will queue forever.}

\item{\code{separate_process}}{Logical, indicating if the task should be
run in a separate process on the worker. If \code{TRUE}, then the
worker runs the task in a separate process using the \code{callr}
package. This means that the worker environment is completely
clean, subsequent runs are not affected by preceding ones.
The downside of this approach is a considerable overhead in
starting the external process and transferring data back.}

\item{\code{timeout_task_run}}{Optionally, a maximum allowed running time, in
seconds. This parameter only has an effect if \code{separate_process}
is \code{TRUE}. If given, then if the task takes longer than this
time it will be stopped and the task status set to \code{TIMEOUT}.}

\item{\code{depends_on}}{Vector or list of IDs of tasks which must have
completed before this job can be run. Once all dependent tasks
have been successfully run, this task will get added to the
queue. If the dependent task fails then this task will be
removed from the queue.}

\item{\code{export}}{Optionally a list of variables to export for the
calculation. If given then no automatic analysis of the
expression is done. It should be either a named list (name
being the variable name, value being the value) or a
character vector of variables that can be found immediately
within \code{envir}. Use this where you have already done analysis
of the expression (e.g., with the future package / globals)
or where you want to avoid moving large objects through Redis
that will be available on the remote workers due to how you
have configured your worker environment.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-enqueue_"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-enqueue_}{}}}
\subsection{Method \code{enqueue_()}}{
Queue an expression
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$enqueue_(
  expr,
  envir = parent.frame(),
  queue = NULL,
  separate_process = FALSE,
  timeout_task_run = NULL,
  depends_on = NULL,
  export = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{expr}}{Any R expression, quoted; use this to use \verb{$enqueue}
in a programmatic context where you want to construct expressions
directly (e.g., \code{bquote(log(.(x)), list(x = 10))}}

\item{\code{envir}}{The environment that you would run this expression in
locally. This will be used to copy across any dependent variables.
For example, if your expression is \code{sum(1 + a)}, we will also send
the value of \code{a} to the worker along with the expression.}

\item{\code{queue}}{The queue to add the task to; if not specified the
"default" queue (which all workers listen to) will be
used. If you have configured workers to listen to more than
one queue you can specify that here. Be warned that if you
push jobs onto a queue with no worker, it will queue forever.}

\item{\code{separate_process}}{Logical, indicating if the task should be
run in a separate process on the worker (see \verb{$enqueue} for
details).}

\item{\code{timeout_task_run}}{Optionally, a maximum allowed running time, in
seconds (see \verb{$enqueue} for details).}

\item{\code{depends_on}}{Vector or list of IDs of tasks which must have
completed before this job can be run. Once all dependent tasks
have been successfully run, this task will get added to the
queue. If the dependent task fails then this task will be
removed from the queue.}

\item{\code{export}}{Optionally a list of variables to export for the
calculation. See \verb{$enqueue} for details.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-task_status"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-task_status}{}}}
\subsection{Method \code{task_status()}}{
Return a character vector of task statuses. The name
of each element corresponds to a task id, and the value will be
one of the possible statuses ("PENDING", "COMPLETE", etc).
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$task_status(task_ids = NULL, follow = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{task_ids}}{Optional character vector of task ids for which you
would like statuses. If not given (or \code{NULL}) then the status of
all task ids known to this rrq controller is returned.}

\item{\code{follow}}{Optional logical, indicating if we should follow any
redirects set up by doing \verb{$task_retry}. If not given, falls
back on the value passed into the queue, the global option
\code{rrq.follow}, and finally \code{TRUE}. Set to \code{FALSE} if you want to
return information about the original task, even if it has been
subsequently retried.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-task_result"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-task_result}{}}}
\subsection{Method \code{task_result()}}{
Get the result for a single task (see \verb{$tasks_result}
for a method for efficiently getting multiple results at once).
Returns the value of running the task if it is complete, and an
error otherwise.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$task_result(task_id, error = FALSE, follow = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{task_id}}{The single id for which the result is wanted.}

\item{\code{error}}{Logical, indicating if we should throw an error
if a task was not successful. By default (\code{error = FALSE}),
in the case of the task result returning an error we return
an object of class \code{rrq_task_error}, which contains information
about the error. Passing \code{error = TRUE} simply calls \code{stop()}
on this error if it is returned.}

\item{\code{follow}}{Optional logical, indicating if we should follow any
redirects set up by doing \verb{$task_retry}. If not given, falls
back on the value passed into the queue, the global option
\code{rrq.follow}, and finally \code{TRUE}. Set to \code{FALSE} if you want to
return information about the original task, even if it has been
subsequently retried.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-tasks_result"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-tasks_result}{}}}
\subsection{Method \code{tasks_result()}}{
Get the results of a group of tasks, returning them as a
list.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$tasks_result(task_ids, error = FALSE, follow = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{task_ids}}{A vector of task ids for which the task result
is wanted.}

\item{\code{error}}{Logical, indicating if we should throw an error if
the task was not successful. See \verb{$task_result()} for details.}

\item{\code{follow}}{Optional logical, indicating if we should follow any
redirects set up by doing \verb{$task_retry}. If not given, falls
back on the value passed into the queue, the global option
\code{rrq.follow}, and finally \code{TRUE}. Set to \code{FALSE} if you want to
return information about the original task, even if it has been
subsequently retried.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-task_wait"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-task_wait}{}}}
\subsection{Method \code{task_wait()}}{
Poll for a task to complete, returning the result
when completed. If the task has already completed this is
roughly equivalent to \code{task_result}. See \verb{$tasks_wait} for an
efficient way of doing this for a group of tasks.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$task_wait(
  task_id,
  timeout = NULL,
  time_poll = 1,
  progress = NULL,
  error = FALSE,
  follow = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{task_id}}{The single id that we will wait for}

\item{\code{timeout}}{Optional timeout, in seconds, after which an
error will be thrown if the task has not completed. If not given,
falls back on the controller's \code{timeout_task_wait} (see \verb{$new()})}

\item{\code{time_poll}}{Optional time with which to "poll" for completion.
By default this will be 1 second; this is the time that each
request for a completed task may block for (however, if the task
is finished before this, the actual time waited for will be less).
Increasing this will reduce the responsiveness of your R session
to interrupting, but will cause slightly less network load.
Values less than 1s are not currently supported as this requires
a very recent Redis server.}

\item{\code{progress}}{Optional logical indicating if a progress bar
should be displayed. If \code{NULL} we fall back on the value of the
global option \code{rrq.progress}, and if that is unset display a
progress bar if in an interactive session.}

\item{\code{error}}{Logical, indicating if we should throw an error if
the task was not successful. See \verb{$task_result()} for details.
Note that an error is always thrown if not all tasks are fetched
in time.}

\item{\code{follow}}{Optional logical, indicating if we should follow any
redirects set up by doing \verb{$task_retry}. If not given, falls
back on the value passed into the queue, the global option
\code{rrq.follow}, and finally \code{TRUE}. Set to \code{FALSE} if you want to
return information about the original task, even if it has been
subsequently retried.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-task_retry"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-task_retry}{}}}
\subsection{Method \code{task_retry()}}{
Retry a task (or set of tasks). Typically this
is after failure (e.g., \code{ERROR}, \code{DIED} or similar) but you can
retry even successfully completed tasks. Once retried, methods
that retrieve information about a task (e.g., \verb{$task_status()},
\verb{$task_result()}) will behave differently depending on the value
of their \code{follow} argument. See \code{vignette("fault-tolerance")}
for more details.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$task_retry(task_ids)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{task_ids}}{Task ids to retry.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-queue_length"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-queue_length}{}}}
\subsection{Method \code{queue_length()}}{
Returns the number of tasks in the queue (waiting for
an available worker).
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$queue_length(queue = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{queue}}{The name of the queue to query (defaults to the
"default" queue).}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-queue_list"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-queue_list}{}}}
\subsection{Method \code{queue_list()}}{
Returns the keys in the task queue.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$queue_list(queue = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{queue}}{The name of the queue to query (defaults to the
"default" queue).}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-worker_log_tail"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-worker_log_tail}{}}}
\subsection{Method \code{worker_log_tail()}}{
Returns the last (few) elements in the worker
log. The log will be returned as a \link{data.frame} of entries
\code{worker_id} (the worker id), \code{child} (the process id, an integer,
where logs come from a child process from a task queued with
\code{separate_process = TRUE}), \code{time} (the time in Redis when the
event happened; see \link[redux:redis_time]{redux::redis_time} to convert this to an R
time), \code{command} (the worker command) and \code{message} (the message
corresponding to that command).
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$worker_log_tail(worker_ids = NULL, n = 1)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{worker_ids}}{Optional vector of worker ids. If \code{NULL} then
all active workers are used.}

\item{\code{n}}{Number of elements to select, the default being the single
last entry. Use \code{Inf} or \code{0} to indicate that you want all log entries}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-worker_stop"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-worker_stop}{}}}
\subsection{Method \code{worker_stop()}}{
Stop workers.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$worker_stop(
  worker_ids = NULL,
  type = "message",
  timeout = 0,
  time_poll = 0.05,
  progress = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{worker_ids}}{Optional vector of worker ids. If \code{NULL} then
all active workers will be stopped.}

\item{\code{type}}{The strategy used to stop the workers. Can be \code{message},
\code{kill} or \code{kill_local} (see details).}

\item{\code{timeout}}{Optional timeout; if greater than zero then we poll
for a response from the worker for this many seconds until they
acknowledge the message and stop (only has an effect if \code{type}
is \code{message}). If a timeout of greater than zero is given, then
for a \code{message}-based stop we wait up to this many seconds for the
worker to exit. That means that we might wait up to \code{2 * timeout}
seconds for this function to return.}

\item{\code{time_poll}}{If \code{type} is \code{message} and \code{timeout} is greater
than zero, this is the polling interval used between redis calls.
Increasing this reduces network load but decreases the ability
to interrupt the process.}

\item{\code{progress}}{Optional logical indicating if a progress bar
should be displayed. If \code{NULL} we fall back on the value of the
global option \code{rrq.progress}, and if that is unset display a
progress bar if in an interactive session.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
The \code{type} parameter indicates the strategy used to stop
workers, and interacts with other parameters. The strategies used by
the different values are:
\itemize{
\item \code{message}, in which case a \code{STOP} message will be sent to the
worker, which they will receive after finishing any currently
running task (if \code{RUNNING}; \code{IDLE} workers will stop immediately).
\item \code{kill}, in which case a kill signal will be sent via the heartbeat
(if the worker is using one). This will kill the worker even if
is currently working on a task, eventually leaving that task with
a status of \code{DIED}.
\item \code{kill_local}, in which case a kill signal is sent using operating
system signals, which requires that the worker is on the same
machine as the controller.
}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-worker_detect_exited"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-worker_detect_exited}{}}}
\subsection{Method \code{worker_detect_exited()}}{
Detects exited workers through a lapsed heartbeat
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$worker_detect_exited()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rrq_controller-worker_config_save"></a>}}
\if{latex}{\out{\hypertarget{method-rrq_controller-worker_config_save}{}}}
\subsection{Method \code{worker_config_save()}}{
Save a worker configuration, which can be used to
start workers with a set of options with the cli. These
correspond to arguments to \link{rrq_worker}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{rrq_controller$worker_config_save(name, config, overwrite = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{name}}{Name for this configuration}

\item{\code{config}}{A worker configuration, created by
\code{\link[=rrq_worker_config]{rrq_worker_config()}}}

\item{\code{overwrite}}{Logical, indicating if an existing configuration
with this \code{name} should be overwritten if it exists. If \code{FALSE},
then the configuration is not updated, even if it differs from
the version currently saved.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Invisibly, a boolean indicating if the configuration was
updated.
}
}
}
