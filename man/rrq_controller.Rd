% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/interface.R
\name{rrq_controller}
\alias{rrq_controller}
\title{Create rrq controller}
\usage{
rrq_controller(
  queue_id,
  con = redux::hiredis(),
  timeout_task_wait = NULL,
  follow = NULL,
  check_version = TRUE,
  offload_path = NULL,
  offload_threshold_size = Inf
)
}
\arguments{
\item{queue_id}{An identifier for the queue.  This will prefix all
keys in redis, so a prefix might be useful here depending on
your use case (e.g. \verb{rrq:<user>:<id>})}

\item{con}{A redis connection. The default tries to create a redis
connection using default ports, or environment variables set as in
\code{\link[redux:hiredis]{redux::hiredis()}}}

\item{timeout_task_wait}{An optional default timeout to use when
waiting for tasks with \link{rrq_task_wait}. If not given, then we
fall back on the global option \code{rrq.timeout_task_wait}, and if
that is not set, we wait forever (i.e., \code{timeout_task_wait = Inf}).}

\item{follow}{An optional default logical to use for tasks
that may (or may not) be retried. If not given we fall back
on the global option \code{rrq.follow}, and if that is not set then
\code{TRUE} (i.e., we do follow). The value \code{follow = TRUE} is
potentially slower than \code{follow = FALSE} for some operations
because we need to dereference every task id. If you never use
\link{rrq_task_retry} then this dereference never has an effect and we
can skip it. See \code{vignette("fault-tolerance")} for more
information.}

\item{check_version}{Logical, indicating if we should check the
schema version.  You can pass \code{FALSE} here to continue even
where the schema version is incompatible, though any subsequent
actions may lead to corruption.}

\item{offload_path}{The path to create an offload store at (passed
to \code{\link{object_store_offload_disk}}). The directory will be
created if it does not exist. If not given (or \code{NULL}) but
the queue was configured with a finite \code{offload_threshold_size},
trying to save large objects will throw an error.}

\item{offload_threshold_size}{The maximum object size, in bytes,
before being moved to the offload store. If given, then larger
data will be saved in \code{offload_path} (using
\code{\link{object_store_offload_disk}})}
}
\value{
An \code{rrq_controller} object, which is opaque.
}
\description{
Create a new controller.  This is the new interface that will
replace \link{rrq_controller} soon, at which point it will rename back
to \code{rrq_controller}.
}
\section{Task lifecycle}{
\itemize{
\item A task is queued with \verb{$enqueue()}, at which point it becomes \code{PENDING}
\item Once a worker selects the task to run, it becomes \code{RUNNING}
\item If the task completes successfully without error it becomes \code{COMPLETE}
\item If the task throws an error, it becomes \code{ERROR}
\item If the task was cancelled (e.g., via \verb{$task_cancel()}) it becomes
\code{CANCELLED}
\item If the task is killed by an external process, crashes or the worker
dies (and is running a heartbeat) then the task becomes \code{DIED}.
\item The status of an unknown task is \code{MISSING}
\item Tasks in any terminal state (except \code{IMPOSSIBLE}) may be retried
with \code{task_retry} at which point they become \code{MOVED}, see
\code{vignette("fault-tolerance")} for details
}
}

\section{Worker lifecycle}{
\itemize{
\item A worker appears and is \code{IDLE}
\item When running a task it is \code{BUSY}
\item If it receives a \code{PAUSE} message it becomes \code{PAUSED} until it
receives a \code{RESUME} message
\item If it exits cleanly (e.g., via a \code{STOP} message or a timeout) it
becomes \code{EXITED}
\item If it crashes and was running a heartbeat, it becomes \code{LOST}
}
}

\section{Messages}{
Most of the time workers process tasks, but you can also send them
"messages". Messages take priority over tasks, so if a worker
becomes idle (by coming online or by finishing a task) it will
consume all available messages before starting on a new task,
even if both are available.

Each message has a "command" and may have "arguments" to that
command. The supported messages are:
\itemize{
\item \code{PING} (no args): "ping" the worker, if alive it will respond
with "PONG"
\item \code{ECHO} (accepts an argument of a string): Print a string to the
terminal and log of the worker. Will respond with \code{OK} once the
message has been printed.
\item \code{EVAL} (accepts a string or a quoted expression): Evaluate an
arbitrary R expression on the worker. Responds with the value of
this expression.
\item \code{STOP} (accepts a string to print as the worker exits, defaults
to "BYE"): Tells the worker to stop.
\item \code{INFO} (no args): Returns information about the worker (versions
of packages, hostname, pid, etc).
\item \code{PAUSE} (no args): Tells the worker to stop accepting tasks
(until it receives a \code{RESUME} message). Messages are processed
as normal.
\item \code{RESUME} (no args): Tells a paused worker to resume accepting
tasks.
\item \code{REFRESH} (no args): Tells the worker to rebuild their
environment with the \code{create} method.
\item \code{TIMEOUT_SET} (accepts a number, representing seconds): Updates
the worker timeout - the length of time after which it will exit
if it has not processed a task.
\item \code{TIMEOUT_GET} (no args): Tells the worker to respond with its
current timeout.
}
}

\section{Storage}{
Every time a task is saved, or a task is completed, results are
saved into the Redis database. Because Redis is an in-memory
database, it's not a great idea to save very large objects into
it (if you ran 100 jobs in parallel and each saved a 2GB object
you'd likely take down your redis server). In addition, \code{redux}
does not support directly saving objects larger than \code{2^31 - 1}
bytes into Redis. So, for some use cases we need to consider
where to store larger objects.

The strategy here is to "offload" the larger objects - bigger than
some user-given size - onto some other storage system. Currently
the only alternative supported is a disk store
(\code{\link{object_store_offload_disk}}) but we hope to expand this
later.  So if your task returns a 3GB object then we will spill
that to disk rather than failing to save that into
Redis.

The storage directory for offloading must be shared amoung all
users of the queue. Depending on the usecase, this could be
a directory on the local filesystems or, if using a queue across
machines, it can be a network file system mounted on all machines.

How big is an object? We serialise the object
(\code{redux::object_to_bin} just wraps \code{\link{serialize}}) which creates
a vector of bytes and that is saved into the database. To get an
idea of how large things are you can do:
\code{length(redux::object_to_bin(your_object))}.  At the time this
documentation was written, \code{mtcars} was \code{3807} bytes, and a
million random numbers was \verb{8,000,031} bytes. It's unlikely that
a \code{offload_threshold_size} of less than 1MB will be sensible.
}

\examples{
\dontshow{if (rrq:::enable_examples(require_queue = "rrq:example")) (if (getRversion() >= "3.4") withAutoprint else force)(\{ # examplesIf}

# Create a new controller; the id will be specific to your
# application.  Here, we use 'rrq:example'
obj <- rrq_controller("rrq:example")

# Create a task for this controller to work on:
t <- rrq_task_create_expr(runif(10), controller = obj)

# Wait for the task to complete
rrq_task_wait(t, controller = obj)

# Fetch the task's result
rrq_task_result(t, controller = obj)
\dontshow{\}) # examplesIf}
}
