<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en-GB">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>rrq • rrq</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="rrq">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">rrq</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.7.23</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="active nav-item"><a class="nav-link" href="../articles/rrq.html">Get started</a></li>
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/fault-tolerance.html">Fault tolerance</a></li>
    <li><a class="dropdown-item" href="../articles/messages.html">messages</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/mrc-ide/rrq/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>rrq</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/mrc-ide/rrq/blob/master/vignettes/rrq.Rmd" class="external-link"><code>vignettes/rrq.Rmd</code></a></small>
      <div class="d-none name"><code>rrq.Rmd</code></div>
    </div>

    
    
<div class="section level2">
<h2 id="getting-started">Getting started<a class="anchor" aria-label="anchor" href="#getting-started"></a>
</h2>
<p>This document assumes that that you have a Redis server running. If
not, see the bottom of the document for options you will have for
installing this on your own system. You can test if your Redis server is
behaving as expected by running</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">redux</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/redux/man/hiredis.html" class="external-link">hiredis</a></span><span class="op">(</span><span class="op">)</span><span class="op">$</span><span class="fu">PING</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="co">#&gt; [Redis: PONG]</span></span></code></pre></div>
<p>If you get an error like “Connection refused” then check your
installation.</p>
<p>The package is designed to be easy to get started with, and has
features that you might like to use later. If you run the “Hello world”
section you probably have 90% of what you need - the result of the
document will show features that will help you bend that around your
specific needs.</p>
</div>
<div class="section level2">
<h2 id="hello-world">Hello world<a class="anchor" aria-label="anchor" href="#hello-world"></a>
</h2>
<p>Without any great explanation, here is the basic approach to using
rrq to run a task on another R process, asynchronously. First, we create
a “controller” object which you can use for queuing tasks.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://mrc-ide.github.io/rrq">rrq</a></span><span class="op">)</span></span>
<span><span class="va">id</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html" class="external-link">paste0</a></span><span class="op">(</span><span class="st">"rrq:"</span>, <span class="fu">ids</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/ids/man/random_id.html" class="external-link">random_id</a></span><span class="op">(</span>bytes <span class="op">=</span> <span class="fl">4</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">obj</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/rrq_controller.html">rrq_controller</a></span><span class="op">(</span><span class="va">id</span><span class="op">)</span></span></code></pre></div>
<p>This controller uses an “identifier” (here, <code>id</code> is
<code>rrq:bab779d8</code>) which can be anything you want but acts like
a folder within the Redis server, distinguishing your queue from any
others hosted on the same server.</p>
<p>We will set this a default controller to use, which means we can
avoid passing in <code>controller = obj</code> to all the calls
below:</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/rrq_default_controller_set.html">rrq_default_controller_set</a></span><span class="op">(</span><span class="va">obj</span><span class="op">)</span></span></code></pre></div>
<p>Submit a task to the queue with <code><a href="../reference/rrq_task_create_expr.html">rrq_task_create_expr()</a></code>,
returning a key for hat task</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">t</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/rrq_task_create_expr.html">rrq_task_create_expr</a></span><span class="op">(</span><span class="fl">1</span> <span class="op">+</span> <span class="fl">1</span><span class="op">)</span></span>
<span><span class="va">t</span></span>
<span><span class="co">#&gt; [1] "498a14828ff4233d26242641639dc5c6"</span></span></code></pre></div>
<p>We’ll also need some worker processes to carry out our tasks. Here,
we’ll spawn two for now (see the section below on alternatives to
this)</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">w</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/rrq_worker_spawn.html">rrq_worker_spawn</a></span><span class="op">(</span><span class="fl">2</span><span class="op">)</span></span>
<span><span class="co">#&gt; <span style="color: #00BBBB;">ℹ</span> Spawning 2 workers with prefix 'nonspheric_siberiantiger'</span></span></code></pre></div>
<p>+Wait for the task to complete:</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/rrq_task_wait.html">rrq_task_wait</a></span><span class="op">(</span><span class="va">t</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span></code></pre></div>
<p>then retrieve the result</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/rrq_task_result.html">rrq_task_result</a></span><span class="op">(</span><span class="va">t</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 2</span></span></code></pre></div>
<p>Things to note here:</p>
<ul>
<li>Every task is given a unique identifier, which can be used to query
the task later (much more on this below)</li>
<li>The process with the controller is not blocked during this operation
and could carry out any other calculation it wanted (it could even be
closed and the controller recreated later)</li>
<li>We submitted the tasks before we had workers ready; we could have
done this in the other order, and workers can be added and removed at
will regardless of the state of the queue (see below)</li>
</ul>
</div>
<div class="section level2">
<h2 id="design">Design<a class="anchor" aria-label="anchor" href="#design"></a>
</h2>
<p>For years, the <code>parallel</code> package has provided users with
the ability to run tasks in parallel with very little setup. Given a
list of data <code>x</code> and some function <code>f</code>, one can
change from the serial code</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/lapply.html" class="external-link">lapply</a></span><span class="op">(</span><span class="va">x</span>, <span class="va">fun</span><span class="op">)</span></span></code></pre></div>
<p>to run in parallel given a cluster object <code>cl</code></p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">parallel</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/parallel/clusterApply.html" class="external-link">parLapply</a></span><span class="op">(</span><span class="va">cl</span>, <span class="va">x</span>, <span class="va">fun</span><span class="op">)</span></span></code></pre></div>
<p>(the even simpler <code>parallel::mclapply(x, fun)</code> can be used
on platforms other than Windows with reasonable success). Nice as this
is it suffers some drawbacks, most of which follow from the simple
blocking interface:</p>
<ul>
<li>The R session is blocked while the calculations run, even though the
host session is doing (essentially) nothing</li>
<li>The number of workers (size of the cluster) is fixed at the point
where <code>parLapply</code> has been called, and is restricted to a
single node without considerable effort. One cannot add workers to the
cluster while it runs, or remove unneeded ones as tasks finish.</li>
<li>It is not possible to retrieve partially completed results - we have
to wait for all the tasks to complete before working with any</li>
<li>If tasks are of uneven size, the load balancing form
(<code><a href="https://rdrr.io/r/parallel/clusterApply.html" class="external-link">parallel::parLapplyLB</a></code>) is quite slow</li>
</ul>
<p>As such it is hard to build interfaces like queues or work through
dependency graphs (though see heroic work in <a href="https://future.futureverse.org/" class="external-link">future</a> and <a href="https://docs.ropensci.org/targets/" class="external-link">targets</a>). Attempts at
doing this run into issues of where do you store the data and the queue
in such a way that you can safely have multiple worker processes
interacting with the queue without corrupting the database or hitting
race conditions. Approaches like <a href="https://cran.r-project.org/package=liteq" class="external-link">liteq</a> may not work
on network file systems, and therefore become limited to a single
node.</p>
<p>At the other end of the scale, HPC systems with their schedulers can
avoid all these issues, but with byzantine interfaces and slow per-task
submission.</p>
<p>Notable features of <code>rrq</code> which motivate its development
within this landscape:</p>
<ul>
<li>Uses <a href="https://redis.io" class="external-link">Redis</a> as a task broker; this
provides a database to hold tasks that allows very fast network based
access to many processes</li>
<li>Uses a non-blocking design where control is returned to the
controller process as immediately while tasks run in the background</li>
<li>Supports a scalable worker pool; no workers are needed for tasks to
be queued, and workers can be added or removed at will while tasks are
running</li>
<li>Allows for multiple non-interacting queues, multiple priority levels
within a queue, and automatically resolved dependencies among completing
tasks</li>
<li>Supports a fully load-balanced design with overheads of around 1ms
per task</li>
<li>Supports optionally running each task in a separate process,
allowing for strong isolation between tasks as well as per-task
timeouts, logging, and allowing cancellation</li>
<li>Allows rich querying of task status and progress and worker
history</li>
<li>Exposes both low-level primitives for working with individual tasks
as well as higher level interfaces that mimic functions like
<code>lapply</code>
</li>
</ul>
</div>
<div class="section level2">
<h2 id="running-tasks">Running tasks<a class="anchor" aria-label="anchor" href="#running-tasks"></a>
</h2>
<p>Running tasks is a little different to many R-parallel backends,
because we do not directly allocate tasks to our workers, but simply
place it on first-in-first-out task queue. A pool of workers will then
poll for work from this queue. See <code>vignette("design")</code> for
more on this.</p>
<p>Consider enqueing this expression</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">t</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/rrq_task_create_expr.html">rrq_task_create_expr</a></span><span class="op">(</span><span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/Sys.sleep.html" class="external-link">Sys.sleep</a></span><span class="op">(</span><span class="fl">2</span><span class="op">)</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span></span>
<span><span class="op">}</span><span class="op">)</span></span></code></pre></div>
<p>This has created a task that will sleep for 2 seconds then return a
random number</p>
<p>Initially the task has status <code>RUNNING</code> (it will be
<code>PENDING</code> <em>very</em> briefly):</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/rrq_task_status.html">rrq_task_status</a></span><span class="op">(</span><span class="va">t</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "RUNNING"</span></span></code></pre></div>
<p>Then after a couple of seconds it will complete (we pad this out here
so that it will complete even on slow systems)</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Sys.sleep.html" class="external-link">Sys.sleep</a></span><span class="op">(</span><span class="fl">3</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/rrq_task_result.html">rrq_task_result</a></span><span class="op">(</span><span class="va">t</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 0.8880451</span></span></code></pre></div>
<p>The basic task lifecycle is this:</p>
<ul>
<li>when created/submitted a task becomes <code>PENDING</code>
</li>
<li>when it is picked up by a worker it becomes
<code>RUNNING</code>
</li>
<li>when it completes it will become <code>COMPLETE</code> or
<code>ERROR</code>
</li>
</ul>
<p>In addition there are rarer ways a task can end
(<code>CANCELLED</code>, <code>DIED</code>, <code>TIMEOUT</code>) or
fail to start due to dependencies between tasks (<code>DEFERRED</code>
or <code>IMPOSSIBLE</code>; see below).</p>
<p>A task in any terminal state (except <code>IMPOSSIBLE</code>, so
<code>COMPLETE</code>, <code>ERROR</code>, <code>CANCELLED</code>,
<code>DIED</code> or <code>TIMEOUT</code>) can be retried, at which
point the status is <code>MOVED</code> and the task will “point”
somewhere else (that task will move through the usual
<code>PENDING -&gt; RUNNING -&gt; (terminal state)</code> flow). See
<code><a href="../articles/fault-tolerance.html">vignette("fault-tolerance")</a></code> for details.</p>
<p>Above, we slept for a few seconds in order for the task to become
finished. However, this is an extremely common operation, so
<code>rrq</code> provides a function <code><a href="../reference/rrq_task_wait.html">rrq_task_wait()</a></code> which
will wait until a task finishes, then returns a logical indicating if
the task succeeded or not, after which you can fetch the result with
<code><a href="../reference/rrq_task_result.html">rrq_task_result()</a></code>.</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">t</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/rrq_task_create_expr.html">rrq_task_create_expr</a></span><span class="op">(</span><span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/Sys.sleep.html" class="external-link">Sys.sleep</a></span><span class="op">(</span><span class="fl">2</span><span class="op">)</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span></span>
<span><span class="op">}</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/rrq_task_wait.html">rrq_task_wait</a></span><span class="op">(</span><span class="va">t</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span>
<span><span class="fu"><a href="../reference/rrq_task_result.html">rrq_task_result</a></span><span class="op">(</span><span class="va">t</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 0.0711711</span></span></code></pre></div>
<p>The polling interval here is 1 second by default, but if the task
completes within that period it will still be returned as soon as it is
complete (the interval is just the time between progress bar updates and
the period where an interrupt would be caught to cancel the wait).</p>
</div>
<div class="section level2">
<h2 id="configuring-the-worker-environment">Configuring the worker environment<a class="anchor" aria-label="anchor" href="#configuring-the-worker-environment"></a>
</h2>
<p>It is rare that we want our workers to run in completely empty R
environments (no extra loaded packages, no custom functions available).
Quite often you will want to run something to configure the workers
before they accept tasks.</p>
<p>In order to do this, first define a function that will accept one
argument which will be the environment that the worker will use, and
then set that environment up.</p>
<p>For the most common case, where you have script files that contain
function definitions and you have a set of packages to load, rrq has a
helper function <code><a href="../reference/rrq_envir.html">rrq_envir()</a></code>.</p>
<p>So, for example, suppose we want to source a file “myfuns.R” which
contains some code</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">slowdouble</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/Sys.sleep.html" class="external-link">Sys.sleep</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span></span>
<span>  <span class="va">x</span> <span class="op">*</span> <span class="fl">2</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>We might write:</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">create</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/rrq_envir.html">rrq_envir</a></span><span class="op">(</span>sources <span class="op">=</span> <span class="st">"myfuns.R"</span><span class="op">)</span></span></code></pre></div>
<p>The next step is to register this function for your queue:</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/rrq_worker_envir_set.html">rrq_worker_envir_set</a></span><span class="op">(</span><span class="va">create</span><span class="op">)</span></span></code></pre></div>
<p>By default, this will notify all running workers to update their
environment. Note that if your function errors in any way, your workers
will exit!</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/rrq_worker_log_tail.html">rrq_worker_log_tail</a></span><span class="op">(</span>n <span class="op">=</span> <span class="fl">4</span><span class="op">)</span></span>
<span><span class="co">#&gt;                    worker_id child       time  command message</span></span>
<span><span class="co">#&gt; 1 nonspheric_siberiantiger_1    NA 1746804815  MESSAGE REFRESH</span></span>
<span><span class="co">#&gt; 2 nonspheric_siberiantiger_2    NA 1746804815  MESSAGE REFRESH</span></span>
<span><span class="co">#&gt; 3 nonspheric_siberiantiger_1    NA 1746804815    ENVIR     new</span></span>
<span><span class="co">#&gt; 4 nonspheric_siberiantiger_2    NA 1746804815    ENVIR     new</span></span>
<span><span class="co">#&gt; 5 nonspheric_siberiantiger_1    NA 1746804815    ENVIR  create</span></span>
<span><span class="co">#&gt; 6 nonspheric_siberiantiger_2    NA 1746804815    ENVIR  create</span></span>
<span><span class="co">#&gt; 7 nonspheric_siberiantiger_1    NA 1746804815 RESPONSE REFRESH</span></span>
<span><span class="co">#&gt; 8 nonspheric_siberiantiger_2    NA 1746804815 RESPONSE REFRESH</span></span></code></pre></div>
<p>Now our workers have picked up our functions we can start using
them:</p>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">t</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/rrq_task_create_expr.html">rrq_task_create_expr</a></span><span class="op">(</span><span class="fu">slowdouble</span><span class="op">(</span><span class="fl">1</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/rrq_task_wait.html">rrq_task_wait</a></span><span class="op">(</span><span class="va">t</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span></code></pre></div>
<p>If you need more control you can write your own function. We could
have written <code>create</code> as</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">create</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">env</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/sys.source.html" class="external-link">sys.source</a></span><span class="op">(</span><span class="st">"myfuns.R"</span>, <span class="va">env</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>This approach would also allow you do do something like read an rds
or Rdata file containing a large object that you want every worker to
have a copy of.</p>
</div>
<div class="section level2">
<h2 id="scheduling-options">Scheduling options<a class="anchor" aria-label="anchor" href="#scheduling-options"></a>
</h2>
<p>The <code>rrq</code> package does not aspire to be a fully fledged
scheduler, but sometimes a little more control than first-in-first-out
is required. There are a few options available that allow the user to
control how tasks are run when needed. These involve:</p>
<ul>
<li>blocking tasks so that they run only after other tasks are completed
(e.g., a set up task followed by a series of computational tasks,
followed by an aggregation task)</li>
<li>multiple queues with different priorities, or that different workers
subscribe to (e.g., fast/slow high-priority/low-priority tasks, or tasks
that require a limited resource)</li>
<li>put tasks in the front of the queue, allowing a last-in-first-out
queue</li>
</ul>
<div class="section level3">
<h3 id="tasks-that-depend-on-other-tasks">Tasks that depend on other tasks<a class="anchor" aria-label="anchor" href="#tasks-that-depend-on-other-tasks"></a>
</h3>
<p>We support a simple system for allowing tasks to depend on other
tasks. An example of this might be where you need to download a file,
then run a series of analyses on it. Or where you want to run an
analysis over a set of parameters, and then aggregate once they’re all
done. How the output of one task feeds into the others is up to you, but
practically this will require one of the following options:</p>
<ul>
<li>write your results to disk and read them back</li>
<li>store results in a database (e.g., Redis!) at the end of one task,
read them in the next</li>
<li>connect to the queue from your task itself</li>
</ul>
<p>When queueing a task, you can provide a vector of task identifiers as
the <code>depends_on</code> argument. These identifiers must all be
known to <code>rrq</code> and the task will not be started until all
these prerequisites are completed. The task lifecycle will look
different to the above; rather than starting as <code>PENDING</code> the
task begins as <code>DEFERRED</code>.</p>
<p>Once all prerequisites are complete, a task becomes possible and it
moves from <code>DEFERRED</code> to <code>PENDING</code>. It will be
placed at the <em>front</em> of the queue.</p>
<p>If a prerequisite task fails for any reason (an error, is cancelled,
or its worker dies) then the task will become
<code>IMPOSSIBLE</code>.</p>
<p>For example, suppose that we have code:</p>
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">create</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">n</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/readRDS.html" class="external-link">saveRDS</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="va">n</span><span class="op">)</span>, <span class="st">"numbers.rds"</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="va">use</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">i</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">d</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/readRDS.html" class="external-link">readRDS</a></span><span class="op">(</span><span class="st">"numbers.rds"</span><span class="op">)</span></span>
<span>  <span class="va">d</span><span class="op">[[</span><span class="va">i</span><span class="op">]</span><span class="op">]</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>Here we have some function <code>create</code> that we want to run
first, doing some setup, then another function <code>use</code> that we
want to run after which will read the result of running
<code>create</code> and do some analysis on it.</p>
<p>Create an <code>rrq_controller</code> object and tell workers to read
the <code>deps.R</code> file which contains these function
definitions</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">obj</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/rrq_controller.html">rrq_controller</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/paste.html" class="external-link">paste0</a></span><span class="op">(</span><span class="st">"rrq:"</span>, <span class="fu">ids</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/ids/man/random_id.html" class="external-link">random_id</a></span><span class="op">(</span>bytes <span class="op">=</span> <span class="fl">4</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/rrq_default_controller_set.html">rrq_default_controller_set</a></span><span class="op">(</span><span class="va">obj</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/rrq_worker_envir_set.html">rrq_worker_envir_set</a></span><span class="op">(</span><span class="fu"><a href="../reference/rrq_envir.html">rrq_envir</a></span><span class="op">(</span>sources <span class="op">=</span> <span class="st">"deps.R"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/source.html" class="external-link">source</a></span><span class="op">(</span><span class="st">"deps.R"</span><span class="op">)</span></span></code></pre></div>
<p>We can then enqueue our first task:</p>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">id</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/rrq_task_create_expr.html">rrq_task_create_expr</a></span><span class="op">(</span><span class="fu">create</span><span class="op">(</span><span class="fl">5</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>Then use this <code>id</code></p>
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">id_use</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/rrq_task_create_expr.html">rrq_task_create_expr</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/use.html" class="external-link">use</a></span><span class="op">(</span><span class="fl">2</span><span class="op">)</span>, depends_on <span class="op">=</span> <span class="va">id</span><span class="op">)</span></span></code></pre></div>
<p>The status of the first task will be <code>PENDING</code>, per
usual:</p>
<div class="sourceCode" id="cb24"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/rrq_task_status.html">rrq_task_status</a></span><span class="op">(</span><span class="va">id</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "PENDING"</span></span></code></pre></div>
<p>however, the second task will be <code>DEFERRED</code> because it is
not yet in the queue:</p>
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/rrq_task_status.html">rrq_task_status</a></span><span class="op">(</span><span class="va">id_use</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "DEFERRED"</span></span>
<span><span class="fu"><a href="../reference/rrq_queue_list.html">rrq_queue_list</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "2df93fcd10bcd6bbf7fc0f01ff40022e"</span></span></code></pre></div>
<p>Once the first task is processed by a worker, the status changes:</p>
<div class="sourceCode" id="cb26"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/rrq_task_status.html">rrq_task_status</a></span><span class="op">(</span><span class="va">id</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "COMPLETE"</span></span>
<span><span class="fu"><a href="../reference/rrq_task_status.html">rrq_task_status</a></span><span class="op">(</span><span class="va">id_use</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "PENDING"</span></span>
<span><span class="fu"><a href="../reference/rrq_queue_list.html">rrq_queue_list</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "9272663bc056619f89efebafaab6a97e"</span></span></code></pre></div>
<p>At this point the second task will proceed through the queue as
usual.</p>
<p>Points to note here:</p>
<ul>
<li>The deferred tasks cannot access the queued result of the blocking
task (see above)</li>
<li>The deferred tasks will be added to the <em>front</em> of the queue
after they become undeferred</li>
<li>The deferred tasks can’t be queued until the blocking tasks have
returned an id</li>
</ul>
</div>
<div class="section level3">
<h3 id="multiple-queues">Multiple queues<a class="anchor" aria-label="anchor" href="#multiple-queues"></a>
</h3>
<p>Sometimes it is useful to have different workers listen on different
queues. For example, you may have workers on different machines with
different capabilities (e.g., a machine with a GPU or high memory). You
may have tasks that are expected to take quite a long time but want some
workers to monitor a fast queue with short lived tasks.</p>
<p>Every worker listens to the <code>default</code> queue, but when
starting a worker, you can add additional queues and control the
priority order of these queues for that worker. When submitting tasks
you then specify the queue that the task sits in.</p>
<p>The easiest way to configure this is to save a worker
configuration:</p>
<div class="sourceCode" id="cb27"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">id</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html" class="external-link">paste0</a></span><span class="op">(</span><span class="st">"rrq:"</span>, <span class="fu">ids</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/ids/man/random_id.html" class="external-link">random_id</a></span><span class="op">(</span>bytes <span class="op">=</span> <span class="fl">4</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">obj</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/rrq_controller.html">rrq_controller</a></span><span class="op">(</span><span class="va">id</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/rrq_default_controller_set.html">rrq_default_controller_set</a></span><span class="op">(</span><span class="va">obj</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/rrq_worker_config_save.html">rrq_worker_config_save</a></span><span class="op">(</span></span>
<span>  <span class="st">"short"</span>,</span>
<span>  <span class="fu"><a href="../reference/rrq_worker_config.html">rrq_worker_config</a></span><span class="op">(</span>queue <span class="op">=</span> <span class="st">"short"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/rrq_worker_config_save.html">rrq_worker_config_save</a></span><span class="op">(</span></span>
<span>  <span class="st">"all"</span>,</span>
<span>  <span class="fu"><a href="../reference/rrq_worker_config.html">rrq_worker_config</a></span><span class="op">(</span>queue <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"short"</span>, <span class="st">"long"</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/rrq_worker_config_list.html">rrq_worker_config_list</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "short"     "localhost" "all"</span></span></code></pre></div>
<p>Above, we create two configurations: “short” which just listens on
the queue <code>short</code>, and <code>all</code> which listens both on
the short and long task queues (note that both these workers will also
listen on the default queue).</p>
<div class="sourceCode" id="cb28"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">w_short</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/rrq_worker_spawn.html">rrq_worker_spawn</a></span><span class="op">(</span>name_config <span class="op">=</span> <span class="st">"short"</span><span class="op">)</span></span>
<span><span class="co">#&gt; <span style="color: #00BBBB;">ℹ</span> Spawning 1 worker with prefix 'compassionless_pachyderm'</span></span>
<span><span class="va">w_all</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/rrq_worker_spawn.html">rrq_worker_spawn</a></span><span class="op">(</span>name_config <span class="op">=</span> <span class="st">"all"</span><span class="op">)</span></span>
<span><span class="co">#&gt; <span style="color: #00BBBB;">ℹ</span> Spawning 1 worker with prefix 'diamond_doe'</span></span></code></pre></div>
<p>We can then submit a long task to the worker:</p>
<div class="sourceCode" id="cb29"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">id_long1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/rrq_task_create_expr.html">rrq_task_create_expr</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Sys.sleep.html" class="external-link">Sys.sleep</a></span><span class="op">(</span><span class="fl">3600</span><span class="op">)</span>, queue <span class="op">=</span> <span class="st">"long"</span><span class="op">)</span></span>
<span><span class="va">id_long2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/rrq_task_create_expr.html">rrq_task_create_expr</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Sys.sleep.html" class="external-link">Sys.sleep</a></span><span class="op">(</span><span class="fl">3600</span><span class="op">)</span>, queue <span class="op">=</span> <span class="st">"long"</span><span class="op">)</span></span></code></pre></div>
<p>After the workers have had the ability to pick up work, our “short”
worker is still available:</p>
<div class="sourceCode" id="cb30"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/rrq_worker_status.html">rrq_worker_status</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="co">#&gt; compassionless_pachyderm_1              diamond_doe_1 </span></span>
<span><span class="co">#&gt;                     "IDLE"                     "BUSY"</span></span></code></pre></div>
<p>So we can submit tasks to this short queue and have them
processed</p>
<div class="sourceCode" id="cb31"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">id</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/rrq_task_create_expr.html">rrq_task_create_expr</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span>, queue <span class="op">=</span> <span class="st">"short"</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/rrq_task_wait.html">rrq_task_wait</a></span><span class="op">(</span><span class="va">id</span>, timeout <span class="op">=</span> <span class="fl">10</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span></code></pre></div>
<p>Note that there is no validation to check that any worker is
listening on any queue when you submit a task. Indeed there can’t be as
new workers can be added at any time (so at the point of submission
perhaps there were no workers).</p>
</div>
</div>
<div class="section level2">
<h2 id="running-tasks-in-separate-processes">Running tasks in separate processes<a class="anchor" aria-label="anchor" href="#running-tasks-in-separate-processes"></a>
</h2>
<p>Running a task in a separate process offers some additional features
at a cost of a little more overhead per task.</p>
<p>The cost is that we have to launch an additional process for every
task run. We use <a href="https://callr.r-lib.org/" class="external-link"><code>callr</code></a> for this to
smooth over a number of rough edges, but this does impose a minimum
overhead of about 0.1s per task, plus the cost of loading any packages
that your task might need (if you use packages that make heavy use of
things like S4 classes this can easily extend to a few seconds).</p>
<p>The additional features that it provides are:</p>
<ul>
<li>Per-task isolation: because every task runs in a separate process it
works in a fresh environment and is isolated from all other tasks</li>
<li>Cancellable tasks: you can stop a running task and the worker will
gracefully pick up additional work</li>
<li>Per-task timeout: you can specify the maximum running time of any
task and if the task exceeds it, it will be killed</li>
<li>Per-task logs, via <code><a href="../reference/rrq_task_log.html">rrq_task_log()</a></code>
</li>
</ul>
<p>The sorts of tasks that benefit from this sort of approach are
typically long-running (expected running times in the 10s of seconds or
more) so that the overhead is low, but also the features of cancellation
and timeouts become more useful. We have also seen this used usefully
where the task may leak memory, or cache results aggressively - over
time this would cause the worker process to consume more memory until
the worker process was killed by the operating system.</p>
<p>To use a separate process, add <code>separate_process = TRUE</code>
to calls to <code><a href="../reference/rrq_task_create_expr.html">rrq_task_create_expr()</a></code>. This will then enable
the argument <code>timeout</code> to have an effect, as well as
<code><a href="../reference/rrq_task_cancel.html">rrq_task_cancel()</a></code>.</p>
</div>
<div class="section level2">
<h2 id="coping-with-memory-use">Coping with memory use<a class="anchor" aria-label="anchor" href="#coping-with-memory-use"></a>
</h2>
<p>The data for each task, and the task result itself, is saved in
Redis. This is alongside the typically much smaller metadata required to
run rrq. Because Redis is an <a href="https://redis.io/topics/faq" class="external-link">in
memory</a> database, this means that some things will not be a great
idea; for example sending off 1000 tasks that will each write back 100
MB of simulation output would try and write 100 GB of data into the
Redis database which may cause issues for your server!</p>
<p>To allow for this workflow, <code>rrq</code> supports configuring its
object store (<code><a href="../reference/object_store.html">rrq::object_store</a></code>) so that objects above a
certain size are written out elsewhere. Currently, the only “elsewhere”
supported is to disk with the assumption that the controller and all
workers share a filesystem. The approach used is safe for multiple
concurrent processes, including over network mounted filesystems.</p>
<p>This feature can be enabled by passing an <code>offload_path</code>
to both the controller and the worker. Additionally, the
<code>offload_threshold_size</code> should be set in the worker
configuration. In the setup below, both the controller and the worker
use the same offload path, but if they were running on different
machines we may need to use different paths pointing at the same
underlying network filesystem.</p>
<div class="sourceCode" id="cb32"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">id</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html" class="external-link">paste0</a></span><span class="op">(</span><span class="st">"rrq:"</span>, <span class="fu">ids</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/ids/man/random_id.html" class="external-link">random_id</a></span><span class="op">(</span>bytes <span class="op">=</span> <span class="fl">4</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">path</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/tempfile.html" class="external-link">tempfile</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">obj</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/rrq_controller.html">rrq_controller</a></span><span class="op">(</span><span class="va">id</span>, offload_path <span class="op">=</span> <span class="va">path</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="../reference/rrq_default_controller_set.html">rrq_default_controller_set</a></span><span class="op">(</span><span class="va">obj</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/rrq_worker_config_save.html">rrq_worker_config_save</a></span><span class="op">(</span></span>
<span>    <span class="st">"localhost"</span>,</span>
<span>    <span class="fu"><a href="../reference/rrq_worker_config.html">rrq_worker_config</a></span><span class="op">(</span>offload_threshold_size <span class="op">=</span> <span class="fl">1000</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="va">w</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/rrq_worker_spawn.html">rrq_worker_spawn</a></span><span class="op">(</span><span class="fl">1</span>, offload_path <span class="op">=</span> <span class="va">path</span><span class="op">)</span></span>
<span><span class="co">#&gt; <span style="color: #00BBBB;">ℹ</span> Spawning 1 worker with prefix 'indistinct_indianspinyloach'</span></span></code></pre></div>
<p>It’s not hard at all to get to 1KB of data, we can do that by
simulating a big pile of random numbers:</p>
<div class="sourceCode" id="cb33"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">t</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/rrq_task_create_expr.html">rrq_task_create_expr</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">200000</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>Once the task has finished, data will be stored on disk below the
path given above:</p>
<div class="sourceCode" id="cb34"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/list.files.html" class="external-link">dir</a></span><span class="op">(</span><span class="va">path</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "15bb4aaa4137c934e1c0b03b4ab3ad4b"</span></span></code></pre></div>
<p>This keeps the larger objects out of the database.</p>
</div>
<div class="section level2">
<h2 id="orchestrating-workers">Orchestrating workers<a class="anchor" aria-label="anchor" href="#orchestrating-workers"></a>
</h2>
<p>This vignette uses the very basic <code><a href="../reference/rrq_worker_spawn.html">rrq_worker_spawn()</a></code>
method to create workers on your local machine. This is intended
primarily for development only, though it may be useful in some
situations. There are other options available, depending on how you want
to use <code>rrq</code>.</p>
<div class="section level3">
<h3 id="use-and-limitations-of-spawn">Use (and limitations) of spawn<a class="anchor" aria-label="anchor" href="#use-and-limitations-of-spawn"></a>
</h3>
<p>The simplest way of getting started with <code>rrq</code> is to use
<code><a href="../reference/rrq_worker_spawn.html">rrq_worker_spawn()</a></code>, as above. This approach has several
nice features; it uses <code>callr</code>, so no extra work is required
to make the worker R session behave like the controller session (it will
find your environment variables, library, and working directory), and it
behaves the same way on all platforms (compare below). However, the
workers will disappear when the controlling session completes (this is
either a good or a bad thing) and you will be limited to a single
node.</p>
</div>
<div class="section level3">
<h3 id="start-workers-on-another-node-perhaps-using-a-scheduler">Start workers on another node, perhaps using a scheduler<a class="anchor" aria-label="anchor" href="#start-workers-on-another-node-perhaps-using-a-scheduler"></a>
</h3>
<p>There are two issues here; one is the technical details of launching
your rrq workers on the cluster, and the other is the details around
whether your HPC admins would like you to (and the security implications
of doing so).</p>
<p>If you are using rrq with an HPC system, then you will want to
schedule workers onto the system. <em>The details here will
change</em></p>
<p>The basic approach is to write out a launcher script somewhere:</p>
<div class="sourceCode" id="cb35"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/rrq_worker_script.html">rrq_worker_script</a></span><span class="op">(</span><span class="va">dest</span><span class="op">)</span></span></code></pre></div>
<p>This can be called from the command line:</p>
<pre><code>$ ./rrq_worker --help
Usage:
  rrq_worker [options] &lt;id&gt;

Options:
--config=NAME    Name of a worker configuration [default: localhost]
--name=NAME      Name of the worker (optional)</code></pre>
<p>This is a bash script that can then be called from whatever cluster
job scheduler you use. The important things to pass through are:</p>
<ul>
<li>
<code>id</code> the only positional argument, which is the queue
id</li>
<li>
<code>--config=NAME</code> allows controlling of the named worker
config (set via <code><a href="../reference/rrq_worker_config_save.html">rrq_worker_config_save()</a></code>, and allowing
changing of timeout, verbosity and queues)</li>
</ul>
<p>In addition, you may need to change the configuration type. If you
need to control redis access you should set the <code>REDIS_URL</code>
environment variable to point at your Redis server.</p>
</div>
<div class="section level3">
<h3 id="use-docker">Use docker<a class="anchor" aria-label="anchor" href="#use-docker"></a>
</h3>
<p>We provide a docker image that you can use (<code>mrcide/rrq</code>),
though typically you would want to extend this image to include your own
packages. Alternatively create your own docker image (see <a href="https://github.com/mrc-ide/rrq/blob/master/docker/Dockerfile" class="external-link">the
main dockerfile</a> but replace <code>COPY . /src</code> with an
installation of rrq) and the <a href="https://github.com/mrc-ide/rrq/blob/master/docker/Dockerfile.worker" class="external-link">image
that sets the entrypoint to call <code>rrq_worker</code></a>.</p>
<p>We use rrq to orchestrate workers in web applications where a number
of workers carry out long running calculations for a HTTP API written
using <a href="https://www.rplumber.io/" class="external-link">plumber</a> and <a href="https://reside-ic.github.io/porcelain/" class="external-link">porcelain</a>.</p>
</div>
</div>
<div class="section level2">
<h2 id="waiting-for-workers-to-appear">Waiting for workers to appear<a class="anchor" aria-label="anchor" href="#waiting-for-workers-to-appear"></a>
</h2>
<p>If you have submitted workers via a task scheduler, you might want to
block and wait for them to become available. You can do this using the
<code><a href="../reference/rrq_worker_wait.html">rrq_worker_wait()</a></code> function.</p>
<p>We first create a vector of names for the new workers, and then tell
<code>rrq</code> that we’re going to produce these workers.</p>
<div class="sourceCode" id="cb37"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">obj</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/rrq_controller.html">rrq_controller</a></span><span class="op">(</span><span class="va">id</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/rrq_default_controller_set.html">rrq_default_controller_set</a></span><span class="op">(</span><span class="va">obj</span><span class="op">)</span></span>
<span><span class="va">worker_ids</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"cluster_1"</span>, <span class="st">"cluster_2"</span><span class="op">)</span></span></code></pre></div>
<p>How you then start the workers is up to you; you might start them at
the command line with</p>
<pre><code>rrq_worker --worker-id cluster_1 rrq:6f7c87c0
rrq_worker --worker-id cluster_2 rrq:6f7c87c0</code></pre>
<p>(into separate terminals). Or you might queue these jobs with a
cluster scheduler such as Slurm or PBS (with appropriate care over the
working directory). But you can then immediately, in your R console
write:</p>
<div class="sourceCode" id="cb39"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/rrq_worker_wait.html">rrq_worker_wait</a></span><span class="op">(</span><span class="va">worker_ids</span>, controller <span class="op">=</span> <span class="va">obj</span><span class="op">)</span></span></code></pre></div>
<p>and your session will block and wait for the workers to appear,
erroring if they do not appear in time.</p>
</div>
<div class="section level2">
<h2 id="worker-heartbeat">Worker heartbeat<a class="anchor" aria-label="anchor" href="#worker-heartbeat"></a>
</h2>
<p>If you use many workers, particularly on different machines, you may
not notice if some disappear. Possible causes of this include:</p>
<ul>
<li>Your task crashes a worker (e.g., you run some C++ code that
segfaults)</li>
<li>Your worker is killed by the operating system (e.g., the system is
running low on RAM and your process is targeted by the out-of-memory
killer)</li>
<li>The machine reboots or shuts down</li>
<li>The redis server goes down temporarily, causing the worker to exit
when writing back results</li>
</ul>
<p>By default, if this happens when your worker is running a task, that
task status will forever be stuck in <code>RUNNING</code>.</p>
<p><code>rrq</code> provides a simple heartbeat process, if requested,
to detect when a worker has disappeared. To do this, we run a second
process on each worker that periodically writes to the Redis database on
a key that will expire in a time slightly longer than that period, in
effect making a <a href="https://en.wikipedia.org/wiki/Dead_man%27s_switch" class="external-link">dead man’s
switch</a> - see <code><a href="../reference/heartbeat.html">rrq::rrq_heartbeat</a></code> for details.</p>
<p>To enable the heartbeat, save a worker configuration with the
<code>heartbeat_period</code> set to some number of seconds. Below we
use 2 seconds so that this example runs reasonably quickly, but in
practice something like 60 might be slightly less load on your Redis
server.</p>
<div class="sourceCode" id="cb40"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">id</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html" class="external-link">paste0</a></span><span class="op">(</span><span class="st">"rrq:"</span>, <span class="fu">ids</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/ids/man/random_id.html" class="external-link">random_id</a></span><span class="op">(</span>bytes <span class="op">=</span> <span class="fl">4</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">obj</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/rrq_controller.html">rrq_controller</a></span><span class="op">(</span><span class="va">id</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/rrq_default_controller_set.html">rrq_default_controller_set</a></span><span class="op">(</span><span class="va">obj</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/rrq_worker_config_save.html">rrq_worker_config_save</a></span><span class="op">(</span></span>
<span>  <span class="st">"localhost"</span>,</span>
<span>  <span class="fu"><a href="../reference/rrq_worker_config.html">rrq_worker_config</a></span><span class="op">(</span>heartbeat_period <span class="op">=</span> <span class="fl">2</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>Then, launch a worker</p>
<div class="sourceCode" id="cb41"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">w</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/rrq_worker_spawn.html">rrq_worker_spawn</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span></span>
<span><span class="co">#&gt; <span style="color: #00BBBB;">ℹ</span> Spawning 1 worker with prefix 'ecological_snake'</span></span></code></pre></div>
<p>Our worker will print information indicating that the heartbeat is
enabled (use <code><a href="../reference/rrq_worker_process_log.html">rrq_worker_process_log()</a></code>)</p>
<pre><code><span><span class="co">#&gt; [2025-05-09 15:33:41.384314] HEARTBEAT rrq:01e14764:worker:ecological_snake_1:heartbeat</span></span>
<span><span class="co">#&gt; [2025-05-09 15:33:41.630389] HEARTBEAT OK</span></span>
<span><span class="co">#&gt; [2025-05-09 15:33:41.639345] ALIVE</span></span>
<span><span class="co">#&gt; [2025-05-09 15:33:41.639699] ENVIR new</span></span>
<span><span class="co">#&gt; [2025-05-09 15:33:41.640097] QUEUE default</span></span>
<span><span class="co">#&gt;                                  __</span></span>
<span><span class="co">#&gt;                 ______________ _/ /</span></span>
<span><span class="co">#&gt;       ______   / ___/ ___/ __ `/ /_____</span></span>
<span><span class="co">#&gt;      /_____/  / /  / /  / /_/ /_/_____/</span></span>
<span><span class="co">#&gt;  ______      /_/  /_/   \__, (_)   ______</span></span>
<span><span class="co">#&gt; /_____/                   /_/     /_____/</span></span>
<span><span class="co">#&gt;     worker:        ecological_snake_1</span></span>
<span><span class="co">#&gt;     config:        localhost</span></span>
<span><span class="co">#&gt;     rrq_version:   0.7.23</span></span>
<span><span class="co">#&gt;     platform:      x86_64-pc-linux-gnu</span></span>
<span><span class="co">#&gt;     running:       Ubuntu 24.04.2 LTS</span></span>
<span><span class="co">#&gt;     hostname:      fv-az1118-568</span></span>
<span><span class="co">#&gt;     username:      runner</span></span>
<span><span class="co">#&gt;     queue:         rrq:01e14764:queue:default</span></span>
<span><span class="co">#&gt;     wd:            /home/runner/work/rrq/rrq/vignettes</span></span>
<span><span class="co">#&gt;     pid:           8958</span></span>
<span><span class="co">#&gt;     redis_host:    127.0.0.1</span></span>
<span><span class="co">#&gt;     redis_port:    6379</span></span>
<span><span class="co">#&gt;     heartbeat_key: rrq:01e14764:worker:ecological_snake_1:heartbeat</span></span>
<span><span class="co">#&gt;     offload_path:  &lt;not set&gt;</span></span></code></pre>
<p>We also have a heartbeat key here that we can inspect:</p>
<div class="sourceCode" id="cb43"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">info</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/rrq_worker_info.html">rrq_worker_info</a></span><span class="op">(</span><span class="op">)</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span></span>
<span><span class="va">obj</span><span class="op">$</span><span class="va">con</span><span class="op">$</span><span class="fu">EXISTS</span><span class="op">(</span><span class="va">info</span><span class="op">$</span><span class="va">heartbeat_key</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 1</span></span>
<span><span class="va">obj</span><span class="op">$</span><span class="va">con</span><span class="op">$</span><span class="fu">PTTL</span><span class="op">(</span><span class="va">info</span><span class="op">$</span><span class="va">heartbeat_key</span><span class="op">)</span> <span class="co"># in milliseconds</span></span>
<span><span class="co">#&gt; [1] 5788</span></span></code></pre></div>
<p>We queue some slow job onto the worker:</p>
<div class="sourceCode" id="cb44"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">t</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/rrq_task_create_expr.html">rrq_task_create_expr</a></span><span class="op">(</span><span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/Sys.sleep.html" class="external-link">Sys.sleep</a></span><span class="op">(</span><span class="fl">10</span><span class="op">)</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span></span>
<span><span class="op">}</span><span class="op">)</span></span></code></pre></div>
<p>Then we kill the worker:</p>
<div class="sourceCode" id="cb45"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">tools</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/tools/pskill.html" class="external-link">pskill</a></span><span class="op">(</span><span class="fu"><a href="../reference/rrq_worker_info.html">rrq_worker_info</a></span><span class="op">(</span><span class="op">)</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">$</span><span class="va">pid</span><span class="op">)</span></span></code></pre></div>
<p>Of course, immediately our key still exists:</p>
<div class="sourceCode" id="cb46"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">obj</span><span class="op">$</span><span class="va">con</span><span class="op">$</span><span class="fu">EXISTS</span><span class="op">(</span><span class="va">info</span><span class="op">$</span><span class="va">heartbeat_key</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 1</span></span></code></pre></div>
<p>but eventually it will expire:</p>
<div class="sourceCode" id="cb47"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Sys.sleep.html" class="external-link">Sys.sleep</a></span><span class="op">(</span><span class="fl">6</span><span class="op">)</span></span>
<span><span class="va">obj</span><span class="op">$</span><span class="va">con</span><span class="op">$</span><span class="fu">EXISTS</span><span class="op">(</span><span class="va">info</span><span class="op">$</span><span class="va">heartbeat_key</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 0</span></span></code></pre></div>
<p>So far as <code>rrq</code> is concerned, at this point your task is
still running</p>
<div class="sourceCode" id="cb48"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/rrq_task_status.html">rrq_task_status</a></span><span class="op">(</span><span class="va">t</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "RUNNING"</span></span></code></pre></div>
<p>Handling this situation is still completely manual. You can detect
lost workers jobs with:</p>
<div class="sourceCode" id="cb49"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/rrq_worker_detect_exited.html">rrq_worker_detect_exited</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="co">#&gt; Lost 1 worker:</span></span>
<span><span class="co">#&gt;   - ecological_snake_1</span></span>
<span><span class="co">#&gt; Orphaning 1 task:</span></span>
<span><span class="co">#&gt;   - 472696c5fc193c6b98376fd384e180cf</span></span></code></pre></div>
<p>this will also “orphan” the task</p>
<div class="sourceCode" id="cb50"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/rrq_task_status.html">rrq_task_status</a></span><span class="op">(</span><span class="va">t</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "DIED"</span></span></code></pre></div>
<p>Any tasks that were dependent on this task will now be marked as
<code>IMPOSSIBLE</code>.</p>
<p>In a future version we will support automatic re-queuing of jobs
assigned to disappeared workers.</p>
</div>
<div class="section level2">
<h2 id="getting-a-redis-server">Getting a Redis server<a class="anchor" aria-label="anchor" href="#getting-a-redis-server"></a>
</h2>
<p>There are several options to get started with Redis, the best one
will likely depend on your platform and needs.</p>
<div class="section level3">
<h3 id="use-docker-1">Use docker<a class="anchor" aria-label="anchor" href="#use-docker-1"></a>
</h3>
<p>(Linux, macOS with <a href="https://docs.docker.com/docker-for-mac/install/" class="external-link">docker
desktop</a>, Windows with <a href="https://docs.docker.com/docker-for-windows/install/" class="external-link">docker
desktop</a>)</p>
<p>This is how we develop rrq because it’s easy to destroy and recreate
the redis instance. Start the docker redis container like:</p>
<pre><code>docker run --name redis --rm -d -p 127.0.0.1:6379:6379 redis</code></pre>
<p>This will listen on port 6379 which is the Redis default. You can
stop the container (deleting all data) with
<code>docker stop redis</code></p>
</div>
<div class="section level3">
<h3 id="install-redis">Install Redis<a class="anchor" aria-label="anchor" href="#install-redis"></a>
</h3>
<p>On Linux this is fairly straightforward, either by <a href="https://redis.io/download" class="external-link">downloading and building the source
code</a> or by installing via <code>apt</code> or <code>snap</code></p>
<p>On macOS the source will compile, or you can install a redis server
via homebrew</p>
<p>On Windows you can <a href="https://redis.com/blog/redis-on-windows-10/" class="external-link">install redis via
WSL</a>. There have also been various ports.</p>
</div>
<div class="section level3">
<h3 id="use-redis-on-a-different-machine">Use Redis on a different machine<a class="anchor" aria-label="anchor" href="#use-redis-on-a-different-machine"></a>
</h3>
<p>If you have redis running on a different machine (this will be the
case if you’re using redis to distribute tasks over a number of
different machines) you will need to tell <code>rrq</code> and
<code>redux</code> where to find it. The simplest way is to set the
environment variable <code>REDIS_HOST</code> to the name of the machine
if it is running with default ports, or set <code>REDUX_URL</code> if
you need more control. Alternatively, when connecting to the server
above, you can manually construct your <code><a href="https://rdrr.io/pkg/redux/man/hiredis.html" class="external-link">redux::hiredis</a></code>
object and pass in any configuration option you need; see the
documentation for <code><a href="https://rdrr.io/pkg/redux/man/redis_config.html" class="external-link">redux::redis_config</a></code> for details.</p>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Rich FitzJohn, Robert Ashton.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.2.</p>
</div>

    </footer>
</div>





  </body>
</html>
