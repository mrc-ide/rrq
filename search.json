[{"path":"https://mrc-ide.github.io/rrq/articles/fault-tolerance.html","id":"error-handling","dir":"Articles","previous_headings":"","what":"Error handling","title":"Fault tolerance","text":"start simplest sort fault, can just easily happen locally remotely rrq. case handling fairly well defined ’s much need . section really “fault tolerance” , simply rrq handles errors can . Consider simple function fit linear model two variables: happy case, everything works expected: provide invalid input, task error: first thing note task throw error fetch result, either via task_wait , via task_result: However, result object rrq_task_error can test using inherits: default behaviour rrq error fetching task require use tryCatch everywhere retrieve tasks might failed, errors often interesting . example, rrq_task_error objects include stack traces alongside error: rlang stack traces, somewhat richer produced traceback(), containing set stacks arranged tree. See documentation details. error object also include warnings captured task ran. Objects class rrq_task_error inherit error condition , thrown, behave expected programs using errors flow control (e.g., tryCatch); can throw stop(): can also change default behaviour error failure passing error = TRUE rrq_task_result() rrq_tasks_result(), immediately rethrow error R session (program stop catch tryCatch): process unchanged task run separate process (separate_process = TRUE passed enqueue), status return type, trace information available failure.","code":"fit_model <- function(x, y) {   lm(y ~ x) } library(rrq) obj <- rrq_controller(paste0(\"rrq:\", ids::random_id(bytes = 4))) rrq_default_controller_set(obj) rrq_worker_envir_set(rrq_envir(sources = \"fault.R\")) w <- rrq_worker_spawn() #> ℹ Spawning 1 worker with prefix 'nonspheric_siberiantiger' x <- runif(5) y <- 2 * x + rnorm(length(x), 0, 0.2) t <- rrq_task_create_expr(fit_model(x, y)) rrq_task_wait(t, 10) #> [1] TRUE rrq_task_status(t) #> [1] \"COMPLETE\" rrq_task_result(t) #>  #> Call: #> lm(formula = y ~ x) #>  #> Coefficients: #> (Intercept)            x   #>    -0.04097      1.87959 t <- rrq_task_create_expr(fit_model(x, NULL)) rrq_task_wait(t, 10) #> [1] FALSE rrq_task_result(t) #> <rrq_task_error> #>   from:   model.frame.default(formula = y ~ x, drop.unused.levels = TRUE) #>   error:  invalid type (NULL) for variable 'y' #>   queue:  rrq:ec94d401 #>   task:   61cf8d81b04c799fa15541333a4748ca #>   status: ERROR #>   * To throw this error, use stop() with it #>   * This error has a stack trace, use '$trace' to see it r <- rrq_task_result(t) r #> <rrq_task_error> #>   from:   model.frame.default(formula = y ~ x, drop.unused.levels = TRUE) #>   error:  invalid type (NULL) for variable 'y' #>   queue:  rrq:ec94d401 #>   task:   61cf8d81b04c799fa15541333a4748ca #>   status: ERROR #>   * To throw this error, use stop() with it #>   * This error has a stack trace, use '$trace' to see it inherits(r, \"rrq_task_error\") #> [1] TRUE r$trace #>      ▆ #>   1. ├─rlang::try_fetch(...) #>   2. │ ├─base::tryCatch(...) #>   3. │ │ └─base (local) tryCatchList(expr, classes, parentenv, handlers) #>   4. │ │   └─base (local) tryCatchOne(expr, names, parentenv, handlers[[1L]]) #>   5. │ │     └─base (local) doTryCatch(return(expr), name, parentenv, handler) #>   6. │ └─base::withCallingHandlers(...) #>   7. ├─base::eval(task$expr, envir) #>   8. │ └─base::eval(task$expr, envir) #>   9. │   └─fit_model(x, NULL) #>  10. │     ├─stats::lm(y ~ x) #>  11. │     │ └─base::eval(mf, parent.frame()) #>  12. │     │   └─base::eval(mf, parent.frame()) #>  13. │     ├─stats::model.frame(formula = y ~ x, drop.unused.levels = TRUE) #>  14. │     └─stats::model.frame.default(formula = y ~ x, drop.unused.levels = TRUE) #>  15. └─base::.handleSimpleError(...) #>  16.   └─rlang (local) h(simpleError(msg, call)) #>  17.     └─handlers[[3L]](cnd) stop(r) #> Error in model.frame.default(formula = y ~ x, drop.unused.levels = TRUE): invalid type (NULL) for variable 'y' rrq_task_result(t, error = TRUE) #> Error in model.frame.default(formula = y ~ x, drop.unused.levels = TRUE): invalid type (NULL) for variable 'y'"},{"path":"https://mrc-ide.github.io/rrq/articles/fault-tolerance.html","id":"increasing-resilience-via-separate-processes","dir":"Articles","previous_headings":"","what":"Increasing resilience via separate processes","title":"Fault tolerance","text":"Running tasks separate processes (e.g., rrq_task_create_expr(mytask(), separate_process = TRUE)) simplest way making things resilient creates layer isolation worker task. task crashes R (e.g., segmentation fault due bug C/C++ code) killed operating system worker process survives can update keys Redis directly advertise fact. generally much nicer worker dies task status updated. downside using separate processes much slower; compare time taken queue, run retrieve trivial task run worker process (look elapsed entry) task run separate process worker expect difference ~100 fold local workers. Almost cost due overhead starting terminating fresh R session. queue uses lot packages additional overhead loaded. However, cost fixed decrease fraction total running time running time task increases. long-running tasks additional safety separate processes probably worthwhile. smaller tasks may want make sure run heartbeat process can handle failures via route. Consider running long running job; one simply sleeps hour simulate process crashing, ’ve killed . queued separate process can use rrq_task_info() fetch process id (PID) process task running (different worker). task run separate process, worker detect task died unexpectedly: different error status previous section (ERROR). Note run task separate process task status unchanged RUNNING) nothing ever update task status! Retrieving result similar behaviour error case; don’t throw instead return object class rrq_task_error (also inherits error condition). However, time ’s really much extra information error: ’s also trace available","code":"system.time(   rrq_task_wait(rrq_task_create_expr(identity(1)), 10)) #>    user  system elapsed  #>   0.001   0.000   0.003 system.time(   rrq_task_wait(rrq_task_create_expr(identity(1), separate_process = TRUE), 10)) #>    user  system elapsed  #>   0.001   0.000   0.341 t <- rrq_task_create_expr(Sys.sleep(3600), separate_process = TRUE) info <- rrq_task_info(t) tools::pskill(info$pid) rrq_task_status(t) #> [1] \"DIED\" r <- rrq_task_result(t) r #> <rrq_task_error> #>   error:  Task not successful: DIED #>   queue:  rrq:ec94d401 #>   task:   7a0c917d05f185dcc3884a149ea88f1d #>   status: DIED #>   * To throw this error, use stop() with it r$trace #> NULL"},{"path":"https://mrc-ide.github.io/rrq/articles/fault-tolerance.html","id":"loss-of-workers","dir":"Articles","previous_headings":"","what":"Loss of workers","title":"Fault tolerance","text":"section outline can unexplained unreported failures task, loss workers. typically worker crashed (due task crashing perhaps), killed (e.g., operating system administrator) loss machine working . order enable fault tolerance sort issue, first need enable “heartbeat” worker processes. second process worker periodically writes Redis database key expire time slightly longer period, effect making dead man’s switch - see rrq::rrq_heartbeat details. worker process dies reason, ’ll detect key expired. can take action. enable heartbeat, save worker configuration starting worker: spawn worker pick configuration, ’ll able detect died. order simulate loss worker, kill starting long-running task: Now, can queue long running process, worker start: worker pick task fairly quickly, status change RUNNING: kill worker (simulating job crashing, machine turning , etc): worker killed, can’t write redis tell us task can’t completed, status never change: heartbeat persist 3 times period given (multiplier configurable number greater 1 OK, picked allows occasional network connectivity issues slowness node - may reduce future version). means 9s (3 * 3s) key expired: can use worker_detect_exited() method clean point, statuses task worker correct: Fetching task result provides DIED error : still terribly useful, provided mechanism automatically requeue lost task restart dead worker, cover next section.","code":"rrq_worker_config_save(   \"localhost\",   rrq_worker_config(heartbeat_period = 3)) w <- rrq_worker_spawn() #> ℹ Spawning 1 worker with prefix 'indistinct_indianspinyloach' t <- rrq_task_create_expr(Sys.sleep(3600)) rrq_task_status(t) #> [1] \"RUNNING\" rrq_worker_status(w$id) #> indistinct_indianspinyloach_1  #>                        \"BUSY\" w$kill() rrq_task_status(t) #> [1] \"RUNNING\" rrq_worker_status(w$id) #> indistinct_indianspinyloach_1  #>                        \"BUSY\" Sys.sleep(10) rrq_worker_detect_exited() #> Lost 1 worker: #>   - indistinct_indianspinyloach_1 #> Orphaning 1 task: #>   - a7187e6afa751d68b44b3d2f34265fbb rrq_task_status(t) #> [1] \"DIED\" rrq_worker_status(w$id) #> indistinct_indianspinyloach_1  #>                        \"LOST\" rrq_task_result(t) #> <rrq_task_error> #>   error:  Task not successful: DIED #>   queue:  rrq:ec94d401 #>   task:   a7187e6afa751d68b44b3d2f34265fbb #>   status: DIED #>   * To throw this error, use stop() with it"},{"path":"https://mrc-ide.github.io/rrq/articles/fault-tolerance.html","id":"retrying-tasks","dir":"Articles","previous_headings":"","what":"Retrying tasks","title":"Fault tolerance","text":"Regardless tasks got broken situation, mechanism getting situation remains ; want retry task: task might errored resource unavailable full now back line worker might died someone turned machine memory errors happen sometimes feel lucky (case also fix program!) Alternatively, perhaps task ran successful completion simply want rerun (e.g., stochastic algorithm displaying non-fatal pathology). can use rrq_task_retry retry number tasks completed (one terminal states - including COMPLETE also ERROR, CANCELLED DIED TIMEOUT). nondestructive task data, particular result, still access failed run stack trace (see ).","code":""},{"path":"https://mrc-ide.github.io/rrq/articles/fault-tolerance.html","id":"an-example-where-retrying-fixes-an-error","dir":"Articles","previous_headings":"Retrying tasks","what":"An example where retrying fixes an error","title":"Fault tolerance","text":"example, ’ll run “model” may may converge, want retry . represents badly behaved task stochastic component eventually work tried enough times: can create new environment worker, pick function: Now, enqueue task usual, wait Oh , task failed! can use task_retry method requeue job, meaning run exactly . However, random number stream moved task return different answer - perhaps work time? task failed . Note task_retry taken task id returned new task id, waited . However, also used original id (). Let’s give one go: Success! task run completion longer error. retry task, rrq sets redirects point old task id new one, cases can use whichever find convenient. example, can now read successful task result task ids: prevent , pass follow = FALSE return original result , can see first two times ran task failed, along error backtraces. logic applies functions, rrq_task_status() Note task status overwritten original status (previously ERROR, now MOVED). However, can always read original status error object’s status field, need . can also extract times events happened rrq_task_times() means time can ignore task retried work whatever task id handy. can inspect chain tasks looking return values rrq_task_info(). example chain three tasks r backquote(paste0(substr(c(t1, t2, t3), 1, 6), \"...\", collapse = \" -> \")), can discover way: , moved field shows tasks upstream () downstream () task. tasks never retried elements NULL. elements always ordered oldest newest, chains tasks always linear (.e., forking). middle task chain, point different tasks: leaf task:","code":"stochastic_failure <- function(p) {   x <- runif(1)   if (x < p) {     stop(sprintf(\"Convergence failure - x is only %0.2f\", x))   }   x } rrq_worker_envir_set(rrq_envir(sources = \"fault2.R\")) w <- rrq::rrq_worker_spawn() #> ℹ Spawning 1 worker with prefix 'ecological_snake' t1 <- rrq_task_create_expr(stochastic_failure(0.5)) rrq_task_wait(t1, timeout = 10) #> [1] FALSE rrq_task_result(t1) #> <rrq_task_error> #>   from:   stochastic_failure(0.5) #>   error:  Convergence failure - x is only 0.27 #>   queue:  rrq:ec94d401 #>   task:   c4ab320544709b0842cbfde192a5d827 #>   status: ERROR #>   * To throw this error, use stop() with it #>   * This error has a stack trace, use '$trace' to see it t2 <- rrq_task_retry(t1) rrq_task_wait(t2, timeout = 10) #> [1] FALSE rrq_task_result(t2) #> <rrq_task_error> #>   from:   stochastic_failure(0.5) #>   error:  Convergence failure - x is only 0.37 #>   queue:  rrq:ec94d401 #>   task:   838eb0c3fff61b9bc61332b3194fa79c #>   status: ERROR #>   * To throw this error, use stop() with it #>   * This error has a stack trace, use '$trace' to see it t3 <- rrq_task_retry(t2) rrq_task_wait(t3, timeout = 10) #> [1] TRUE rrq_task_result(t3) #> [1] 0.5728534 rrq_task_results(c(t1, t2, t3)) #> [[1]] #> [1] 0.5728534 #>  #> [[2]] #> [1] 0.5728534 #>  #> [[3]] #> [1] 0.5728534 rrq_task_results(c(t1, t2, t3), follow = FALSE) #> [[1]] #> <rrq_task_error> #>   from:   stochastic_failure(0.5) #>   error:  Convergence failure - x is only 0.27 #>   queue:  rrq:ec94d401 #>   task:   c4ab320544709b0842cbfde192a5d827 #>   status: ERROR #>   * To throw this error, use stop() with it #>   * This error has a stack trace, use '$trace' to see it #>  #> [[2]] #> <rrq_task_error> #>   from:   stochastic_failure(0.5) #>   error:  Convergence failure - x is only 0.37 #>   queue:  rrq:ec94d401 #>   task:   838eb0c3fff61b9bc61332b3194fa79c #>   status: ERROR #>   * To throw this error, use stop() with it #>   * This error has a stack trace, use '$trace' to see it #>  #> [[3]] #> [1] 0.5728534 rrq_task_status(c(t1, t2, t3)) #> [1] \"COMPLETE\" \"COMPLETE\" \"COMPLETE\" rrq_task_status(c(t1, t2, t3), follow = FALSE) #> [1] \"MOVED\"    \"MOVED\"    \"COMPLETE\" rrq_task_times(c(t1, t2, t3)) #>                                      submit      start   complete moved #> c4ab320544709b0842cbfde192a5d827 1746804788 1746804788 1746804788    NA #> 838eb0c3fff61b9bc61332b3194fa79c 1746804788 1746804788 1746804788    NA #> 28c4f021a8be85ee2984eaea85fd936d 1746804788 1746804788 1746804788    NA rrq_task_times(c(t1, t2, t3), follow = FALSE) #>                                      submit      start   complete      moved #> c4ab320544709b0842cbfde192a5d827 1746804788 1746804788 1746804788 1746804788 #> 838eb0c3fff61b9bc61332b3194fa79c 1746804788 1746804788 1746804788 1746804788 #> 28c4f021a8be85ee2984eaea85fd936d 1746804788 1746804788 1746804788         NA rrq_task_info(t1) #> $id #> [1] \"c4ab320544709b0842cbfde192a5d827\" #>  #> $status #> [1] \"MOVED\" #>  #> $queue #> [1] \"default\" #>  #> $separate_process #> [1] FALSE #>  #> $timeout #> NULL #>  #> $worker #> [1] \"ecological_snake_1\" #>  #> $pid #> NULL #>  #> $depends #> $depends$up #> NULL #>  #> $depends$down #> NULL #>  #>  #> $moved #> $moved$up #> NULL #>  #> $moved$down #> [1] \"838eb0c3fff61b9bc61332b3194fa79c\" \"28c4f021a8be85ee2984eaea85fd936d\" rrq_task_info(t2)$moved #> $up #> [1] \"c4ab320544709b0842cbfde192a5d827\" #>  #> $down #> [1] \"28c4f021a8be85ee2984eaea85fd936d\" rrq_task_info(t3)$moved #> $up #> [1] \"c4ab320544709b0842cbfde192a5d827\" \"838eb0c3fff61b9bc61332b3194fa79c\" #>  #> $down #> NULL"},{"path":"https://mrc-ide.github.io/rrq/articles/fault-tolerance.html","id":"performance-considerations","dir":"Articles","previous_headings":"Retrying tasks","what":"Performance considerations","title":"Fault tolerance","text":"possible change default behaviour follow follow task chain. might slightly efficient cases interested running large numbers small tasks want retry failed tasks. almost every request involves task id check see moved. change behaviour, pass follow argument queue constructor, example: , create queue controller object default follow behaviour set FALSE accessing task result moved task search potential retries unless follow = TRUE explicitly passed.","code":"obj_nofollow <- rrq_controller(obj$queue_id, follow = FALSE) rrq_task_result(t1, controller = obj_nofollow) #> <rrq_task_error> #>   from:   stochastic_failure(0.5) #>   error:  Convergence failure - x is only 0.27 #>   queue:  rrq:ec94d401 #>   task:   c4ab320544709b0842cbfde192a5d827 #>   status: ERROR #>   * To throw this error, use stop() with it #>   * This error has a stack trace, use '$trace' to see it"},{"path":"https://mrc-ide.github.io/rrq/articles/fault-tolerance.html","id":"deleting-tasks-that-have-been-retried","dir":"Articles","previous_headings":"Retrying tasks","what":"Deleting tasks that have been retried","title":"Fault tolerance","text":"Deletion operate tasks chain. delete task retried deletes everything upstream (original task) downstream (last time task retried). otherwise easy end inconsistent state. run three tasks chain deleted:","code":"rrq_task_delete(t1) rrq_task_status(c(t1, t2, t3), follow = FALSE) #> [1] \"MISSING\" \"MISSING\" \"MISSING\""},{"path":"https://mrc-ide.github.io/rrq/articles/fault-tolerance.html","id":"going-further","dir":"Articles","previous_headings":"Retrying tasks","what":"Going further","title":"Fault tolerance","text":"Currently system allow things useful can’t change queue retry task (configurations multiple queues) can’t automatically retry task failure (e.g., try 5 times giving entirely) can’t retry tasks become impossible due failure dependent task, even task retried since succeeded relax limitations soon.","code":""},{"path":"https://mrc-ide.github.io/rrq/articles/messages.html","id":"messages-and-responses","dir":"Articles","previous_headings":"","what":"Messages and responses","title":"messages","text":"queue sends message one workers process. message identifier derived current time. Messages written first--first-queue, per worker, processed independently workers look see workers messages processing . soon worker finished processing current job process message (must wait finish current job start jobs). message processed (see ) response written response list identifier message. messages interact worker timeout: PING, ECHO, EVAL, INFO PAUSE, RESUME REFRESH reset timer, task run TIMEOUT_SET explicitly interacts timer TIMEOUT_GET reset timer, reporting remaining time STOP causes worker exit, interaction timer","code":""},{"path":"https://mrc-ide.github.io/rrq/articles/messages.html","id":"ping","dir":"Articles","previous_headings":"","what":"PING","title":"messages","text":"PING message simply asks worker return PONG. ’s useful diagnosing communication issues little message id going useful getting responses: (derived current time, according Redis central reference point time whole system). logfile prints: request PING (MESSAGE PING) value PONG R message stream logging response (RESPONSE PONG), means something written response stream. can access bits information worker log: includes ALIVE message worker comes . Inspecting logs fine interactive use, ’s going useful often poll response. already know worker response, can ask anyway: inversely can messages given worker responses : fetch responses workers sent (always returning named list): fetch response given worker: response can deleted passing delete = TRUE method: recalling message throw error: also timeout argument lets wait response ready (rrq_task_wait()). Looking log show went : task received 2s later task completed message received , basically instantaneously, message responded However, message processed task completed, response takes come back. Equivalently, worker log:","code":"message_id <- rrq_message_send(\"PING\") message_id #> [1] \"1746804791.239048\" [2025-05-09 15:33:11.239455] MESSAGE PING PONG [2025-05-09 15:33:11.240036] RESPONSE PING rrq_worker_log_tail(n = Inf) #>                    worker_id child       time  command message #> 1 nonspheric_siberiantiger_1    NA 1746804791    ALIVE         #> 2 nonspheric_siberiantiger_1    NA 1746804791    ENVIR     new #> 3 nonspheric_siberiantiger_1    NA 1746804791    QUEUE default #> 4 nonspheric_siberiantiger_1    NA 1746804791  MESSAGE    PING #> 5 nonspheric_siberiantiger_1    NA 1746804791 RESPONSE    PING rrq_message_has_response(message_id) #> nonspheric_siberiantiger_1  #>                       TRUE rrq_message_response_ids(worker_id) #> [1] \"1746804791.239048\" rrq_message_get_response(message_id) #> $nonspheric_siberiantiger_1 #> [1] \"PONG\" rrq_message_get_response(message_id, worker_id) #> $nonspheric_siberiantiger_1 #> [1] \"PONG\" rrq_message_get_response(message_id, worker_id, delete = TRUE) #> $nonspheric_siberiantiger_1 #> [1] \"PONG\" rrq_message_get_response(message_id, worker_id) #> Error in `rrq_message_get_response()`: #> ! Response missing for worker: 'nonspheric_siberiantiger_1' rrq_task_create_expr(Sys.sleep(2)) #> [1] \"aa5abd7302610e0fcc8fcbadb0c4a94e\" message_id <- rrq_message_send(\"PING\") rrq_message_get_response(   message_id, worker_id, delete = TRUE, timeout = 10) #> $nonspheric_siberiantiger_1 #> [1] \"PONG\" rrq_worker_log_tail(n = 4) #>                    worker_id child       time       command #> 1 nonspheric_siberiantiger_1    NA 1746804792    TASK_START #> 2 nonspheric_siberiantiger_1    NA 1746804794 TASK_COMPLETE #> 3 nonspheric_siberiantiger_1    NA 1746804794       MESSAGE #> 4 nonspheric_siberiantiger_1    NA 1746804794      RESPONSE #>                            message #> 1 aa5abd7302610e0fcc8fcbadb0c4a94e #> 2 aa5abd7302610e0fcc8fcbadb0c4a94e #> 3                             PING #> 4                             PING [2025-05-09 15:33:12.050812] TASK_START aa5abd7302610e0fcc8fcbadb0c4a94e [2025-05-09 15:33:14.055233] TASK_COMPLETE aa5abd7302610e0fcc8fcbadb0c4a94e [2025-05-09 15:33:14.055767] MESSAGE PING PONG [2025-05-09 15:33:14.056075] RESPONSE PING"},{"path":"https://mrc-ide.github.io/rrq/articles/messages.html","id":"echo","dir":"Articles","previous_headings":"","what":"ECHO","title":"messages","text":"basically like PING interesting; prints arbitrary string log. always returns \"OK\" response.","code":"message_id <- rrq_message_send(\"ECHO\", \"hello world!\") rrq_message_get_response(message_id, worker_id, timeout = 10) #> $nonspheric_siberiantiger_1 #> [1] \"OK\" [2025-05-09 15:33:14.752853] MESSAGE ECHO hello world! [2025-05-09 15:33:14.753465] RESPONSE ECHO"},{"path":"https://mrc-ide.github.io/rrq/articles/messages.html","id":"info","dir":"Articles","previous_headings":"","what":"INFO","title":"messages","text":"INFO command refreshes returns worker information. already copy worker info; created worker started : can force worker refresh: ’s new worker information, complete updated envir field:","code":"rrq_worker_info()[[worker_id]] #>   <rrq_worker_info> #>     worker:        nonspheric_siberiantiger_1 #>     config:        localhost #>     rrq_version:   0.7.23 #>     platform:      x86_64-pc-linux-gnu #>     running:       Ubuntu 24.04.2 LTS #>     hostname:      fv-az1118-568 #>     username:      runner #>     queue:         rrq:c29119c2:queue:default #>     wd:            /home/runner/work/rrq/rrq/vignettes #>     pid:           8789 #>     redis_host:    127.0.0.1 #>     redis_port:    6379 #>     heartbeat_key: NULL #>     offload_path:  NULL message_id <- rrq_message_send(\"INFO\") rrq_message_get_response(message_id, worker_id, timeout = 10) #> $nonspheric_siberiantiger_1 #> $nonspheric_siberiantiger_1$worker #> [1] \"nonspheric_siberiantiger_1\" #>  #> $nonspheric_siberiantiger_1$config #> [1] \"localhost\" #>  #> $nonspheric_siberiantiger_1$rrq_version #> [1] \"0.7.23\" #>  #> $nonspheric_siberiantiger_1$platform #> [1] \"x86_64-pc-linux-gnu\" #>  #> $nonspheric_siberiantiger_1$running #> [1] \"Ubuntu 24.04.2 LTS\" #>  #> $nonspheric_siberiantiger_1$hostname #> [1] \"fv-az1118-568\" #>  #> $nonspheric_siberiantiger_1$username #> [1] \"runner\" #>  #> $nonspheric_siberiantiger_1$queue #> [1] \"rrq:c29119c2:queue:default\" #>  #> $nonspheric_siberiantiger_1$wd #> [1] \"/home/runner/work/rrq/rrq/vignettes\" #>  #> $nonspheric_siberiantiger_1$pid #> [1] 8789 #>  #> $nonspheric_siberiantiger_1$redis_host #> [1] \"127.0.0.1\" #>  #> $nonspheric_siberiantiger_1$redis_port #> [1] 6379 #>  #> $nonspheric_siberiantiger_1$heartbeat_key #> NULL #>  #> $nonspheric_siberiantiger_1$offload_path #> NULL"},{"path":"https://mrc-ide.github.io/rrq/articles/messages.html","id":"eval","dir":"Articles","previous_headings":"","what":"EVAL","title":"messages","text":"Evaluate arbitrary R expression, passed string (sort unevaluated quoted expression). expression evaluated global environment, environment queued code evaluated . used evaluate code side effects, installing packages. However, due limitations R loads packages way update reload package going restart worker.","code":"message_id <- rrq_message_send(\"EVAL\", \"1 + 1\") rrq_message_get_response(message_id, worker_id, timeout = 10) #> $nonspheric_siberiantiger_1 #> [1] 2"},{"path":"https://mrc-ide.github.io/rrq/articles/messages.html","id":"pause-resume","dir":"Articles","previous_headings":"","what":"PAUSE / RESUME","title":"messages","text":"PAUSE / RESUME messages can used prevent workers picking new work (allowing start ). paused workers ignore tasks, stay queue: Sending RESUME message unpauses worker:","code":"rrq_worker_status() #> nonspheric_siberiantiger_1  #>                     \"IDLE\" message_id <- rrq_message_send(\"PAUSE\") rrq_message_get_response(message_id, worker_id, timeout = 10) #> $nonspheric_siberiantiger_1 #> [1] \"OK\" rrq_worker_status() #> nonspheric_siberiantiger_1  #>                   \"PAUSED\" t <- rrq_task_create_expr(runif(5)) rrq_task_status(t) #> [1] \"PENDING\" message_id <- rrq_message_send(\"RESUME\") rrq_message_get_response(message_id, worker_id, timeout = 10) #> $nonspheric_siberiantiger_1 #> [1] \"OK\" rrq_task_wait(t, 5) #> [1] TRUE"},{"path":"https://mrc-ide.github.io/rrq/articles/messages.html","id":"set_timeout-get_timeout","dir":"Articles","previous_headings":"","what":"SET_TIMEOUT / GET_TIMEOUT","title":"messages","text":"Workers quit left idle certain time; timeout. processing tasks counts work (messages). can query timeout GET_TIMEOUT set SET_TIMEOUT. worker timeout infinite; never quit: can set finite value, seconds: timeout set 10 minutes (600s). set, TIMEOUT_GET returns length time remaining worker exits One useful pattern send work workers, set timeout zero. means work complete exit (almost) immediately: worker remain idle 60s (default) length time one poll work lasts, exit.","code":"rrq_message_send_and_wait(\"TIMEOUT_GET\", worker_ids = worker_id) #> $nonspheric_siberiantiger_1 #> timeout_idle    remaining  #>          Inf          Inf rrq_message_send_and_wait(\"TIMEOUT_SET\", 600, worker_ids = worker_id) #> $nonspheric_siberiantiger_1 #> [1] \"OK\" rrq_message_send_and_wait(\"TIMEOUT_GET\", worker_ids = worker_id) #> $nonspheric_siberiantiger_1 #> timeout_idle    remaining  #>     600.0000     599.8851 Sys.sleep(5) rrq_message_send_and_wait(\"TIMEOUT_GET\", worker_ids = worker_id) #> $nonspheric_siberiantiger_1 #> timeout_idle    remaining  #>     600.0000     594.8315 ids <- rrq_task_create_bulk_call(function(x) {   Sys.sleep(0.5)   runif(x) }, 1:5) rrq_message_send(\"TIMEOUT_SET\", 0, worker_id) rrq_task_wait(ids) #> [1] TRUE rrq_task_results(ids) #> [[1]] #> [1] 0.2621188 #>  #> [[2]] #> [1] 0.4395982 0.4428071 #>  #> [[3]] #> [1] 0.6248181 0.9971756 0.9929622 #>  #> [[4]] #> [1] 0.4135190 0.3477054 0.4453713 0.6302362 #>  #> [[5]] #> [1] 0.07060784 0.27927816 0.54133812 0.37507236 0.34581227 rrq_worker_status(worker_id) #> nonspheric_siberiantiger_1  #>                     \"IDLE\" rrq_message_send_and_wait(\"TIMEOUT_GET\", worker_ids = worker_id) #> $nonspheric_siberiantiger_1 #> timeout_idle    remaining  #>            0            0"},{"path":"https://mrc-ide.github.io/rrq/articles/messages.html","id":"messages-that-are-supported-but-use-via-wrappers","dir":"Articles","previous_headings":"","what":"Messages that are supported but use via wrappers:","title":"messages","text":"methods typically used via methods [rrq_controller] object. REFRESH: requests worker refresh evaluation environment. Typically used via rrq_worker_envir_set() STOP: sent informational message argument, requests worker stop. Typically used via rrq_worker_stop()","code":""},{"path":"https://mrc-ide.github.io/rrq/articles/rrq.html","id":"getting-started","dir":"Articles","previous_headings":"","what":"Getting started","title":"rrq","text":"document assumes Redis server running. , see bottom document options installing system. can test Redis server behaving expected running get error like “Connection refused” check installation. package designed easy get started , features might like use later. run “Hello world” section probably 90% need - result document show features help bend around specific needs.","code":"redux::hiredis()$PING() #> [Redis: PONG]"},{"path":"https://mrc-ide.github.io/rrq/articles/rrq.html","id":"hello-world","dir":"Articles","previous_headings":"","what":"Hello world","title":"rrq","text":"Without great explanation, basic approach using rrq run task another R process, asynchronously. First, create “controller” object can use queuing tasks. controller uses “identifier” (, id rrq:bab779d8) can anything want acts like folder within Redis server, distinguishing queue others hosted server. set default controller use, means can avoid passing controller = obj calls : Submit task queue rrq_task_create_expr(), returning key hat task ’ll also need worker processes carry tasks. , ’ll spawn two now (see section alternatives ) +Wait task complete: retrieve result Things note : Every task given unique identifier, can used query task later (much ) process controller blocked operation carry calculation wanted (even closed controller recreated later) submitted tasks workers ready; done order, workers can added removed regardless state queue (see )","code":"library(rrq) id <- paste0(\"rrq:\", ids::random_id(bytes = 4)) obj <- rrq_controller(id) rrq_default_controller_set(obj) t <- rrq_task_create_expr(1 + 1) t #> [1] \"498a14828ff4233d26242641639dc5c6\" w <- rrq_worker_spawn(2) #> ℹ Spawning 2 workers with prefix 'nonspheric_siberiantiger' rrq_task_wait(t) #> [1] TRUE rrq_task_result(t) #> [1] 2"},{"path":"https://mrc-ide.github.io/rrq/articles/rrq.html","id":"design","dir":"Articles","previous_headings":"","what":"Design","title":"rrq","text":"years, parallel package provided users ability run tasks parallel little setup. Given list data x function f, one can change serial code run parallel given cluster object cl (even simpler parallel::mclapply(x, fun) can used platforms Windows reasonable success). Nice suffers drawbacks, follow simple blocking interface: R session blocked calculations run, even though host session (essentially) nothing number workers (size cluster) fixed point parLapply called, restricted single node without considerable effort. One add workers cluster runs, remove unneeded ones tasks finish. possible retrieve partially completed results - wait tasks complete working tasks uneven size, load balancing form (parallel::parLapplyLB) quite slow hard build interfaces like queues work dependency graphs (though see heroic work future targets). Attempts run issues store data queue way can safely multiple worker processes interacting queue without corrupting database hitting race conditions. Approaches like liteq may work network file systems, therefore become limited single node. end scale, HPC systems schedulers can avoid issues, byzantine interfaces slow per-task submission. Notable features rrq motivate development within landscape: Uses Redis task broker; provides database hold tasks allows fast network based access many processes Uses non-blocking design control returned controller process immediately tasks run background Supports scalable worker pool; workers needed tasks queued, workers can added removed tasks running Allows multiple non-interacting queues, multiple priority levels within queue, automatically resolved dependencies among completing tasks Supports fully load-balanced design overheads around 1ms per task Supports optionally running task separate process, allowing strong isolation tasks well per-task timeouts, logging, allowing cancellation Allows rich querying task status progress worker history Exposes low-level primitives working individual tasks well higher level interfaces mimic functions like lapply","code":"lapply(x, fun) parallel::parLapply(cl, x, fun)"},{"path":"https://mrc-ide.github.io/rrq/articles/rrq.html","id":"running-tasks","dir":"Articles","previous_headings":"","what":"Running tasks","title":"rrq","text":"Running tasks little different many R-parallel backends, directly allocate tasks workers, simply place first--first-task queue. pool workers poll work queue. See vignette(\"design\") . Consider enqueing expression created task sleep 2 seconds return random number Initially task status RUNNING (PENDING briefly): couple seconds complete (pad complete even slow systems) basic task lifecycle : created/submitted task becomes PENDING picked worker becomes RUNNING completes become COMPLETE ERROR addition rarer ways task can end (CANCELLED, DIED, TIMEOUT) fail start due dependencies tasks (DEFERRED IMPOSSIBLE; see ). task terminal state (except IMPOSSIBLE, COMPLETE, ERROR, CANCELLED, DIED TIMEOUT) can retried, point status MOVED task “point” somewhere else (task move usual PENDING -> RUNNING -> (terminal state) flow). See vignette(\"fault-tolerance\") details. , slept seconds order task become finished. However, extremely common operation, rrq provides function rrq_task_wait() wait task finishes, returns logical indicating task succeeded , can fetch result rrq_task_result(). polling interval 1 second default, task completes within period still returned soon complete (interval just time progress bar updates period interrupt caught cancel wait).","code":"t <- rrq_task_create_expr({   Sys.sleep(2)   runif(1) }) rrq_task_status(t) #> [1] \"RUNNING\" Sys.sleep(3) rrq_task_result(t) #> [1] 0.8880451 t <- rrq_task_create_expr({   Sys.sleep(2)   runif(1) }) rrq_task_wait(t) #> [1] TRUE rrq_task_result(t) #> [1] 0.0711711"},{"path":"https://mrc-ide.github.io/rrq/articles/rrq.html","id":"configuring-the-worker-environment","dir":"Articles","previous_headings":"","what":"Configuring the worker environment","title":"rrq","text":"rare want workers run completely empty R environments (extra loaded packages, custom functions available). Quite often want run something configure workers accept tasks. order , first define function accept one argument environment worker use, set environment . common case, script files contain function definitions set packages load, rrq helper function rrq_envir(). , example, suppose want source file “myfuns.R” contains code might write: next step register function queue: default, notify running workers update environment. Note function errors way, workers exit! Now workers picked functions can start using : need control can write function. written create approach also allow something like read rds Rdata file containing large object want every worker copy .","code":"slowdouble <- function(x) {   Sys.sleep(x)   x * 2 } create <- rrq_envir(sources = \"myfuns.R\") rrq_worker_envir_set(create) rrq_worker_log_tail(n = 4) #>                    worker_id child       time  command message #> 1 nonspheric_siberiantiger_1    NA 1746804815  MESSAGE REFRESH #> 2 nonspheric_siberiantiger_2    NA 1746804815  MESSAGE REFRESH #> 3 nonspheric_siberiantiger_1    NA 1746804815    ENVIR     new #> 4 nonspheric_siberiantiger_2    NA 1746804815    ENVIR     new #> 5 nonspheric_siberiantiger_1    NA 1746804815    ENVIR  create #> 6 nonspheric_siberiantiger_2    NA 1746804815    ENVIR  create #> 7 nonspheric_siberiantiger_1    NA 1746804815 RESPONSE REFRESH #> 8 nonspheric_siberiantiger_2    NA 1746804815 RESPONSE REFRESH t <- rrq_task_create_expr(slowdouble(1)) rrq_task_wait(t) #> [1] TRUE create <- function(env) {   sys.source(\"myfuns.R\", env) }"},{"path":"https://mrc-ide.github.io/rrq/articles/rrq.html","id":"scheduling-options","dir":"Articles","previous_headings":"","what":"Scheduling options","title":"rrq","text":"rrq package aspire fully fledged scheduler, sometimes little control first--first-required. options available allow user control tasks run needed. involve: blocking tasks run tasks completed (e.g., set task followed series computational tasks, followed aggregation task) multiple queues different priorities, different workers subscribe (e.g., fast/slow high-priority/low-priority tasks, tasks require limited resource) put tasks front queue, allowing last--first-queue","code":""},{"path":"https://mrc-ide.github.io/rrq/articles/rrq.html","id":"tasks-that-depend-on-other-tasks","dir":"Articles","previous_headings":"Scheduling options","what":"Tasks that depend on other tasks","title":"rrq","text":"support simple system allowing tasks depend tasks. example might need download file, run series analyses . want run analysis set parameters, aggregate ’re done. output one task feeds others , practically require one following options: write results disk read back store results database (e.g., Redis!) end one task, read next connect queue task queueing task, can provide vector task identifiers depends_on argument. identifiers must known rrq task started prerequisites completed. task lifecycle look different ; rather starting PENDING task begins DEFERRED. prerequisites complete, task becomes possible moves DEFERRED PENDING. placed front queue. prerequisite task fails reason (error, cancelled, worker dies) task become IMPOSSIBLE. example, suppose code: function create want run first, setup, another function use want run read result running create analysis . Create rrq_controller object tell workers read deps.R file contains function definitions can enqueue first task: use id status first task PENDING, per usual: however, second task DEFERRED yet queue: first task processed worker, status changes: point second task proceed queue usual. Points note : deferred tasks access queued result blocking task (see ) deferred tasks added front queue become undeferred deferred tasks can’t queued blocking tasks returned id","code":"create <- function(n) {   saveRDS(runif(n), \"numbers.rds\") }  use <- function(i) {   d <- readRDS(\"numbers.rds\")   d[[i]] } obj <- rrq_controller(paste0(\"rrq:\", ids::random_id(bytes = 4))) rrq_default_controller_set(obj) rrq_worker_envir_set(rrq_envir(sources = \"deps.R\")) source(\"deps.R\") id <- rrq_task_create_expr(create(5)) id_use <- rrq_task_create_expr(use(2), depends_on = id) rrq_task_status(id) #> [1] \"PENDING\" rrq_task_status(id_use) #> [1] \"DEFERRED\" rrq_queue_list() #> [1] \"2df93fcd10bcd6bbf7fc0f01ff40022e\" rrq_task_status(id) #> [1] \"COMPLETE\" rrq_task_status(id_use) #> [1] \"PENDING\" rrq_queue_list() #> [1] \"9272663bc056619f89efebafaab6a97e\""},{"path":"https://mrc-ide.github.io/rrq/articles/rrq.html","id":"multiple-queues","dir":"Articles","previous_headings":"Scheduling options","what":"Multiple queues","title":"rrq","text":"Sometimes useful different workers listen different queues. example, may workers different machines different capabilities (e.g., machine GPU high memory). may tasks expected take quite long time want workers monitor fast queue short lived tasks. Every worker listens default queue, starting worker, can add additional queues control priority order queues worker. submitting tasks specify queue task sits . easiest way configure save worker configuration: , create two configurations: “short” just listens queue short, listens short long task queues (note workers also listen default queue). can submit long task worker: workers ability pick work, “short” worker still available: can submit tasks short queue processed Note validation check worker listening queue submit task. Indeed can’t new workers can added time (point submission perhaps workers).","code":"id <- paste0(\"rrq:\", ids::random_id(bytes = 4)) obj <- rrq_controller(id) rrq_default_controller_set(obj) rrq_worker_config_save(   \"short\",   rrq_worker_config(queue = \"short\")) rrq_worker_config_save(   \"all\",   rrq_worker_config(queue = c(\"short\", \"long\"))) rrq_worker_config_list() #> [1] \"short\"     \"localhost\" \"all\" w_short <- rrq_worker_spawn(name_config = \"short\") #> ℹ Spawning 1 worker with prefix 'compassionless_pachyderm' w_all <- rrq_worker_spawn(name_config = \"all\") #> ℹ Spawning 1 worker with prefix 'diamond_doe' id_long1 <- rrq_task_create_expr(Sys.sleep(3600), queue = \"long\") id_long2 <- rrq_task_create_expr(Sys.sleep(3600), queue = \"long\") rrq_worker_status() #> compassionless_pachyderm_1              diamond_doe_1  #>                     \"IDLE\"                     \"BUSY\" id <- rrq_task_create_expr(runif(1), queue = \"short\") rrq_task_wait(id, timeout = 10) #> [1] TRUE"},{"path":"https://mrc-ide.github.io/rrq/articles/rrq.html","id":"running-tasks-in-separate-processes","dir":"Articles","previous_headings":"","what":"Running tasks in separate processes","title":"rrq","text":"Running task separate process offers additional features cost little overhead per task. cost launch additional process every task run. use callr smooth number rough edges, impose minimum overhead 0.1s per task, plus cost loading packages task might need (use packages make heavy use things like S4 classes can easily extend seconds). additional features provides : Per-task isolation: every task runs separate process works fresh environment isolated tasks Cancellable tasks: can stop running task worker gracefully pick additional work Per-task timeout: can specify maximum running time task task exceeds , killed Per-task logs, via rrq_task_log() sorts tasks benefit sort approach typically long-running (expected running times 10s seconds ) overhead low, also features cancellation timeouts become useful. also seen used usefully task may leak memory, cache results aggressively - time cause worker process consume memory worker process killed operating system. use separate process, add separate_process = TRUE calls rrq_task_create_expr(). enable argument timeout effect, well rrq_task_cancel().","code":""},{"path":"https://mrc-ide.github.io/rrq/articles/rrq.html","id":"coping-with-memory-use","dir":"Articles","previous_headings":"","what":"Coping with memory use","title":"rrq","text":"data task, task result , saved Redis. alongside typically much smaller metadata required run rrq. Redis memory database, means things great idea; example sending 1000 tasks write back 100 MB simulation output try write 100 GB data Redis database may cause issues server! allow workflow, rrq supports configuring object store (rrq::object_store) objects certain size written elsewhere. Currently, “elsewhere” supported disk assumption controller workers share filesystem. approach used safe multiple concurrent processes, including network mounted filesystems. feature can enabled passing offload_path controller worker. Additionally, offload_threshold_size set worker configuration. setup , controller worker use offload path, running different machines may need use different paths pointing underlying network filesystem. ’s hard get 1KB data, can simulating big pile random numbers: task finished, data stored disk path given : keeps larger objects database.","code":"id <- paste0(\"rrq:\", ids::random_id(bytes = 4)) path <- tempfile() obj <- rrq_controller(id, offload_path = path)  rrq_default_controller_set(obj) rrq_worker_config_save(     \"localhost\",     rrq_worker_config(offload_threshold_size = 1000))  w <- rrq_worker_spawn(1, offload_path = path) #> ℹ Spawning 1 worker with prefix 'indistinct_indianspinyloach' t <- rrq_task_create_expr(runif(200000)) dir(path) #> [1] \"15bb4aaa4137c934e1c0b03b4ab3ad4b\""},{"path":"https://mrc-ide.github.io/rrq/articles/rrq.html","id":"orchestrating-workers","dir":"Articles","previous_headings":"","what":"Orchestrating workers","title":"rrq","text":"vignette uses basic rrq_worker_spawn() method create workers local machine. intended primarily development , though may useful situations. options available, depending want use rrq.","code":""},{"path":"https://mrc-ide.github.io/rrq/articles/rrq.html","id":"use-and-limitations-of-spawn","dir":"Articles","previous_headings":"Orchestrating workers","what":"Use (and limitations) of spawn","title":"rrq","text":"simplest way getting started rrq use rrq_worker_spawn(), . approach several nice features; uses callr, extra work required make worker R session behave like controller session (find environment variables, library, working directory), behaves way platforms (compare ). However, workers disappear controlling session completes (either good bad thing) limited single node.","code":""},{"path":"https://mrc-ide.github.io/rrq/articles/rrq.html","id":"start-workers-on-another-node-perhaps-using-a-scheduler","dir":"Articles","previous_headings":"Orchestrating workers","what":"Start workers on another node, perhaps using a scheduler","title":"rrq","text":"two issues ; one technical details launching rrq workers cluster, details around whether HPC admins like (security implications ). using rrq HPC system, want schedule workers onto system. details change basic approach write launcher script somewhere: can called command line: bash script can called whatever cluster job scheduler use. important things pass : id positional argument, queue id --config=NAME allows controlling named worker config (set via rrq_worker_config_save(), allowing changing timeout, verbosity queues) addition, may need change configuration type. need control redis access set REDIS_URL environment variable point Redis server.","code":"rrq_worker_script(dest) $ ./rrq_worker --help Usage:   rrq_worker [options] <id>  Options: --config=NAME    Name of a worker configuration [default: localhost] --name=NAME      Name of the worker (optional)"},{"path":"https://mrc-ide.github.io/rrq/articles/rrq.html","id":"use-docker","dir":"Articles","previous_headings":"Orchestrating workers","what":"Use docker","title":"rrq","text":"provide docker image can use (mrcide/rrq), though typically want extend image include packages. Alternatively create docker image (see main dockerfile replace COPY . /src installation rrq) image sets entrypoint call rrq_worker. use rrq orchestrate workers web applications number workers carry long running calculations HTTP API written using plumber porcelain.","code":""},{"path":"https://mrc-ide.github.io/rrq/articles/rrq.html","id":"waiting-for-workers-to-appear","dir":"Articles","previous_headings":"","what":"Waiting for workers to appear","title":"rrq","text":"submitted workers via task scheduler, might want block wait become available. can using rrq_worker_wait() function. first create vector names new workers, tell rrq ’re going produce workers. start workers ; might start command line (separate terminals). might queue jobs cluster scheduler Slurm PBS (appropriate care working directory). can immediately, R console write: session block wait workers appear, erroring appear time.","code":"obj <- rrq_controller(id) rrq_default_controller_set(obj) worker_ids <- c(\"cluster_1\", \"cluster_2\") rrq_worker --worker-id cluster_1 rrq:6f7c87c0 rrq_worker --worker-id cluster_2 rrq:6f7c87c0 rrq_worker_wait(worker_ids, controller = obj)"},{"path":"https://mrc-ide.github.io/rrq/articles/rrq.html","id":"worker-heartbeat","dir":"Articles","previous_headings":"","what":"Worker heartbeat","title":"rrq","text":"use many workers, particularly different machines, may notice disappear. Possible causes include: task crashes worker (e.g., run C++ code segfaults) worker killed operating system (e.g., system running low RAM process targeted --memory killer) machine reboots shuts redis server goes temporarily, causing worker exit writing back results default, happens worker running task, task status forever stuck RUNNING. rrq provides simple heartbeat process, requested, detect worker disappeared. , run second process worker periodically writes Redis database key expire time slightly longer period, effect making dead man’s switch - see rrq::rrq_heartbeat details. enable heartbeat, save worker configuration heartbeat_period set number seconds. use 2 seconds example runs reasonably quickly, practice something like 60 might slightly less load Redis server. , launch worker worker print information indicating heartbeat enabled (use rrq_worker_process_log()) also heartbeat key can inspect: queue slow job onto worker: kill worker: course, immediately key still exists: eventually expire: far rrq concerned, point task still running Handling situation still completely manual. can detect lost workers jobs : also “orphan” task tasks dependent task now marked IMPOSSIBLE. future version support automatic re-queuing jobs assigned disappeared workers.","code":"id <- paste0(\"rrq:\", ids::random_id(bytes = 4)) obj <- rrq_controller(id) rrq_default_controller_set(obj) rrq_worker_config_save(   \"localhost\",   rrq_worker_config(heartbeat_period = 2)) w <- rrq_worker_spawn(1) #> ℹ Spawning 1 worker with prefix 'ecological_snake' #> [2025-05-09 15:33:41.384314] HEARTBEAT rrq:01e14764:worker:ecological_snake_1:heartbeat #> [2025-05-09 15:33:41.630389] HEARTBEAT OK #> [2025-05-09 15:33:41.639345] ALIVE #> [2025-05-09 15:33:41.639699] ENVIR new #> [2025-05-09 15:33:41.640097] QUEUE default #>                                  __ #>                 ______________ _/ / #>       ______   / ___/ ___/ __ `/ /_____ #>      /_____/  / /  / /  / /_/ /_/_____/ #>  ______      /_/  /_/   \\__, (_)   ______ #> /_____/                   /_/     /_____/ #>     worker:        ecological_snake_1 #>     config:        localhost #>     rrq_version:   0.7.23 #>     platform:      x86_64-pc-linux-gnu #>     running:       Ubuntu 24.04.2 LTS #>     hostname:      fv-az1118-568 #>     username:      runner #>     queue:         rrq:01e14764:queue:default #>     wd:            /home/runner/work/rrq/rrq/vignettes #>     pid:           8958 #>     redis_host:    127.0.0.1 #>     redis_port:    6379 #>     heartbeat_key: rrq:01e14764:worker:ecological_snake_1:heartbeat #>     offload_path:  <not set> info <- rrq_worker_info()[[1]] obj$con$EXISTS(info$heartbeat_key) #> [1] 1 obj$con$PTTL(info$heartbeat_key) # in milliseconds #> [1] 5788 t <- rrq_task_create_expr({   Sys.sleep(10)   runif(1) }) tools::pskill(rrq_worker_info()[[1]]$pid) obj$con$EXISTS(info$heartbeat_key) #> [1] 1 Sys.sleep(6) obj$con$EXISTS(info$heartbeat_key) #> [1] 0 rrq_task_status(t) #> [1] \"RUNNING\" rrq_worker_detect_exited() #> Lost 1 worker: #>   - ecological_snake_1 #> Orphaning 1 task: #>   - 472696c5fc193c6b98376fd384e180cf rrq_task_status(t) #> [1] \"DIED\""},{"path":"https://mrc-ide.github.io/rrq/articles/rrq.html","id":"getting-a-redis-server","dir":"Articles","previous_headings":"","what":"Getting a Redis server","title":"rrq","text":"several options get started Redis, best one likely depend platform needs.","code":""},{"path":"https://mrc-ide.github.io/rrq/articles/rrq.html","id":"use-docker-1","dir":"Articles","previous_headings":"Getting a Redis server","what":"Use docker","title":"rrq","text":"(Linux, macOS docker desktop, Windows docker desktop) develop rrq ’s easy destroy recreate redis instance. Start docker redis container like: listen port 6379 Redis default. can stop container (deleting data) docker stop redis","code":"docker run --name redis --rm -d -p 127.0.0.1:6379:6379 redis"},{"path":"https://mrc-ide.github.io/rrq/articles/rrq.html","id":"install-redis","dir":"Articles","previous_headings":"Getting a Redis server","what":"Install Redis","title":"rrq","text":"Linux fairly straightforward, either downloading building source code installing via apt snap macOS source compile, can install redis server via homebrew Windows can install redis via WSL. also various ports.","code":""},{"path":"https://mrc-ide.github.io/rrq/articles/rrq.html","id":"use-redis-on-a-different-machine","dir":"Articles","previous_headings":"Getting a Redis server","what":"Use Redis on a different machine","title":"rrq","text":"redis running different machine (case ’re using redis distribute tasks number different machines) need tell rrq redux find . simplest way set environment variable REDIS_HOST name machine running default ports, set REDUX_URL need control. Alternatively, connecting server , can manually construct redux::hiredis object pass configuration option need; see documentation redux::redis_config details.","code":""},{"path":"https://mrc-ide.github.io/rrq/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Rich FitzJohn. Author, maintainer. Robert Ashton. Author. Imperial College Science, Technology Medicine. Copyright holder.","code":""},{"path":"https://mrc-ide.github.io/rrq/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"FitzJohn R, Ashton R (2025). rrq: Simple Redis Queue. R package version 0.7.23, https://mrc-ide.github.io/rrq.","code":"@Manual{,   title = {rrq: Simple Redis Queue},   author = {Rich FitzJohn and Robert Ashton},   year = {2025},   note = {R package version 0.7.23},   url = {https://mrc-ide.github.io/rrq}, }"},{"path":"https://mrc-ide.github.io/rrq/index.html","id":"rrq","dir":"","previous_headings":"","what":"Simple Redis Queue","title":"Simple Redis Queue","text":"Task queues R, implemented using Redis.","code":""},{"path":"https://mrc-ide.github.io/rrq/index.html","id":"getting-started","dir":"","previous_headings":"","what":"Getting started","title":"Simple Redis Queue","text":"Create rrq_controller object Submit work queue: Query task process: Run tasks workers background Wait tasks complete Retrieve results task Query workers done information, see vignette(\"rrq\")","code":"library(rrq) obj <- rrq_controller(\"rrq:readme\") rrq_default_controller_set(obj) t <- rrq_task_create_expr(runif(10)) t #> [1] \"fd08ef462c509e174338ca5920b13adf\" rrq_task_status(t) #> [1] \"PENDING\" rrq_worker_spawn() #> ℹ Spawning 1 worker with prefix 'nonmetalliferous_jabiru' #> <rrq_worker_manager> #>   Public: #>     clone: function (deep = FALSE) #>     id: nonmetalliferous_jabiru_1 #>     initialize: function (controller, n, logdir = NULL, name_config = \"localhost\", #>     is_alive: function (worker_id = NULL) #>     kill: function (worker_id = NULL) #>     logs: function (worker_id) #>     stop: function (worker_id = NULL, ...) #>     wait_alive: function (timeout, time_poll = 0.2, progress = NULL) #>   Private: #>     check_worker_id: function (worker_id) #>     controller: rrq_controller #>     logfile: /tmp/Rtmp4AMYNM/filee336a6e3e1369/nonmetalliferous_jabiru_1 #>     process: list #>     worker_id_base: nonmetalliferous_jabiru rrq_task_wait(t) #> [1] TRUE rrq_task_result(t) #>  [1] 0.044105073 0.151111529 0.047623996 0.936703515 0.719949653 0.519903127 #>  [7] 0.030698510 0.057218178 0.503331142 0.002863957 rrq_worker_log_tail(n = Inf) #>                   worker_id child       time       command #> 1 nonmetalliferous_jabiru_1    NA 1721033895         ALIVE #> 2 nonmetalliferous_jabiru_1    NA 1721033895         ENVIR #> 3 nonmetalliferous_jabiru_1    NA 1721033895         QUEUE #> 4 nonmetalliferous_jabiru_1    NA 1721033895    TASK_START #> 5 nonmetalliferous_jabiru_1    NA 1721033895 TASK_COMPLETE #>                            message #> 1 #> 2                              new #> 3                          default #> 4 fd08ef462c509e174338ca5920b13adf #> 5 fd08ef462c509e174338ca5920b13adf"},{"path":"https://mrc-ide.github.io/rrq/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Simple Redis Queue","text":"Install mrc-ide R universe package repository: Alternatively, install remotes:","code":"install.packages(   \"rrq\",   repos = c(\"https://mrc-ide.r-universe.dev\", \"https://cloud.r-project.org\")) remotes::install_github(\"mrc-ide/rrq\", upgrade = FALSE)"},{"path":"https://mrc-ide.github.io/rrq/index.html","id":"testing","dir":"","previous_headings":"","what":"Testing","title":"Simple Redis Queue","text":"test, need redis server can automatically connected using redux defaults. satisfied unauthenticated redis server running localhost, otherwise update environment variable REDIS_URL point redis server. use production server, package create delete lot keys. suitable redis server can started using docker (stopped ./scripts/redis stop) Alternatively, Windows, native (.e., depending CygWin, MSys, WSL) port Redis 5.0.14.1 can installed , run box.","code":"./scripts/redis start"},{"path":"https://mrc-ide.github.io/rrq/index.html","id":"testing-the-pkgdown-site-with-examples","dir":"","previous_headings":"","what":"Testing the pkgdown site with examples","title":"Simple Redis Queue","text":"documentation includes many executed code examples. preview documentation results , ’ll need Redis server running, rrq package installed. , R terminal:- run worker. another R terminal, pkgdown site built docs/ folder.","code":"rrq::rrq_worker$new(\"rrq:example\")$loop() pkgdown::build_site()"},{"path":"https://mrc-ide.github.io/rrq/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Simple Redis Queue","text":"MIT © Imperial College Science, Technology Medicine","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/compat.html","id":null,"dir":"Reference","previous_headings":"","what":"Compatibility functions — rrq_controller2","title":"Compatibility functions — rrq_controller2","text":"Compatibility functions","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/compat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compatibility functions — rrq_controller2","text":"","code":"rrq_controller2(...)  rrq_worker_config_save2(...)  rrq_worker_spawn2(...)  rrq_configure(...)"},{"path":"https://mrc-ide.github.io/rrq/reference/compat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compatibility functions — rrq_controller2","text":"... Arguments passed preferred function","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/heartbeat.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a heartbeat instance — rrq_heartbeat","title":"Create a heartbeat instance — rrq_heartbeat","text":"Create heartbeat instance Create heartbeat instance","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/heartbeat.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a heartbeat instance — rrq_heartbeat","text":"Create heartbeat instance.  can used running obj$start() reset TTL (Time Live) key every period seconds (set high).  R process dies, key expire 3 * period seconds (set expire) another application can tell R instance died.","code":""},{"path":[]},{"path":"https://mrc-ide.github.io/rrq/reference/heartbeat.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"Create a heartbeat instance — rrq_heartbeat","text":"rrq_heartbeat$new() rrq_heartbeat$is_running() rrq_heartbeat$start() rrq_heartbeat$stop() rrq_heartbeat$format()","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/heartbeat.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"Create a heartbeat instance — rrq_heartbeat","text":"Create heartbeat object","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/heartbeat.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a heartbeat instance — rrq_heartbeat","text":"","code":"rrq_heartbeat$new(   key,   period,   expire = 3 * period,   value = expire,   config = NULL,   start = TRUE,   timeout = 10 )"},{"path":"https://mrc-ide.github.io/rrq/reference/heartbeat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a heartbeat instance — rrq_heartbeat","text":"key Key use. heartbeat starts create key set expire expiry seconds. period Timeout period (seconds) expire Key expiry time (seconds) value Value store key.  default stores expiry time, time since last heartbeat can computed. converted character .character saving Redis config Configuration parameters passed redux::redis_config.  Provide either named list redis_config object.  allows host, port, password, db, etc set. start heartbeat started immediately? timeout Time, seconds, wait heartbeat appear.  generally appear quickly (within second unless connection slow) can generally left alone.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/heartbeat.html","id":"method-is-running-","dir":"Reference","previous_headings":"","what":"Method is_running()","title":"Create a heartbeat instance — rrq_heartbeat","text":"Report heartbeat process running. TRUE process started stopped.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/heartbeat.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a heartbeat instance — rrq_heartbeat","text":"","code":"rrq_heartbeat$is_running()"},{"path":"https://mrc-ide.github.io/rrq/reference/heartbeat.html","id":"method-start-","dir":"Reference","previous_headings":"","what":"Method start()","title":"Create a heartbeat instance — rrq_heartbeat","text":"Start heartbeat process. error thrown already running.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/heartbeat.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a heartbeat instance — rrq_heartbeat","text":"","code":"rrq_heartbeat$start()"},{"path":"https://mrc-ide.github.io/rrq/reference/heartbeat.html","id":"method-stop-","dir":"Reference","previous_headings":"","what":"Method stop()","title":"Create a heartbeat instance — rrq_heartbeat","text":"Stop heartbeat process","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/heartbeat.html","id":"usage-3","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a heartbeat instance — rrq_heartbeat","text":"","code":"rrq_heartbeat$stop(wait = TRUE)"},{"path":"https://mrc-ide.github.io/rrq/reference/heartbeat.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a heartbeat instance — rrq_heartbeat","text":"wait Logical, indicating wait heartbeat process terminates (take fraction second)","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/heartbeat.html","id":"method-format-","dir":"Reference","previous_headings":"","what":"Method format()","title":"Create a heartbeat instance — rrq_heartbeat","text":"Format method, used R6 nicely print object","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/heartbeat.html","id":"usage-4","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a heartbeat instance — rrq_heartbeat","text":"","code":"rrq_heartbeat$format(...)"},{"path":"https://mrc-ide.github.io/rrq/reference/heartbeat.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a heartbeat instance — rrq_heartbeat","text":"... Additional arguments, currently ignored","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/heartbeat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a heartbeat instance — rrq_heartbeat","text":"","code":"if (redux::redis_available()) {   rand_str <- function() {     paste(sample(letters, 20, TRUE), collapse = \"\")   }   key <- sprintf(\"rrq:heartbeat:%s\", rand_str())   h <- rrq::rrq_heartbeat$new(key, 1, expire = 2)   con <- redux::hiredis()    # The heartbeat key exists   con$EXISTS(key)    # And has an expiry of less than 2000ms   con$PTTL(key)    # We can manually stop the heartbeat, and 2s later the key will   # stop existing   h$stop()    Sys.sleep(2)   con$EXISTS(key) # 0    # This is required to close any processes opened by this   # example, normally you would not need this.   processx:::supervisor_kill() }"},{"path":"https://mrc-ide.github.io/rrq/reference/object_store.html","id":null,"dir":"Reference","previous_headings":"","what":"rrq object store — object_store","title":"rrq object store — object_store","text":"create task rrq task uses local variables need copied worker evaluate task. ,   objects b context rrq_task_create_expr called. considerations : names b useful immediate context controller point task sent need store values referenced b without reference names - naming new values value. , name becomes hash object, computed rlang::hash(), form content-addressable storage. note might end using value referenced b many times different tasks re-save data needed, necessarily delete task deleted unless nothing else uses value. objects might tiny large; small tend care quickly can resolved (.e., latency) large need careful overfull Redis' database memory-based system. make robust flexible, use object_store object, allow objects stored either directly Redis, offloaded onto \"large\" data store based size. Currently, provide support offloading disk, future hope expand . create value store (reference value already exists) assign tag database; means value hash abc123 tag def789 prefix:data[\"abc123\"] => [1] f5 26 a5 b7 26 93 b3 41 b7 d0 b0... (data stored, serialised redis hash hash, binary object. prefix:tag_hash:def789 => {abc123} (set hashes used tag) prefix:hash_tag:abc123 => {def789} (set tags reference hash) also used value hash abc123 tag fed987 look like prefix:data[abc123] => [1] f5 26 a5 b7 26 93 b3 41 b7 d0 b0... hash, binary object. prefix:tag_hash:def789 => {abc123} prefix:tag_hash:fed987 => {abc123} prefix:hash_tag:abc123 => {def789, fed987} tags dropped, references dropped set prefix:hash_tag:abc123 set becomes empty can delete prefix:data[abc123] simple form reference counting. rrq use task_ids tag. dealing large data, \"offload\" large data secondary store. replaces redis hash hash => value something else. Currently alternative offer object_store_offload_disk save binary representation object path <path>/<hash> allow large values shared controller worker long share common filesystem.","code":"rrq_task_create_expr(f(a, b))"},{"path":"https://mrc-ide.github.io/rrq/reference/object_store.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"rrq object store — object_store","text":"Create object store. Typically used end-users, used internally rrq_controller","code":""},{"path":[]},{"path":"https://mrc-ide.github.io/rrq/reference/object_store.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"rrq object store — object_store","text":"object_store$new() object_store$list() object_store$tags() object_store$get() object_store$mget() object_store$set() object_store$mset() object_store$location() object_store$drop() object_store$destroy()","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/object_store.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"rrq object store — object_store","text":"Create new object store (connect existing one)","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/object_store.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"rrq object store — object_store","text":"","code":"object_store$new(con, prefix, max_size = Inf, offload = NULL)"},{"path":"https://mrc-ide.github.io/rrq/reference/object_store.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"rrq object store — object_store","text":"con redis connection object prefix key prefix use; make number keys start prefix. max_size maximum serialised object size, bytes. serialised object larger size placed offload storage, provided offload argument. default Inf values stored redis database. offload offload storage object. provide one object_store_offload_disk, saves objects disk serialisation). interface subject change. given object exceeds max_size error thrown.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/object_store.html","id":"method-list-","dir":"Reference","previous_headings":"","what":"Method list()","title":"rrq object store — object_store","text":"List hashes data known data store","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/object_store.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"rrq object store — object_store","text":"","code":"object_store$list()"},{"path":"https://mrc-ide.github.io/rrq/reference/object_store.html","id":"method-tags-","dir":"Reference","previous_headings":"","what":"Method tags()","title":"rrq object store — object_store","text":"List tags known data store","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/object_store.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"rrq object store — object_store","text":"","code":"object_store$tags()"},{"path":"https://mrc-ide.github.io/rrq/reference/object_store.html","id":"method-get-","dir":"Reference","previous_headings":"","what":"Method get()","title":"rrq object store — object_store","text":"Get single object hash","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/object_store.html","id":"usage-3","dir":"Reference","previous_headings":"","what":"Usage","title":"rrq object store — object_store","text":"","code":"object_store$get(hash)"},{"path":"https://mrc-ide.github.io/rrq/reference/object_store.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"rrq object store — object_store","text":"hash single hash use","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/object_store.html","id":"method-mget-","dir":"Reference","previous_headings":"","what":"Method mget()","title":"rrq object store — object_store","text":"Get number objects hashes. Unlike $get() method accepts vector hash (length 0, 1, 1) returns list length.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/object_store.html","id":"usage-4","dir":"Reference","previous_headings":"","what":"Usage","title":"rrq object store — object_store","text":"","code":"object_store$mget(hash)"},{"path":"https://mrc-ide.github.io/rrq/reference/object_store.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"rrq object store — object_store","text":"hash vector object hashes","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/object_store.html","id":"method-set-","dir":"Reference","previous_headings":"","what":"Method set()","title":"rrq object store — object_store","text":"Set object object store, returning hash object.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/object_store.html","id":"usage-5","dir":"Reference","previous_headings":"","what":"Usage","title":"rrq object store — object_store","text":"","code":"object_store$set(value, tag, serialize = TRUE)"},{"path":"https://mrc-ide.github.io/rrq/reference/object_store.html","id":"arguments-3","dir":"Reference","previous_headings":"","what":"Arguments","title":"rrq object store — object_store","text":"value object save tag string used associate object. tags point particular object value removed, object deleted store. serialize Logical, indicating values serialised first. Typically TRUE, advanced use already serialised object can pass set FALSE. Note objects serialised redux::object_to_bin (serialize(..., xdr = FALSE)) accepted.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/object_store.html","id":"method-mset-","dir":"Reference","previous_headings":"","what":"Method mset()","title":"rrq object store — object_store","text":"Set number objects store. Unlike $set(), method sets list objects store , returns character vector hashes length list values.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/object_store.html","id":"usage-6","dir":"Reference","previous_headings":"","what":"Usage","title":"rrq object store — object_store","text":"","code":"object_store$mset(value, tag, serialize = TRUE)"},{"path":"https://mrc-ide.github.io/rrq/reference/object_store.html","id":"arguments-4","dir":"Reference","previous_headings":"","what":"Arguments","title":"rrq object store — object_store","text":"value list objects save tag string used associate object. tags point particular object value removed, object deleted store. tag used objects. serialize Logical, indicating values serialised first. Typically TRUE, advanced use already serialised object can pass set FALSE. Note objects serialised redux::object_to_bin (serialize(..., xdr = FALSE)) accepted.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/object_store.html","id":"method-location-","dir":"Reference","previous_headings":"","what":"Method location()","title":"rrq object store — object_store","text":"Return storage locations set hashes. Currently location may redis (stored directly redis server), offload (stored offload storage) NA (found, error = FALSE).","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/object_store.html","id":"usage-7","dir":"Reference","previous_headings":"","what":"Usage","title":"rrq object store — object_store","text":"","code":"object_store$location(hash, error = TRUE)"},{"path":"https://mrc-ide.github.io/rrq/reference/object_store.html","id":"arguments-5","dir":"Reference","previous_headings":"","what":"Arguments","title":"rrq object store — object_store","text":"hash vector hashes error logical, indicating throw error hash unknown","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/object_store.html","id":"method-drop-","dir":"Reference","previous_headings":"","what":"Method drop()","title":"rrq object store — object_store","text":"Delete tags store. dissociate tags hashes references means tag points hash data hash removed. return (invisibly) character vector dropped hashes.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/object_store.html","id":"usage-8","dir":"Reference","previous_headings":"","what":"Usage","title":"rrq object store — object_store","text":"","code":"object_store$drop(tag)"},{"path":"https://mrc-ide.github.io/rrq/reference/object_store.html","id":"arguments-6","dir":"Reference","previous_headings":"","what":"Arguments","title":"rrq object store — object_store","text":"tag Vector tags drop","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/object_store.html","id":"method-destroy-","dir":"Reference","previous_headings":"","what":"Method destroy()","title":"rrq object store — object_store","text":"Remove data store, stores metadata","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/object_store.html","id":"usage-9","dir":"Reference","previous_headings":"","what":"Usage","title":"rrq object store — object_store","text":"","code":"object_store$destroy()"},{"path":"https://mrc-ide.github.io/rrq/reference/object_store_offload_disk.html","id":null,"dir":"Reference","previous_headings":"","what":"Disk-based offload — object_store_offload_disk","title":"Disk-based offload — object_store_offload_disk","text":"Disk-based offload Disk-based offload","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/object_store_offload_disk.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Disk-based offload — object_store_offload_disk","text":"disk-based offload object_store. intended direct user-use.","code":""},{"path":[]},{"path":"https://mrc-ide.github.io/rrq/reference/object_store_offload_disk.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"Disk-based offload — object_store_offload_disk","text":"object_store_offload_disk$new() object_store_offload_disk$mset() object_store_offload_disk$mget() object_store_offload_disk$mdel() object_store_offload_disk$list() object_store_offload_disk$destroy()","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/object_store_offload_disk.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"Disk-based offload — object_store_offload_disk","text":"Create store","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/object_store_offload_disk.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Disk-based offload — object_store_offload_disk","text":"","code":"object_store_offload_disk$new(path)"},{"path":"https://mrc-ide.github.io/rrq/reference/object_store_offload_disk.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Disk-based offload — object_store_offload_disk","text":"path directory name store objects . created yet exist.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/object_store_offload_disk.html","id":"method-mset-","dir":"Reference","previous_headings":"","what":"Method mset()","title":"Disk-based offload — object_store_offload_disk","text":"Save number values disk","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/object_store_offload_disk.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"Disk-based offload — object_store_offload_disk","text":"","code":"object_store_offload_disk$mset(hash, value)"},{"path":"https://mrc-ide.github.io/rrq/reference/object_store_offload_disk.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"Disk-based offload — object_store_offload_disk","text":"hash character vector object hashes value list serialised objects (raw vector)","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/object_store_offload_disk.html","id":"method-mget-","dir":"Reference","previous_headings":"","what":"Method mget()","title":"Disk-based offload — object_store_offload_disk","text":"Retrieve number objects store","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/object_store_offload_disk.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"Disk-based offload — object_store_offload_disk","text":"","code":"object_store_offload_disk$mget(hash)"},{"path":"https://mrc-ide.github.io/rrq/reference/object_store_offload_disk.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"Disk-based offload — object_store_offload_disk","text":"hash character vector hashes objects return. objects deserialised return.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/object_store_offload_disk.html","id":"method-mdel-","dir":"Reference","previous_headings":"","what":"Method mdel()","title":"Disk-based offload — object_store_offload_disk","text":"Delete number objects store","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/object_store_offload_disk.html","id":"usage-3","dir":"Reference","previous_headings":"","what":"Usage","title":"Disk-based offload — object_store_offload_disk","text":"","code":"object_store_offload_disk$mdel(hash)"},{"path":"https://mrc-ide.github.io/rrq/reference/object_store_offload_disk.html","id":"arguments-3","dir":"Reference","previous_headings":"","what":"Arguments","title":"Disk-based offload — object_store_offload_disk","text":"hash character vector hashes remove","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/object_store_offload_disk.html","id":"method-list-","dir":"Reference","previous_headings":"","what":"Method list()","title":"Disk-based offload — object_store_offload_disk","text":"List hashes stored offload store","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/object_store_offload_disk.html","id":"usage-4","dir":"Reference","previous_headings":"","what":"Usage","title":"Disk-based offload — object_store_offload_disk","text":"","code":"object_store_offload_disk$list()"},{"path":"https://mrc-ide.github.io/rrq/reference/object_store_offload_disk.html","id":"method-destroy-","dir":"Reference","previous_headings":"","what":"Method destroy()","title":"Disk-based offload — object_store_offload_disk","text":"Completely delete store (deleting directory)","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/object_store_offload_disk.html","id":"usage-5","dir":"Reference","previous_headings":"","what":"Usage","title":"Disk-based offload — object_store_offload_disk","text":"","code":"object_store_offload_disk$destroy()"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_controller.html","id":null,"dir":"Reference","previous_headings":"","what":"Create rrq controller — rrq_controller","title":"Create rrq controller — rrq_controller","text":"Create new controller.  new interface replace rrq_controller soon, point rename back rrq_controller.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_controller.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create rrq controller — rrq_controller","text":"","code":"rrq_controller(   queue_id,   con = redux::hiredis(),   timeout_task_wait = NULL,   follow = NULL,   check_version = TRUE,   offload_path = NULL,   offload_threshold_size = Inf )"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_controller.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create rrq controller — rrq_controller","text":"queue_id identifier queue.  prefix keys redis, prefix might useful depending use case (e.g. rrq:<user>:<id>) con redis connection. default tries create redis connection using default ports, environment variables set redux::hiredis() timeout_task_wait optional default timeout use waiting tasks rrq_task_wait. given, fall back global option rrq.timeout_task_wait, set, wait forever (.e., timeout_task_wait = Inf). follow optional default logical use tasks may (may ) retried. given fall back global option rrq.follow, set TRUE (.e., follow). value follow = TRUE potentially slower follow = FALSE operations need dereference every task id. never use rrq_task_retry dereference never effect can skip . See vignette(\"fault-tolerance\") information. check_version Logical, indicating check schema version.  can pass FALSE continue even schema version incompatible, though subsequent actions may lead corruption. offload_path path create offload store (passed object_store_offload_disk). directory created exist. given (NULL) queue configured finite offload_threshold_size, trying save large objects throw error. offload_threshold_size maximum object size, bytes, moved offload store. given, larger data saved offload_path (using object_store_offload_disk)","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_controller.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create rrq controller — rrq_controller","text":"rrq_controller object, opaque.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_controller.html","id":"task-lifecycle","dir":"Reference","previous_headings":"","what":"Task lifecycle","title":"Create rrq controller — rrq_controller","text":"task queued $enqueue(), point becomes PENDING worker selects task run, becomes RUNNING task completes successfully without error becomes COMPLETE task throws error, becomes ERROR task cancelled (e.g., via $task_cancel()) becomes CANCELLED task killed external process, crashes worker dies (running heartbeat) task becomes DIED. status unknown task MISSING Tasks terminal state (except IMPOSSIBLE) may retried task_retry point become MOVED, see vignette(\"fault-tolerance\") details","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_controller.html","id":"worker-lifecycle","dir":"Reference","previous_headings":"","what":"Worker lifecycle","title":"Create rrq controller — rrq_controller","text":"worker appears IDLE running task BUSY receives PAUSE message becomes PAUSED receives RESUME message exits cleanly (e.g., via STOP message timeout) becomes EXITED crashes running heartbeat, becomes LOST","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_controller.html","id":"messages","dir":"Reference","previous_headings":"","what":"Messages","title":"Create rrq controller — rrq_controller","text":"time workers process tasks, can also send \"messages\". Messages take priority tasks, worker becomes idle (coming online finishing task) consume available messages starting new task, even available. message \"command\" may \"arguments\" command. supported messages : PING (args): \"ping\" worker, alive respond \"PONG\" ECHO (accepts argument string): Print string terminal log worker. respond OK message printed. EVAL (accepts string quoted expression): Evaluate arbitrary R expression worker. Responds value expression. STOP (accepts string print worker exits, defaults \"BYE\"): Tells worker stop. INFO (args): Returns information worker (versions packages, hostname, pid, etc). PAUSE (args): Tells worker stop accepting tasks (receives RESUME message). Messages processed normal. RESUME (args): Tells paused worker resume accepting tasks. REFRESH (args): Tells worker rebuild environment create method. TIMEOUT_SET (accepts number, representing seconds): Updates worker timeout - length time exit processed task. TIMEOUT_GET (args): Tells worker respond current timeout.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_controller.html","id":"storage","dir":"Reference","previous_headings":"","what":"Storage","title":"Create rrq controller — rrq_controller","text":"Every time task saved, task completed, results saved Redis database. Redis -memory database, great idea save large objects (ran 100 jobs parallel saved 2GB object likely take redis server). addition, redux support directly saving objects larger 2^31 - 1 bytes Redis. , use cases need consider store larger objects. strategy \"offload\" larger objects - bigger user-given size - onto storage system. Currently alternative supported disk store (object_store_offload_disk) hope expand later.  task returns 3GB object spill disk rather failing save Redis. storage directory offloading must shared amoung users queue. Depending usecase, directory local filesystems , using queue across machines, can network file system mounted machines. big object? serialise object (redux::object_to_bin just wraps serialize) creates vector bytes saved database. get idea large things can : length(redux::object_to_bin(your_object)).  time documentation written, mtcars 3807 bytes, million random numbers 8,000,031 bytes. unlikely offload_threshold_size less 1MB sensible.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_controller.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create rrq controller — rrq_controller","text":"","code":"if (FALSE) { # rrq:::enable_examples(require_queue = \"rrq:example\")  # Create a new controller; the id will be specific to your # application.  Here, we use 'rrq:example' obj <- rrq_controller(\"rrq:example\")  # Create a task for this controller to work on: t <- rrq_task_create_expr(runif(10), controller = obj)  # Wait for the task to complete rrq_task_wait(t, controller = obj)  # Fetch the task's result rrq_task_result(t, controller = obj) }"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_default_controller_set.html","id":null,"dir":"Reference","previous_headings":"","what":"Register default controller — rrq_default_controller_set","title":"Register default controller — rrq_default_controller_set","text":"Set clear default controller use rrq functions.  want use avoid passing controller named argument every function.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_default_controller_set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Register default controller — rrq_default_controller_set","text":"","code":"rrq_default_controller_set(controller)  rrq_default_controller_clear()"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_default_controller_set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Register default controller — rrq_default_controller_set","text":"controller rrq_controller object, NULL clear default controller (equivalent using rrq_default_controller_clear)","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_default_controller_set.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Register default controller — rrq_default_controller_set","text":"Invisibly, previously set default controller (NULL none set)","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_deferred_list.html","id":null,"dir":"Reference","previous_headings":"","what":"List deferred tasks — rrq_deferred_list","title":"List deferred tasks — rrq_deferred_list","text":"Return deferred tasks waiting . Note arbitrary order, tasks added queue dependencies satisfied.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_deferred_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"List deferred tasks — rrq_deferred_list","text":"","code":"rrq_deferred_list(controller = NULL)"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_deferred_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"List deferred tasks — rrq_deferred_list","text":"controller controller use.  given (NULL) use controller registered rrq_default_controller_set().","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_destroy.html","id":null,"dir":"Reference","previous_headings":"","what":"Destroy queue — rrq_destroy","title":"Destroy queue — rrq_destroy","text":"Entirely destroy queue, deleting keys associated Redis database. destructive action undone.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_destroy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Destroy queue — rrq_destroy","text":"","code":"rrq_destroy(   delete = TRUE,   worker_stop_type = \"message\",   timeout_worker_stop = 0,   controller = NULL )"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_destroy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Destroy queue — rrq_destroy","text":"delete Either TRUE (default) indicating keys immediately deleted. Alternatively, provide integer value keys instead marked future deletion \"expiring\" many seconds, using Redis' EXPIRE command. worker_stop_type Passed rrq_worker_stop(); Can one \"message\", \"kill\" \"kill_local\". \"kill\" method requires workers using heartbeat, \"kill_local\" requires workers machine controller. However, may faster stop workers \"message\", wait task finished. timeout_worker_stop timeout pass worker respond request stop. See worker_stop's timeout argument details. controller controller destroy","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_envir.html","id":null,"dir":"Reference","previous_headings":"","what":"Create simple worker environments — rrq_envir","title":"Create simple worker environments — rrq_envir","text":"Helper function creating worker environment. function exists create function suitable passing rrq_worker_envir_set common case worker source R scripts /load packages startup. convenience wrapper around defining function, covering simple case. need flexibility write function.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_envir.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create simple worker environments — rrq_envir","text":"","code":"rrq_envir(packages = NULL, sources = NULL)"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_envir.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create simple worker environments — rrq_envir","text":"packages optional character vector sources optional character vector scripts read. Typically contain just function definitions might read large data objects .","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_envir.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create simple worker environments — rrq_envir","text":"function suitable passing rrq_worker_envir_set, can set (update) environment workers.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_heartbeat_kill.html","id":null,"dir":"Reference","previous_headings":"","what":"Kill a process running a heartbeat — rrq_heartbeat_kill","title":"Kill a process running a heartbeat — rrq_heartbeat_kill","text":"Send kill signal (typically SIGTERM) terminate process running heartbeat. used rrq_controller order tear workers, even processing task. heartbeat process created, main loop listen requests kill via function forward worker. primarily useful workers different physical machine controller tools::pskill() used.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_heartbeat_kill.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Kill a process running a heartbeat — rrq_heartbeat_kill","text":"","code":"rrq_heartbeat_kill(con, key, signal = tools::SIGTERM)"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_heartbeat_kill.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Kill a process running a heartbeat — rrq_heartbeat_kill","text":"con hiredis object key heartbeat key signal signal send (typically tools::SIGTERM \"polite\" shutdown)","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_heartbeat_kill.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Kill a process running a heartbeat — rrq_heartbeat_kill","text":"","code":"if (redux::redis_available()) {   rand_str <- function() {     paste(sample(letters, 20, TRUE), collapse = \"\")   }   # Suppose we have a process that exposes a heartbeat running on   # this key:   key <- sprintf(\"rrq:heartbeat:%s\", rand_str())    # We can send it a SIGTERM signal over redis using:   con <- redux::hiredis()   rrq::rrq_heartbeat_kill(con, key, tools::SIGTERM) }"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_message_get_response.html","id":null,"dir":"Reference","previous_headings":"","what":"Get message response — rrq_message_get_response","title":"Get message response — rrq_message_get_response","text":"Get response messages, waiting message responded .","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_message_get_response.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get message response — rrq_message_get_response","text":"","code":"rrq_message_get_response(   message_id,   worker_ids = NULL,   named = TRUE,   delete = FALSE,   timeout = 0,   time_poll = 0.5,   progress = NULL,   controller = NULL )"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_message_get_response.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get message response — rrq_message_get_response","text":"message_id message id worker_ids Optional vector worker ids. NULL active workers used (note may differ set workers message sent !) named Logical, indicating return value named worker id. delete Logical, indicating messages deleted retrieval timeout Integer, representing seconds wait response received. error thrown response received time. time_poll timeout greater zero, polling interval used redis calls.  Increasing reduces network load increases time may waited . progress Optional logical indicating progress bar displayed. NULL fall back value global option rrq.progress, unset display progress bar interactive session. controller controller use.  given (NULL) use controller registered rrq_default_controller_set().","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_message_get_response.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get message response — rrq_message_get_response","text":"","code":"if (FALSE) { # rrq:::enable_examples(require_queue = \"rrq:example\") obj <- rrq_controller(\"rrq:example\") id <- rrq_message_send(\"PING\", controller = obj) rrq_message_get_response(id, timeout = 5, controller = obj) }"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_message_has_response.html","id":null,"dir":"Reference","previous_headings":"","what":"Detect if message has response — rrq_message_has_response","title":"Detect if message has response — rrq_message_has_response","text":"Detect response available message","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_message_has_response.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detect if message has response — rrq_message_has_response","text":"","code":"rrq_message_has_response(   message_id,   worker_ids = NULL,   named = TRUE,   controller = NULL )"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_message_has_response.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Detect if message has response — rrq_message_has_response","text":"message_id message id worker_ids Optional vector worker ids. NULL active workers used (note may differ set workers message sent !) named Logical, indicating return vector named controller controller use.  given (NULL) use controller registered rrq_default_controller_set().","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_message_has_response.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Detect if message has response — rrq_message_has_response","text":"logical vector, possibly named (depending named argument)","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_message_has_response.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Detect if message has response — rrq_message_has_response","text":"","code":"if (FALSE) { # rrq:::enable_examples(require_queue = \"rrq:example\") obj <- rrq_controller(\"rrq:example\")  id <- rrq_message_send(\"PING\", controller = obj) rrq_message_has_response(id, controller = obj) rrq_message_get_response(id, timeout = 5, controller = obj) rrq_message_has_response(id, controller = obj) }"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_message_response_ids.html","id":null,"dir":"Reference","previous_headings":"","what":"Return ids for messages with responses for a particular worker. — rrq_message_response_ids","title":"Return ids for messages with responses for a particular worker. — rrq_message_response_ids","text":"Return ids messages responses particular worker.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_message_response_ids.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Return ids for messages with responses for a particular worker. — rrq_message_response_ids","text":"","code":"rrq_message_response_ids(worker_id, controller = NULL)"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_message_response_ids.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Return ids for messages with responses for a particular worker. — rrq_message_response_ids","text":"worker_id worker id controller controller use.  given (NULL) use controller registered rrq_default_controller_set().","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_message_response_ids.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Return ids for messages with responses for a particular worker. — rrq_message_response_ids","text":"character vector ids","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_message_response_ids.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Return ids for messages with responses for a particular worker. — rrq_message_response_ids","text":"","code":"if (FALSE) { # rrq:::enable_examples(require_queue = \"rrq:example\") obj <- rrq_controller(\"rrq:example\") w <- rrq_worker_list(controller = obj) rrq_message_send(\"PING\", controller = obj) }"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_message_send.html","id":null,"dir":"Reference","previous_headings":"","what":"Send message to workers — rrq_message_send","title":"Send message to workers — rrq_message_send","text":"Send message workers. Sending message returns message id, can used poll response rrq_message_* functions.  See vignette(\"messages\") details messaging interface.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_message_send.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Send message to workers — rrq_message_send","text":"","code":"rrq_message_send(command, args = NULL, worker_ids = NULL, controller = NULL)"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_message_send.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Send message to workers — rrq_message_send","text":"command command, PING, PAUSE; see Messages section Details al messages. args Arguments command, supported worker_ids Optional vector worker ids send message . NULL message sent active workers. controller controller use.  given (NULL) use controller registered rrq_default_controller_set().","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_message_send.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Send message to workers — rrq_message_send","text":"Invisibly, single identifier","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_message_send.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Send message to workers — rrq_message_send","text":"","code":"if (FALSE) { # rrq:::enable_examples(require_queue = \"rrq:example\") obj <- rrq_controller(\"rrq:example\")  id <- rrq_message_send(\"PING\", controller = obj) rrq_message_get_response(id, timeout = 5, controller = obj) }"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_message_send_and_wait.html","id":null,"dir":"Reference","previous_headings":"","what":"Send a message and wait for response — rrq_message_send_and_wait","title":"Send a message and wait for response — rrq_message_send_and_wait","text":"Send message wait responses.  helper function around rrq_message_send() rrq_message_get_response().","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_message_send_and_wait.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Send a message and wait for response — rrq_message_send_and_wait","text":"","code":"rrq_message_send_and_wait(   command,   args = NULL,   worker_ids = NULL,   named = TRUE,   delete = TRUE,   timeout = 600,   time_poll = 0.05,   progress = NULL,   controller = NULL )"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_message_send_and_wait.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Send a message and wait for response — rrq_message_send_and_wait","text":"command command, PING, PAUSE; see Messages section Details al messages. args Arguments command, supported worker_ids Optional vector worker ids send message . NULL message sent active workers. named Logical, indicating return value named worker id. delete Logical, indicating messages deleted retrieval timeout Integer, representing seconds wait response received. error thrown response received time. time_poll timeout greater zero, polling interval used redis calls.  Increasing reduces network load increases time may waited . progress Optional logical indicating progress bar displayed. NULL fall back value global option rrq.progress, unset display progress bar interactive session. controller controller use.  given (NULL) use controller registered rrq_default_controller_set().","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_message_send_and_wait.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Send a message and wait for response — rrq_message_send_and_wait","text":"message response","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_message_send_and_wait.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Send a message and wait for response — rrq_message_send_and_wait","text":"","code":"if (FALSE) { # rrq:::enable_examples(require_queue = \"rrq:example\") obj <- rrq_controller(\"rrq:example\") rrq_message_send_and_wait(\"PING\", controller = obj) }"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_queue_length.html","id":null,"dir":"Reference","previous_headings":"","what":"Queue length — rrq_queue_length","title":"Queue length — rrq_queue_length","text":"Returns length queue (number tasks waiting run).  length value returned rrq_queue_list.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_queue_length.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Queue length — rrq_queue_length","text":"","code":"rrq_queue_length(queue = NULL, controller = NULL)"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_queue_length.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Queue length — rrq_queue_length","text":"queue name queue query (defaults \"default\" queue). controller controller use.  given (NULL) use controller registered rrq_default_controller_set().","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_queue_length.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Queue length — rrq_queue_length","text":"number","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_queue_list.html","id":null,"dir":"Reference","previous_headings":"","what":"List queue contents — rrq_queue_list","title":"List queue contents — rrq_queue_list","text":"Returns keys task queue.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_queue_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"List queue contents — rrq_queue_list","text":"","code":"rrq_queue_list(queue = NULL, controller = NULL)"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_queue_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"List queue contents — rrq_queue_list","text":"queue name queue query (defaults \"default\" queue). controller controller use.  given (NULL) use controller registered rrq_default_controller_set().","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_queue_remove.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove task ids from a queue — rrq_queue_remove","title":"Remove task ids from a queue — rrq_queue_remove","text":"Remove task ids queue.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_queue_remove.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove task ids from a queue — rrq_queue_remove","text":"","code":"rrq_queue_remove(task_ids, queue = NULL, controller = NULL)"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_queue_remove.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove task ids from a queue — rrq_queue_remove","text":"task_ids Task ids remove queue name queue query (defaults \"default\" queue). controller controller use.  given (NULL) use controller registered rrq_default_controller_set().","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_cancel.html","id":null,"dir":"Reference","previous_headings":"","what":"Cancel a task — rrq_task_cancel","title":"Cancel a task — rrq_task_cancel","text":"Cancel single task. task PENDING unqueued status set CANCELED.  RUNNING task stopped set run separate process (.e., queued separate_process = TRUE).  Dependent tasks marked impossible.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_cancel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cancel a task — rrq_task_cancel","text":"","code":"rrq_task_cancel(task_id, wait = TRUE, timeout_wait = 10, controller = NULL)"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_cancel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cancel a task — rrq_task_cancel","text":"task_id Id task cancel wait Wait task stopped, running. timeout_wait Maximum time, seconds, wait task cancelled worker. controller controller use.  given (NULL) use controller registered rrq_default_controller_set().","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_cancel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cancel a task — rrq_task_cancel","text":"Nothing successfully cancelled, otherwise throws error task_id status e.g. Task 123 running (MISSING)","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_cancel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cancel a task — rrq_task_cancel","text":"","code":"if (FALSE) { # rrq:::enable_examples(require_queue = \"rrq:example\") obj <- rrq_controller(\"rrq:example\")  t <- rrq_task_create_expr(Sys.sleep(4), separate_process = TRUE,                           controller = obj) Sys.sleep(0.5) rrq_task_cancel(t, controller = obj) rrq_task_status(t, controller = obj) }"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_create_bulk_call.html","id":null,"dir":"Reference","previous_headings":"","what":"Create bulk tasks from a call — rrq_task_create_bulk_call","title":"Create bulk tasks from a call — rrq_task_create_bulk_call","text":"Create bulk set tasks based applying function vector data.frame.  bulk equivalent rrq_task_create_call, way rrq_task_create_bulk_expr bulk version rrq_task_create_expr.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_create_bulk_call.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create bulk tasks from a call — rrq_task_create_bulk_call","text":"","code":"rrq_task_create_bulk_call(   fn,   data,   args = NULL,   queue = NULL,   separate_process = FALSE,   timeout_task_run = NULL,   depends_on = NULL,   controller = NULL )"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_create_bulk_call.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create bulk tasks from a call — rrq_task_create_bulk_call","text":"fn function call data data apply function .  can vector list, case act like lapply apply fn element turn.  Alternatively, can data.frame, case row taken set arguments fn.  Note data data.frame arguments fn named. args Additional arguments fn, shared across calls. must named.  using data.frame data, probably better adding additional columns vary across rows, end result . queue queue add task ; specified \"default\" queue (workers listen ) used. configured workers listen one queue can specify . warned push jobs onto queue worker, queue forever. separate_process Logical, indicating task run separate process worker. TRUE, worker runs task separate process using callr package. means worker environment completely clean, subsequent runs affected preceding ones.  downside approach considerable overhead starting external process transferring data back. timeout_task_run Optionally, maximum allowed running time, seconds. parameter effect separate_process TRUE. given, task takes longer time stopped task status set TIMEOUT. depends_on Vector list IDs tasks must completed job can run. dependent tasks successfully run, task get added queue. dependent task fails task removed queue. controller controller use.  given (NULL) use controller registered rrq_default_controller_set().","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_create_bulk_call.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create bulk tasks from a call — rrq_task_create_bulk_call","text":"vector task identifiers; length data rows data.frame, otherwise length data","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_create_bulk_call.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create bulk tasks from a call — rrq_task_create_bulk_call","text":"","code":"if (FALSE) { # rrq:::enable_examples(require_queue = \"rrq:example\") obj <- rrq_controller(\"rrq:example\")  d <- data.frame(n = 1:10, lambda = rgamma(10, 5)) ts <- rrq_task_create_bulk_call(rpois, d, controller = obj) rrq_task_wait(ts, controller = obj) rrq_task_results(ts, controller = obj) }"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_create_bulk_expr.html","id":null,"dir":"Reference","previous_headings":"","what":"Create bulk tasks from an expression — rrq_task_create_bulk_expr","title":"Create bulk tasks from an expression — rrq_task_create_bulk_expr","text":"Create bulk set tasks. Variables data take precedence variables environment expr created. \"pronoun\" support yet (see rlang docs).  Use !! pull variable environment need , careful inject something really large (e.g., vector really) end revolting expression poor backtraces.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_create_bulk_expr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create bulk tasks from an expression — rrq_task_create_bulk_expr","text":"","code":"rrq_task_create_bulk_expr(   expr,   data,   queue = NULL,   separate_process = FALSE,   timeout_task_run = NULL,   depends_on = NULL,   controller = NULL )"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_create_bulk_expr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create bulk tasks from an expression — rrq_task_create_bulk_expr","text":"expr expression, rrq_task_create_expr data Data wish inject row-wise expression queue queue add task ; specified \"default\" queue (workers listen ) used. configured workers listen one queue can specify . warned push jobs onto queue worker, queue forever. separate_process Logical, indicating task run separate process worker. TRUE, worker runs task separate process using callr package. means worker environment completely clean, subsequent runs affected preceding ones.  downside approach considerable overhead starting external process transferring data back. timeout_task_run Optionally, maximum allowed running time, seconds. parameter effect separate_process TRUE. given, task takes longer time stopped task status set TIMEOUT. depends_on Vector list IDs tasks must completed job can run. dependent tasks successfully run, task get added queue. dependent task fails task removed queue. controller controller use.  given (NULL) use controller registered rrq_default_controller_set().","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_create_bulk_expr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create bulk tasks from an expression — rrq_task_create_bulk_expr","text":"character vector task identifiers; length equal number row data","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_create_bulk_expr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create bulk tasks from an expression — rrq_task_create_bulk_expr","text":"","code":"if (FALSE) { # rrq:::enable_examples(require_queue = \"rrq:example\") obj <- rrq_controller(\"rrq:example\")  # Create 10 tasks: ts <- rrq_task_create_bulk_expr(sqrt(x), data.frame(x = 1:10),                                 controller = obj) rrq_task_wait(ts, controller = obj) rrq_task_results(ts, controller = obj)  # Note that there is no automatic simplification when fetching # results, you might use unlist or vapply to turn this into a # numeric vector rather than a list  # The data.frame substituted in may have multiple columns # representing multiple variables to substitute into the # expression d <- expand.grid(a = 1:4, b = 1:4) ts <- rrq_task_create_bulk_expr(a * b, d, controller = obj) rrq_task_wait(ts, controller = obj) rrq_task_results(ts, controller = obj) }"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_create_call.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a task from a call — rrq_task_create_call","title":"Create a task from a call — rrq_task_create_call","text":"Create task based function call.  fairly similar callr::r, forms basis lapply()-like task submission.  Sending call may slightly different semantics expect send closure (function binds data), may change behaviour find happy set compromises.  See Details .  expression rrq_task_create_call(f, list(, b, c)) similar rrq_task_create_expr(f(, b, c)), use whichever prefer.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_create_call.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a task from a call — rrq_task_create_call","text":"","code":"rrq_task_create_call(   fn,   args,   queue = NULL,   separate_process = FALSE,   timeout_task_run = NULL,   depends_on = NULL,   controller = NULL )"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_create_call.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a task from a call — rrq_task_create_call","text":"fn function call args list arguments pass function queue queue add task ; specified \"default\" queue (workers listen ) used. configured workers listen one queue can specify . warned push jobs onto queue worker, queue forever. separate_process Logical, indicating task run separate process worker. TRUE, worker runs task separate process using callr package. means worker environment completely clean, subsequent runs affected preceding ones.  downside approach considerable overhead starting external process transferring data back. timeout_task_run Optionally, maximum allowed running time, seconds. parameter effect separate_process TRUE. given, task takes longer time stopped task status set TIMEOUT. depends_on Vector list IDs tasks must completed job can run. dependent tasks successfully run, task get added queue. dependent task fails task removed queue. controller controller use.  given (NULL) use controller registered rrq_default_controller_set().","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_create_call.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a task from a call — rrq_task_create_call","text":"task identifier (32 character hex string) can pass rrq functions, notably rrq_task_status() rrq_task_result()","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_create_call.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a task from a call — rrq_task_create_call","text":"Things pretty unambiguous pass function package, especially refer package namespace (e.g. pkg::fn). pass name without namespace package loaded library() locally loaded library within worker environment, may right thing may see task fail, find different function name. pass anonymous function (e.g., function(x) x + 1) may may right thing respect environment capture.  never capture global environment function closure tries bind symbol global environment work.  Like callr::r, anonymous functions easiest think fully self contained (.e., inputs functions come args). bound local environment, may slightly better, semantics undefined subject change. R fancy things function calls try replicate.  particular may noticed works:   can end situation locally :   R looks symbol call skips non-function objects.  reconstruct environment chains exactly way locally possible.","code":"c <- \"x\" c(c, c) # a vector of two \"x\"'s f <- function(x) x + 1 local({   f <- 1   f(f) # 2 })"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_create_call.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a task from a call — rrq_task_create_call","text":"","code":"if (FALSE) { # rrq:::enable_examples(require_queue = \"rrq:example\") obj <- rrq_controller(\"rrq:example\") t <- rrq_task_create_call(sqrt, list(2), controller = obj) rrq_task_wait(t, controller = obj) rrq_task_result(t, controller = obj) }"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_create_expr.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a task based on an expression — rrq_task_create_expr","title":"Create a task based on an expression — rrq_task_create_expr","text":"Create task based expression.  expression passed expr typically function call (e.g., f(x)).  analyse expression find variables reference (case f(x) x) combine function name run worker.  x found calling environment error.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_create_expr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a task based on an expression — rrq_task_create_expr","text":"","code":"rrq_task_create_expr(   expr,   queue = NULL,   separate_process = FALSE,   timeout_task_run = NULL,   depends_on = NULL,   controller = NULL )"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_create_expr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a task based on an expression — rrq_task_create_expr","text":"expr expression, need quoting. See Details. queue queue add task ; specified \"default\" queue (workers listen ) used. configured workers listen one queue can specify . warned push jobs onto queue worker, queue forever. separate_process Logical, indicating task run separate process worker. TRUE, worker runs task separate process using callr package. means worker environment completely clean, subsequent runs affected preceding ones.  downside approach considerable overhead starting external process transferring data back. timeout_task_run Optionally, maximum allowed running time, seconds. parameter effect separate_process TRUE. given, task takes longer time stopped task status set TIMEOUT. depends_on Vector list IDs tasks must completed job can run. dependent tasks successfully run, task get added queue. dependent task fails task removed queue. controller controller use.  given (NULL) use controller registered rrq_default_controller_set().","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_create_expr.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a task based on an expression — rrq_task_create_expr","text":"Alternatively may provide multiline statement using {} surround multiple lines, :   case, apply simple heuristic work x locally assigned saved expression.","code":"task_create_expr({   x <- runif(1)   f(x) }, ...)"},{"path":[]},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_create_expr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a task based on an expression — rrq_task_create_expr","text":"","code":"if (FALSE) { # rrq:::enable_examples(require_queue = \"rrq:example\") obj <- rrq_controller(\"rrq:example\")  # Simple use of the function to create a task based on a function call t <- rrq_task_create_expr(sqrt(2), controller = obj) rrq_task_wait(t, controller = obj) rrq_task_result(t, controller = obj)  # The expression can contain calls to other variables, and these # will be included in the call: a <- 3 t <- rrq_task_create_expr(sqrt(a), controller = obj) rrq_task_wait(t, controller = obj) rrq_task_result(t, controller = obj)  # You can pass in an expression _as_ a symbol too: expr <- quote(sqrt(4)) t <- rrq_task_create_expr(expr, controller = obj) rrq_task_wait(t, controller = obj) rrq_task_result(t, controller = obj)  # If you queue tasks into separate processes you can use a timeout # to kill the task if it takes too long: t <- rrq_task_create_expr(Sys.sleep(3),                           separate_process = TRUE,                           timeout_task_run = 1,                           controller = obj) rrq_task_wait(t, controller = obj) rrq_task_result(t, controller = obj) }"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Fetch internal task data — rrq_task_data","title":"Fetch internal task data — rrq_task_data","text":"Fetch internal data task (expert use )","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fetch internal task data — rrq_task_data","text":"","code":"rrq_task_data(task_id, controller = NULL)"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fetch internal task data — rrq_task_data","text":"task_id single task identifier controller controller use.  given (NULL) use controller registered rrq_default_controller_set().","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fetch internal task data — rrq_task_data","text":"Internal data, structures subject change","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fetch internal task data — rrq_task_data","text":"","code":"obj <- rrq_controller(\"rrq:example\")  t <- rrq_task_create_expr(runif(1), controller = obj) rrq_task_data(t, controller = obj) #> $type #> [1] \"expr\" #>  #> $expr #> runif(1) #>  #> $variables #> NULL #>   x <- 10 y <- 20 t <- rrq_task_create_expr(x + y, controller = obj) rrq_task_data(t, controller = obj) #> $type #> [1] \"expr\" #>  #> $expr #> x + y #>  #> $variables #> $variables$x #> [1] 10 #>  #> $variables$y #> [1] 20 #>  #>"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_delete.html","id":null,"dir":"Reference","previous_headings":"","what":"Delete tasks — rrq_task_delete","title":"Delete tasks — rrq_task_delete","text":"Delete one tasks","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_delete.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Delete tasks — rrq_task_delete","text":"","code":"rrq_task_delete(task_ids, check = TRUE, controller = NULL)"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_delete.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Delete tasks — rrq_task_delete","text":"task_ids Vector task ids delete check Logical indicating check tasks running. Deleting running tasks unlikely result desirable behaviour. controller controller use.  given (NULL) use controller registered rrq_default_controller_set().","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_delete.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Delete tasks — rrq_task_delete","text":"Nothing, called side effects ","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_delete.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Delete tasks — rrq_task_delete","text":"","code":"obj <- rrq_controller(\"rrq:example:delete\")  ts <- rrq_task_create_bulk_call(sqrt, 1:10, controller = obj) rrq_task_exists(ts, controller = obj) #>  [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE  rrq_task_delete(ts[1:5], controller = obj) rrq_task_exists(ts, controller = obj) #>  [1] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  rrq_task_delete(ts, controller = obj) rrq_task_exists(ts, controller = obj) #>  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_exists.html","id":null,"dir":"Reference","previous_headings":"","what":"Test if tasks exist — rrq_task_exists","title":"Test if tasks exist — rrq_task_exists","text":"Test task ids exist (.e., known controller). Nonexistent tasks may deleted, known different controller just never existed.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_exists.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test if tasks exist — rrq_task_exists","text":"","code":"rrq_task_exists(task_ids, named = FALSE, controller = NULL)"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_exists.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test if tasks exist — rrq_task_exists","text":"task_ids Vector task ids check named Logical, indicating return value named task ids; quite long can make value little awkward work . controller controller use.  given (NULL) use controller registered rrq_default_controller_set().","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_exists.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test if tasks exist — rrq_task_exists","text":"logical vector length task_ids; TRUE task exists, FALSE otherwise.  named TRUE, vector named task_ids.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_exists.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test if tasks exist — rrq_task_exists","text":"","code":"obj <- rrq_controller(\"rrq:example\")  t1 <- rrq_task_create_expr(runif(1), controller = obj) rrq_task_exists(t1, controller = obj) #> [1] TRUE  t2 <- ids::random_id() rrq_task_exists(t2, controller = obj) #> [1] FALSE"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_info.html","id":null,"dir":"Reference","previous_headings":"","what":"Fetch task information — rrq_task_info","title":"Fetch task information — rrq_task_info","text":"Fetch information task. currently includes information task () running information retry chain, expand future. format output subject change (probably get nice print method) values present output included future update.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_info.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fetch task information — rrq_task_info","text":"","code":"rrq_task_info(task_id, controller = NULL)"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_info.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fetch task information — rrq_task_info","text":"task_id single task identifier controller controller use.  given (NULL) use controller registered rrq_default_controller_set().","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_info.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fetch task information — rrq_task_info","text":"list, format currently subject change","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_info.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fetch task information — rrq_task_info","text":"","code":"if (FALSE) { # rrq:::enable_examples(require_queue = \"rrq:example\") obj <- rrq_controller(\"rrq:example\")  # Get information about a task t <- rrq_task_create_expr(runif(1), controller = obj) rrq_task_info(t, controller = obj)  # If the task has been retried, the retry chain is shown rrq_task_wait(t, controller = obj) rrq_task_retry(t, controller = obj) rrq_task_info(t, controller = obj)  # If the task was queued onto a separate process, then this # information is shown rrq_task_create_expr(1 + 1, separate_process = TRUE, timeout_task_run = 60,                       controller = obj) rrq_task_wait(t, controller = obj) rrq_task_info(t, controller = obj) }"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_list.html","id":null,"dir":"Reference","previous_headings":"","what":"List all tasks — rrq_task_list","title":"List all tasks — rrq_task_list","text":"List tasks.  may lot tasks, can quite slow execute.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"List all tasks — rrq_task_list","text":"","code":"rrq_task_list(controller = NULL)"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"List all tasks — rrq_task_list","text":"controller controller use.  given (NULL) use controller registered rrq_default_controller_set().","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"List all tasks — rrq_task_list","text":"character vector","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_list.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"List all tasks — rrq_task_list","text":"","code":"obj <- rrq_controller(\"rrq:example\")  rrq_task_list(controller = obj) #> [1] \"20fa8b9b8acf0fc7204827b761647b69\" \"ca8c1dd9920175ef1c67c8d79df8d99b\" #> [3] \"19e7eb98ba45dcc39e951459b07d8267\""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_log.html","id":null,"dir":"Reference","previous_headings":"","what":"Fetch task logs — rrq_task_log","title":"Fetch task logs — rrq_task_log","text":"Fetch logs tasks queued separate processes (e.g., rrq_task_create_expr using separate_process = TRUE).  knowable task definitely produces logs - mixture workers enable task logs , depend worker picks logging enabled.  though fine.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_log.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fetch task logs — rrq_task_log","text":"","code":"rrq_task_log(task_id, controller = NULL)"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_log.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fetch task logs — rrq_task_log","text":"task_id single task identifier controller controller use.  given (NULL) use controller registered rrq_default_controller_set().","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_log.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fetch task logs — rrq_task_log","text":"character vector logs, NULL log present yet.  logging enabled task, throw error.  Empty logs can distinguished \"logs yet\", return empty character vector (character(0)).","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_log.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fetch task logs — rrq_task_log","text":"","code":"if (FALSE) { # rrq:::enable_examples(require_queue = \"rrq:example\")  obj <- rrq_controller(\"rrq:example\")  t <- rrq_task_create_expr(message(\"hello!\"), separate_process = TRUE,                           controller = obj) rrq_task_wait(t, controller = obj) rrq_task_log(t, controller = obj) }"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_overview.html","id":null,"dir":"Reference","previous_headings":"","what":"High level task overview — rrq_task_overview","title":"High level task overview — rrq_task_overview","text":"Provide high level overview task statuses set task ids, count major categories PENDING, RUNNING, COMPLETE, ERROR, CANCELLED, DIED, TIMEOUT, IMPOSSIBLE, DEFERRED MOVED.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_overview.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"High level task overview — rrq_task_overview","text":"","code":"rrq_task_overview(task_ids = NULL, controller = NULL)"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_overview.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"High level task overview — rrq_task_overview","text":"task_ids Optional character vector task ids like overview. given (NULL) status task ids known rrq controller used (might fairly costly). controller controller use.  given (NULL) use controller registered rrq_default_controller_set().","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_overview.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"High level task overview — rrq_task_overview","text":"list names corresponding possible task status levels values number tasks state.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_overview.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"High level task overview — rrq_task_overview","text":"","code":"obj <- rrq_controller(\"rrq:example\")  ids <- rrq_task_list(controller = obj) t(as.data.frame(rrq_task_overview(ids, controller = obj))) #>            [,1] #> PENDING       3 #> RUNNING       0 #> COMPLETE      0 #> ERROR         0 #> CANCELLED     0 #> DIED          0 #> TIMEOUT       0 #> IMPOSSIBLE    0 #> DEFERRED      0 #> MOVED         0"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_position.html","id":null,"dir":"Reference","previous_headings":"","what":"Find task position in queue — rrq_task_position","title":"Find task position in queue — rrq_task_position","text":"Find position one tasks queue.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_position.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find task position in queue — rrq_task_position","text":"","code":"rrq_task_position(   task_ids,   missing = 0L,   queue = NULL,   follow = NULL,   controller = NULL )"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_position.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find task position in queue — rrq_task_position","text":"task_ids Character vector tasks find position . missing Value return task found queue. task take value missing running, complete, errored, deferred etc positive integer queue, indicating position (1) next task run. queue name queue query (defaults \"default\" queue). follow Optional logical, indicating follow redirects set rrq_task_retry. given, falls back value passed controller, global option rrq.follow, finally TRUE. Set FALSE want return information original task, even subsequently retried. controller controller use.  given (NULL) use controller registered rrq_default_controller_set().","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_position.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find task position in queue — rrq_task_position","text":"integer vector, length task_ids","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_preceeding.html","id":null,"dir":"Reference","previous_headings":"","what":"List tasks ahead of a task — rrq_task_preceeding","title":"List tasks ahead of a task — rrq_task_preceeding","text":"List tasks front task_id queue. task missing queue return NULL. task next queue return empty character vector.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_preceeding.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"List tasks ahead of a task — rrq_task_preceeding","text":"","code":"rrq_task_preceeding(task_id, queue = NULL, follow = NULL, controller = NULL)"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_preceeding.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"List tasks ahead of a task — rrq_task_preceeding","text":"task_id Task find position . queue name queue query (defaults \"default\" queue). follow Optional logical, indicating follow redirects set rrq_task_retry. given, falls back value passed controller, global option rrq.follow, finally TRUE. Set FALSE want return information original task, even subsequently retried. controller controller use.  given (NULL) use controller registered rrq_default_controller_set().","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_progress.html","id":null,"dir":"Reference","previous_headings":"","what":"Fetch task progress information — rrq_task_progress","title":"Fetch task progress information — rrq_task_progress","text":"Retrieve task progress, set. NULL progress never registered, otherwise whatever value set - can arbitrary R object.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_progress.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fetch task progress information — rrq_task_progress","text":"","code":"rrq_task_progress(task_id, controller = NULL)"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_progress.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fetch task progress information — rrq_task_progress","text":"task_id single task id progress wanted. controller controller use.  given (NULL) use controller registered rrq_default_controller_set().","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_progress.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fetch task progress information — rrq_task_progress","text":"set progress object","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_progress_update.html","id":null,"dir":"Reference","previous_headings":"","what":"Post task update — rrq_task_progress_update","title":"Post task update — rrq_task_progress_update","text":"Post task progress update.  progress system rrq agnostic going render progress, just convention - see Details .  R object can sent progress value (e.g., string, list, etc).","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_progress_update.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Post task update — rrq_task_progress_update","text":"","code":"rrq_task_progress_update(value, error = FALSE)"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_progress_update.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Post task update — rrq_task_progress_update","text":"value R object contents update. overwrite previous progress value, can retrieved calling rrq_task_progress.  value NULL appear clear status, NULL also returned status found task. error Logical, indicating throw error running rrq task. Set FALSE want code work without modification within outside rrq job, TRUE want sure progress messages made server.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_progress_update.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Post task update — rrq_task_progress_update","text":"order report progress, task may, code, write   information fetchable calling rrq_task_progress task_id. also possible register progress without acquiring dependency rrq.  package/script includes code like:   (function can called anything - important bit body function body - must return object message element two class attributes progress condition). can use way rrq::rrq_task_progress_update code.  run without using rrq, function appear nothing.","code":"rrq::rrq_task_progress_update(\"task is 90% done\") progress <- function(message) {   signalCondition(structure(list(message = message),                             class = c(\"progress\", \"condition\"))) }"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_progress_update.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Post task update — rrq_task_progress_update","text":"","code":"if (FALSE) { # rrq:::enable_examples(require_queue = \"rrq:example\") obj <- rrq_controller(\"rrq:example\")  f <- function(n) {   for (i in seq_len(n)) {     rrq::rrq_task_progress_update(sprintf(\"Iteration %d / %d\", i, n))     Sys.sleep(0.1)   }   n }  t <- rrq_task_create_call(f, list(5), controller = obj) # This might be empty at first rrq_task_progress(t, controller = obj) # Wait for the task to complete rrq_task_wait(t, controller = obj) # Contains the _last_ progress message rrq_task_progress(t, controller = obj) }"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Fetch single task result — rrq_task_result","title":"Fetch single task result — rrq_task_result","text":"Get result single task (see rrq_task_results method efficiently getting multiple results ).  Returns value running task complete, error otherwise.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fetch single task result — rrq_task_result","text":"","code":"rrq_task_result(task_id, error = FALSE, follow = NULL, controller = NULL)"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fetch single task result — rrq_task_result","text":"task_id single id result wanted. error Logical, indicating throw error task successful. default (error = FALSE), case task result returning error return object class rrq_task_error, contains information error. Passing error = TRUE calls stop() error returned. follow Optional logical, indicating follow redirects set rrq_task_retry. given, falls back value passed controller, global option rrq.follow, finally TRUE. Set FALSE want return information original task, even subsequently retried. controller controller use.  given (NULL) use controller registered rrq_default_controller_set().","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fetch single task result — rrq_task_result","text":"result task.  may error (object class rrq_task_error) task failed.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_result.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fetch single task result — rrq_task_result","text":"","code":"if (FALSE) { # rrq:::enable_examples(require_queue = \"rrq:example\") obj <- rrq_controller(\"rrq:example\")  # Create a task, wait for it to finish and fetch its result t <- rrq_task_create_expr(runif(1), controller = obj) rrq_task_wait(t, controller = obj) rrq_task_result(t, controller = obj)  # Tasks that fail do not fail on result, but instead return an # object with the class \"rrq_task_error\" t <- rrq_task_create_expr(readRDS(\"somefile.rds\"), controller = obj) rrq_task_wait(t, controller = obj) rrq_task_result(t, controller = obj) }"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_results.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the results of a group of tasks, returning them as a list. See rrq_task_result for getting the result of a single task. — rrq_task_results","title":"Get the results of a group of tasks, returning them as a list. See rrq_task_result for getting the result of a single task. — rrq_task_results","text":"Get results group tasks, returning list. See rrq_task_result getting result single task.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_results.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the results of a group of tasks, returning them as a list. See rrq_task_result for getting the result of a single task. — rrq_task_results","text":"","code":"rrq_task_results(   task_ids,   error = FALSE,   named = FALSE,   follow = NULL,   controller = NULL )"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_results.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the results of a group of tasks, returning them as a list. See rrq_task_result for getting the result of a single task. — rrq_task_results","text":"task_ids vector task ids task result wanted. error Logical, indicating throw error task successful. See rrq_task_result() details. named Logical, indicating return value named task ids; quite long can make value little awkward work . follow Optional logical, indicating follow redirects set rrq_task_retry. given, falls back value passed controller, global option rrq.follow, finally TRUE. Set FALSE want return information original task, even subsequently retried. controller controller use.  given (NULL) use controller registered rrq_default_controller_set().","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_results.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the results of a group of tasks, returning them as a list. See rrq_task_result for getting the result of a single task. — rrq_task_results","text":"list, one entry per result.  function errors task available.  named = TRUE, list named task_ids.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_results.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the results of a group of tasks, returning them as a list. See rrq_task_result for getting the result of a single task. — rrq_task_results","text":"","code":"if (FALSE) { # rrq:::enable_examples(require_queue = \"rrq:example\") obj <- rrq_controller(\"rrq:example\")  ts <- rrq_task_create_bulk_call(sqrt, 1:10, controller = obj) rrq_task_wait(ts, controller = obj) rrq_task_results(ts, controller = obj)  # For a single task, rrq_task_result and rrq_task_results differ # in the return type; rrq_task_results always returns a list: t <- ts[[1]] rrq_task_result(t, controller = obj) rrq_task_results(t, controller = obj) }"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_retry.html","id":null,"dir":"Reference","previous_headings":"","what":"Retry tasks — rrq_task_retry","title":"Retry tasks — rrq_task_retry","text":"Retry task (set tasks). Typically failure (e.g., ERROR, DIED similar) can retry even successfully completed tasks. retried, functions retrieve information task (e.g., rrq_task_status(), [rrq_task_result()]) behave differently depending value followargument. Seevignette(\"fault-tolerance\")` details.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_retry.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Retry tasks — rrq_task_retry","text":"","code":"rrq_task_retry(task_ids, controller = NULL)"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_retry.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Retry tasks — rrq_task_retry","text":"task_ids Task ids retry. controller controller use.  given (NULL) use controller registered rrq_default_controller_set().","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_retry.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Retry tasks — rrq_task_retry","text":"New task ids","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_retry.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Retry tasks — rrq_task_retry","text":"","code":"if (FALSE) { # rrq:::enable_examples(require_queue = \"rrq:example\") obj <- rrq_controller(\"rrq:example\")  # It's straightforward to see the effect of retrying a task with # one that produces a different value each time, so here, we use a # simple task that draws one normally distributed random number t1 <- rrq_task_create_expr(rnorm(1), controller = obj) rrq_task_wait(t1, controller = obj) rrq_task_result(t1, controller = obj)  # If we retry the task we'll get a different value: t2 <- rrq_task_retry(t1, controller = obj) rrq_task_wait(t2, controller = obj) rrq_task_result(t2, controller = obj)  # Once a task is retried, most of the time (by default) you can use # the original id and the new one exchangeably: rrq_task_result(t1, controller = obj) rrq_task_result(t2, controller = obj)  # Use the 'follow' argument to modify this behaviour rrq_task_result(t1, follow = FALSE, controller = obj) rrq_task_result(t2, follow = FALSE, controller = obj)  # See the retry chain with rrq_task_info rrq_task_info(t1, controller = obj) rrq_task_info(t2, controller = obj) }"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_status.html","id":null,"dir":"Reference","previous_headings":"","what":"Fetch task statuses — rrq_task_status","title":"Fetch task statuses — rrq_task_status","text":"Return character vector task statuses. name element corresponds task id, value one possible statuses (\"PENDING\", \"COMPLETE\", etc).","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_status.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fetch task statuses — rrq_task_status","text":"","code":"rrq_task_status(task_ids, named = FALSE, follow = NULL, controller = NULL)"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_status.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fetch task statuses — rrq_task_status","text":"task_ids Optional character vector task ids like statuses. named Logical, indicating return value named task ids; quite long can make value little awkward work . follow Optional logical, indicating follow redirects set rrq_task_retry. given, falls back value passed controller, global option rrq.follow, finally TRUE. Set FALSE want return information original task, even subsequently retried. controller controller use.  given (NULL) use controller registered rrq_default_controller_set().","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_status.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fetch task statuses — rrq_task_status","text":"character vector length task_ids","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_status.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fetch task statuses — rrq_task_status","text":"","code":"if (FALSE) { # rrq:::enable_examples(require_queue = \"rrq:example\") obj <- rrq_controller(\"rrq:example\")  ts <- rrq_task_create_bulk_call(sqrt, 1:10, controller = obj) rrq_task_status(ts, controller = obj) rrq_task_wait(ts, controller = obj) rrq_task_status(ts, controller = obj) }"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_times.html","id":null,"dir":"Reference","previous_headings":"","what":"Fetch task times — rrq_task_times","title":"Fetch task times — rrq_task_times","text":"Fetch times tasks points life cycle.  task returns time submission, starting completion (necessarily successfully; includes errors interruptions). task reached point yet (e.g., submitted run, running finished) time NA).  Times returned unix timestamp format UTC; can use redux::redis_time_to_r convert POSIXt object.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_times.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fetch task times — rrq_task_times","text":"","code":"rrq_task_times(task_ids, follow = NULL, controller = NULL)"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_times.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fetch task times — rrq_task_times","text":"task_ids vector task ids follow Optional logical, indicating follow redirects set rrq_task_retry. given, falls back value passed controller, global option rrq.follow, finally TRUE. Set FALSE want return information original task, even subsequently retried. controller controller use.  given (NULL) use controller registered rrq_default_controller_set().","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_times.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fetch task times — rrq_task_times","text":"matrix times, row names corresponding task ids.  may change data.frame point future.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_times.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fetch task times — rrq_task_times","text":"","code":"if (FALSE) { # rrq:::enable_examples(require_queue = \"rrq:example\") obj <- rrq_controller(\"rrq:example\")  t <- rrq_task_create_expr(Sys.sleep(3), controller = obj) rrq_task_times(t, controller = obj) rrq_task_wait(t, controller = obj) rrq_task_times(t, controller = obj) }"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_wait.html","id":null,"dir":"Reference","previous_headings":"","what":"Wait for group of tasks — rrq_task_wait","title":"Wait for group of tasks — rrq_task_wait","text":"Wait task, set tasks, complete.  used rrq prior version 0.8.0, might expect function return result, now return logical value indicates success .  can fetch task result rrq_task_result.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_wait.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Wait for group of tasks — rrq_task_wait","text":"","code":"rrq_task_wait(   task_id,   timeout = NULL,   time_poll = 1,   progress = NULL,   follow = NULL,   controller = NULL )"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_wait.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Wait for group of tasks — rrq_task_wait","text":"task_id vector task ids poll (can one task many) timeout Optional timeout, seconds, error thrown task completed. given, falls back controller's timeout_task_wait (see rrq_controller) time_poll Optional time \"poll\" completion.  default 1 second; time request completed task may block (however, task finished , actual time waited less).  Increasing reduce responsiveness R session interrupting, cause slightly less network load.  Values less 1s supported Redis server version 6.0.0 greater (released September 2020). progress Optional logical indicating progress bar displayed. NULL fall back value global option rrq.progress, unset display progress bar interactive session. follow Optional logical, indicating follow redirects set rrq_task_retry. given, falls back value passed controller, global option rrq.follow, finally TRUE. Set FALSE want return information original task, even subsequently retried. controller controller use.  given (NULL) use controller registered rrq_default_controller_set().","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_wait.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Wait for group of tasks — rrq_task_wait","text":"scalar logical value; TRUE tasks complete successfully FALSE otherwise","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_task_wait.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Wait for group of tasks — rrq_task_wait","text":"","code":"if (FALSE) { # rrq:::enable_examples(require_queue = \"rrq:example\") obj <- rrq_controller(\"rrq:example\") t1 <- rrq_task_create_expr(Sys.sleep(1), controller = obj) rrq_task_wait(t1, controller = obj)  # The return value of wait gives a summary of successfullness # of the task t2 <- rrq_task_create_expr(stop(\"Some error\"), controller = obj) rrq_task_wait(t2, controller = obj)  # If you wait on many tasks, the return value is effectively # reduced with \"all\" (so the result is TRUE if all tasks were # successful) rrq_task_wait(c(t1, t2), controller = obj) }"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker.html","id":null,"dir":"Reference","previous_headings":"","what":"rrq queue worker — rrq_worker","title":"rrq queue worker — rrq_worker","text":"rrq queue worker rrq queue worker","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"rrq queue worker — rrq_worker","text":"rrq queue worker.  typically interacting sit poll queue jobs.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker.html","id":"public-fields","dir":"Reference","previous_headings":"","what":"Public fields","title":"rrq queue worker — rrq_worker","text":"id id worker config name configuration used worker controller rrq controller object","code":""},{"path":[]},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"rrq queue worker — rrq_worker","text":"rrq_worker$new() rrq_worker$info() rrq_worker$log() rrq_worker$load_envir() rrq_worker$poll() rrq_worker$step() rrq_worker$loop() rrq_worker$format() rrq_worker$timer_start() rrq_worker$progress() rrq_worker$task_eval() rrq_worker$shutdown()","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"rrq queue worker — rrq_worker","text":"Constructor","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"rrq queue worker — rrq_worker","text":"","code":"rrq_worker$new(   queue_id,   name_config = \"localhost\",   worker_id = NULL,   timeout_config = 0,   is_child = FALSE,   con = redux::hiredis(),   offload_path = NULL )"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"rrq queue worker — rrq_worker","text":"queue_id queue id name_config Optional name configuration. default \"localhost\" configuration always exists. Create new configurations using rrq_worker_config_save. worker_id Optional worker id.  omitted, random id created. timeout_config long try read worker configuration . attempt read second throw error config located timeout seconds. Use create workers configurations available. default (0) assume configuration immediately available. is_child Logical, used indicate child real worker.  is_child TRUE, arguments effect (e.g., queue timeout / idle / polling arguments) come parent. general use. con redis connection offload_path path create offload store . See rrq_controller details.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker.html","id":"method-info-","dir":"Reference","previous_headings":"","what":"Method info()","title":"rrq queue worker — rrq_worker","text":"Return information worker, list key-value pairs.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"rrq queue worker — rrq_worker","text":"","code":"rrq_worker$info()"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker.html","id":"method-log-","dir":"Reference","previous_headings":"","what":"Method log()","title":"rrq queue worker — rrq_worker","text":"Create log entry. print human readable format screen machine-readable format redis database.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"rrq queue worker — rrq_worker","text":"","code":"rrq_worker$log(label, value = NULL)"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"rrq queue worker — rrq_worker","text":"label Scalar character, title log entry value Character vector (null) log values","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker.html","id":"method-load-envir-","dir":"Reference","previous_headings":"","what":"Method load_envir()","title":"rrq queue worker — rrq_worker","text":"Load worker environment creating new environment object running create hook (configured). See rrq_worker_envir_set() details.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker.html","id":"usage-3","dir":"Reference","previous_headings":"","what":"Usage","title":"rrq queue worker — rrq_worker","text":"","code":"rrq_worker$load_envir()"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker.html","id":"method-poll-","dir":"Reference","previous_headings":"","what":"Method poll()","title":"rrq queue worker — rrq_worker","text":"Poll work","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker.html","id":"usage-4","dir":"Reference","previous_headings":"","what":"Usage","title":"rrq queue worker — rrq_worker","text":"","code":"rrq_worker$poll(immediate = FALSE)"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"rrq queue worker — rrq_worker","text":"immediate Logical, indicating blocking wait queue instead reducing timeout zero. Intended primarily use tests.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker.html","id":"method-step-","dir":"Reference","previous_headings":"","what":"Method step()","title":"rrq queue worker — rrq_worker","text":"Take single \"step\". consists Poll work ($poll()) work found, run (either task message) work found, check timeout","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker.html","id":"usage-5","dir":"Reference","previous_headings":"","what":"Usage","title":"rrq queue worker — rrq_worker","text":"","code":"rrq_worker$step(immediate = FALSE)"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker.html","id":"arguments-3","dir":"Reference","previous_headings":"","what":"Arguments","title":"rrq queue worker — rrq_worker","text":"immediate Logical, indicating blocking wait queue instead reducing timeout zero. Intended primarily use tests.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker.html","id":"method-loop-","dir":"Reference","previous_headings":"","what":"Method loop()","title":"rrq queue worker — rrq_worker","text":"main worker loop. Use set main worker event loop, continue exiting (via timeout message).","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker.html","id":"usage-6","dir":"Reference","previous_headings":"","what":"Usage","title":"rrq queue worker — rrq_worker","text":"","code":"rrq_worker$loop(immediate = FALSE)"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker.html","id":"arguments-4","dir":"Reference","previous_headings":"","what":"Arguments","title":"rrq queue worker — rrq_worker","text":"immediate Logical, indicating blocking wait queue instead reducing timeout zero. Intended primarily use tests.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker.html","id":"method-format-","dir":"Reference","previous_headings":"","what":"Method format()","title":"rrq queue worker — rrq_worker","text":"Create nice string representation worker. Used automatically print worker R6.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker.html","id":"usage-7","dir":"Reference","previous_headings":"","what":"Usage","title":"rrq queue worker — rrq_worker","text":"","code":"rrq_worker$format()"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker.html","id":"method-timer-start-","dir":"Reference","previous_headings":"","what":"Method timer_start()","title":"rrq queue worker — rrq_worker","text":"Start timer","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker.html","id":"usage-8","dir":"Reference","previous_headings":"","what":"Usage","title":"rrq queue worker — rrq_worker","text":"","code":"rrq_worker$timer_start()"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker.html","id":"method-progress-","dir":"Reference","previous_headings":"","what":"Method progress()","title":"rrq queue worker — rrq_worker","text":"Submit progress message. See rrq_task_progress_update() details mechanism.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker.html","id":"usage-9","dir":"Reference","previous_headings":"","what":"Usage","title":"rrq queue worker — rrq_worker","text":"","code":"rrq_worker$progress(value, error = TRUE)"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker.html","id":"arguments-5","dir":"Reference","previous_headings":"","what":"Arguments","title":"rrq queue worker — rrq_worker","text":"value R object contents update. overwrite previous progress value, can retrieved rrq_task_progress.  value NULL appear clear status, NULL also returned status found task. error Logical, indicating throw error running rrq task. Set FALSE want code work without modification within outside rrq job, TRUE want sure progress messages made server.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker.html","id":"method-task-eval-","dir":"Reference","previous_headings":"","what":"Method task_eval()","title":"rrq queue worker — rrq_worker","text":"Evaluate task. running task separate process, always set two environment variables: * RRQ_WORKER_ID id field * RRQ_TASK_ID task id","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker.html","id":"usage-10","dir":"Reference","previous_headings":"","what":"Usage","title":"rrq queue worker — rrq_worker","text":"","code":"rrq_worker$task_eval(task_id)"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker.html","id":"arguments-6","dir":"Reference","previous_headings":"","what":"Arguments","title":"rrq queue worker — rrq_worker","text":"task_id task identifier. undefined happens identifier exist.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker.html","id":"method-shutdown-","dir":"Reference","previous_headings":"","what":"Method shutdown()","title":"rrq queue worker — rrq_worker","text":"Stop worker","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker.html","id":"usage-11","dir":"Reference","previous_headings":"","what":"Usage","title":"rrq queue worker — rrq_worker","text":"","code":"rrq_worker$shutdown(status = \"OK\", graceful = TRUE)"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker.html","id":"arguments-7","dir":"Reference","previous_headings":"","what":"Arguments","title":"rrq queue worker — rrq_worker","text":"status worker status; typically one OK ERROR can string graceful Logical, indicating request graceful shutdown heartbeat, running.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_config.html","id":null,"dir":"Reference","previous_headings":"","what":"Create worker configuration — rrq_worker_config","title":"Create worker configuration — rrq_worker_config","text":"Create worker configuration, suitable pass rrq_worker_config_save. results function modified.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_config.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create worker configuration — rrq_worker_config","text":"","code":"rrq_worker_config(   queue = NULL,   verbose = TRUE,   logdir = NULL,   poll_queue = NULL,   timeout_idle = Inf,   poll_process = 1,   timeout_process_die = 2,   heartbeat_period = NULL,   offload_threshold_size = Inf )"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_config.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create worker configuration — rrq_worker_config","text":"queue Optional character vector queues listen tasks. default queue always listened (called 'default'). can specify additional names tasks put onto queues rrq_task_create_expr() (functions) higher priority default. can explicitly list \"default\" queue (e.g., queue = c(\"high\", \"default\", \"low\")) set position default queue. verbose Logical, indicating worker print logging output screen.  Logging screen small measurable performance cost, collect system logs worker wasted time.  Logging redis server always enabled. logdir Optional log directory use writing logs queuing tasks separate process.  given, logs saved <logdir>/<task_id>.  directory writable workers readable controller. poll_queue Polling time new tasks queue messages. Longer values reduce impact database make workers less responsive killed interrupt (control-C Escape).  default good uses, shorter values used debugging. Importantly, longer times increase time taken worker detect new tasks. timeout_idle Optional timeout sets length time worker exit processed task. (roughly) equivalent issuing TIMEOUT_SET message initialising worker, except guaranteed run workers. poll_process Polling time indicating long wait background process produce stdout stderr. used tasks queued separate_process TRUE. timeout_process_die Timeout indicating long wait wait background process respond SIGTERM, either stop worker cancel task. used tasks queued separate_process TRUE. tasks may take several seconds stop, may want increase ensure clean exit. heartbeat_period Optional period heartbeat.  non-NULL heartbeat process started (using rrq_heartbeat) can used build fault tolerant queues. See vignette(\"fault-tolerance\") details. NULL (default), heartbeat configured. offload_threshold_size object size beyond task results offloaded disk instead stored Redis. See rrq_controller details. Inf (default), results never offloaded.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_config.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create worker configuration — rrq_worker_config","text":"list values class rrq_worker_config; considered read-, contain validated input parameters.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_config.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create worker configuration — rrq_worker_config","text":"","code":"rrq::rrq_worker_config() #> $queue #> [1] \"default\" #>  #> $verbose #> [1] TRUE #>  #> $logdir #> NULL #>  #> $poll_queue #> [1] 60 #>  #> $timeout_idle #> [1] Inf #>  #> $poll_process #> [1] 1 #>  #> $timeout_process_die #> [1] 2 #>  #> $heartbeat_period #> NULL #>  #> $offload_threshold_size #> [1] Inf #>  #> attr(,\"class\") #> [1] \"rrq_worker_config\""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_config_list.html","id":null,"dir":"Reference","previous_headings":"","what":"List worker configurations — rrq_worker_config_list","title":"List worker configurations — rrq_worker_config_list","text":"Return names worker configurations saved rrq_worker_config_save()","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_config_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"List worker configurations — rrq_worker_config_list","text":"","code":"rrq_worker_config_list(controller = NULL)"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_config_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"List worker configurations — rrq_worker_config_list","text":"controller controller use.  given (NULL) use controller registered rrq_default_controller_set().","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_config_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"List worker configurations — rrq_worker_config_list","text":"character vector names; can passed name argument rrq_worker_config_read().","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_config_list.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"List worker configurations — rrq_worker_config_list","text":"","code":"if (FALSE) { # rrq:::enable_examples(require_queue = \"rrq:example\") obj <- rrq_controller(\"rrq:example\")  cfg <- rrq_worker_config(\"fast\") rrq_worker_config_save(\"use-fast\", cfg, controller = obj) rrq_worker_config_list(controller = obj) }"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_config_read.html","id":null,"dir":"Reference","previous_headings":"","what":"Read worker configuration — rrq_worker_config_read","title":"Read worker configuration — rrq_worker_config_read","text":"Return value worker configuration saved rrq_worker_config_save()","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_config_read.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read worker configuration — rrq_worker_config_read","text":"","code":"rrq_worker_config_read(name, timeout = 0, controller = NULL)"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_config_read.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read worker configuration — rrq_worker_config_read","text":"name Name configuration (see rrq_worker_config_list()) timeout Optionally, timeout wait worker configuration appear.  Generally want set , can used block configuration becomes available. controller controller use.  given (NULL) use controller registered rrq_default_controller_set().","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_config_read.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read worker configuration — rrq_worker_config_read","text":"","code":"if (FALSE) { # rrq:::enable_examples(require_queue = \"rrq:example\") obj <- rrq_controller(\"rrq:example\")  cfg <- rrq_worker_config(\"fast\") rrq_worker_config_save(\"use-fast\", cfg, controller = obj) rrq_worker_config_read(\"use-fast\", controller = obj) }"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_config_save.html","id":null,"dir":"Reference","previous_headings":"","what":"Save worker configuration — rrq_worker_config_save","title":"Save worker configuration — rrq_worker_config_save","text":"Save worker configuration, can used start workers set options cli. correspond arguments rrq_worker. function renamed soon","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_config_save.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Save worker configuration — rrq_worker_config_save","text":"","code":"rrq_worker_config_save(name, config, overwrite = TRUE, controller = NULL)"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_config_save.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Save worker configuration — rrq_worker_config_save","text":"name Name configuration config worker configuration, created rrq_worker_config() overwrite Logical, indicating existing configuration name overwritten exists. FALSE, configuration updated, even differs version currently saved. controller controller use.  given (NULL) use controller registered rrq_default_controller_set().","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_config_save.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Save worker configuration — rrq_worker_config_save","text":"Invisibly, boolean indicating configuration updated.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_config_save.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Save worker configuration — rrq_worker_config_save","text":"","code":"if (FALSE) { # rrq:::enable_examples(require_queue = \"rrq:example\") obj <- rrq_controller(\"rrq:example\")  cfg <- rrq_worker_config(\"fast\") rrq_worker_config_save(\"use-fast\", cfg, controller = obj) rrq_worker_config_list(controller = obj) }"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_delete_exited.html","id":null,"dir":"Reference","previous_headings":"","what":"Clean up exited workers — rrq_worker_delete_exited","title":"Clean up exited workers — rrq_worker_delete_exited","text":"Cleans workers known exited.  See vignette(\"fault-tolerance\") details.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_delete_exited.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Clean up exited workers — rrq_worker_delete_exited","text":"","code":"rrq_worker_delete_exited(worker_ids = NULL, controller = NULL)"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_delete_exited.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Clean up exited workers — rrq_worker_delete_exited","text":"worker_ids Optional vector worker ids. NULL rrq looks exited workers using rrq_worker_list_exited(). given, check workers known exited. controller controller use.  given (NULL) use controller registered rrq_default_controller_set().","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_delete_exited.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Clean up exited workers — rrq_worker_delete_exited","text":"character vector workers deleted","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_delete_exited.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Clean up exited workers — rrq_worker_delete_exited","text":"","code":"if (FALSE) { # rrq:::enable_examples(require_queue = \"rrq:example\") obj <- rrq_controller(\"rrq:example\") rrq_worker_delete_exited(controller = obj) }"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_detect_exited.html","id":null,"dir":"Reference","previous_headings":"","what":"Detect exited workers — rrq_worker_detect_exited","title":"Detect exited workers — rrq_worker_detect_exited","text":"Detects exited workers lapsed heartbeat.  differs rrq_worker_list_exited() lists workers definitely exited checking see worker runs heartbeat process reported back time, marks worker exited.  See vignette(\"fault-tolerance\") details.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_detect_exited.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detect exited workers — rrq_worker_detect_exited","text":"","code":"rrq_worker_detect_exited(controller = NULL)"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_detect_exited.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Detect exited workers — rrq_worker_detect_exited","text":"controller controller use.  given (NULL) use controller registered rrq_default_controller_set().","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_detect_exited.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Detect exited workers — rrq_worker_detect_exited","text":"Undefined.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_detect_exited.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Detect exited workers — rrq_worker_detect_exited","text":"","code":"if (FALSE) { # rrq:::enable_examples(require_queue = \"rrq:example\") obj <- rrq_controller(\"rrq:example\") rrq_worker_detect_exited(controller = obj) }"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_envir_set.html","id":null,"dir":"Reference","previous_headings":"","what":"Set worker environment — rrq_worker_envir_set","title":"Set worker environment — rrq_worker_envir_set","text":"Register function create environment creating worker. worker starts, run function.  function rrq_worker_envir_refresh asks worker reload copy already specified environment (e.g., pick changes source files).","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_envir_set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set worker environment — rrq_worker_envir_set","text":"","code":"rrq_worker_envir_set(create, notify = TRUE, controller = NULL)  rrq_worker_envir_refresh(controller = NULL)"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_envir_set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set worker environment — rrq_worker_envir_set","text":"create function create environment. called one parameter (environment), fresh R session. function rrq_envir() can used create suitable function common case (loading packages sourcing scripts). Set NULL remove environment creation function (.e., start workers essentially empty environment). notify Boolean, indicating send REFRESH message workers update environment, via rrq_worker_envir_refresh controller controller use.  given (NULL) use controller registered rrq_default_controller_set().","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_envir_set.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set worker environment — rrq_worker_envir_set","text":"","code":"if (FALSE) { # rrq:::enable_examples(require_queue = \"rrq:example\") obj <- rrq_controller(\"rrq:example\")  rrq_worker_envir_set(rrq_envir(packages = \"ids\"), controller = obj) t <- rrq_task_create_expr(search(), controller = obj) rrq_task_wait(t, controller = obj) rrq_task_result(t, controller = obj) rrq_worker_log_tail(n = 5, controller = obj)  rrq_worker_envir_set(NULL, controller = obj) }"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_exists.html","id":null,"dir":"Reference","previous_headings":"","what":"Test if a worker exists — rrq_worker_exists","title":"Test if a worker exists — rrq_worker_exists","text":"Test worker exists","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_exists.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test if a worker exists — rrq_worker_exists","text":"","code":"rrq_worker_exists(name, controller = NULL)"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_exists.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test if a worker exists — rrq_worker_exists","text":"name Name worker controller controller use.  given (NULL) use controller registered rrq_default_controller_set().","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_exists.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test if a worker exists — rrq_worker_exists","text":"logical value","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_exists.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test if a worker exists — rrq_worker_exists","text":"","code":"if (FALSE) { # rrq:::enable_examples(require_queue = \"rrq:example\") obj <- rrq_controller(\"rrq:example\") w <- rrq_worker_list(controller = obj) rrq_worker_exists(w, controller = obj) rrq_worker_exists(\"bob-the-builder\", controller = obj) }"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_info.html","id":null,"dir":"Reference","previous_headings":"","what":"Worker information — rrq_worker_info","title":"Worker information — rrq_worker_info","text":"Returns list information active workers (exited workers worker_ids includes ).","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_info.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Worker information — rrq_worker_info","text":"","code":"rrq_worker_info(worker_ids = NULL, controller = NULL)"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_info.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Worker information — rrq_worker_info","text":"worker_ids Optional vector worker ids. NULL active workers used. controller controller use.  given (NULL) use controller registered rrq_default_controller_set().","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_info.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Worker information — rrq_worker_info","text":"list worker_info objects","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_info.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Worker information — rrq_worker_info","text":"","code":"if (FALSE) { # rrq:::enable_examples(require_queue = \"rrq:example\") obj <- rrq_controller(\"rrq:example\") rrq_worker_info(controller = obj) }"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_len.html","id":null,"dir":"Reference","previous_headings":"","what":"Number of active workers — rrq_worker_len","title":"Number of active workers — rrq_worker_len","text":"Returns number active workers","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_len.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Number of active workers — rrq_worker_len","text":"","code":"rrq_worker_len(controller = NULL)"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_len.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Number of active workers — rrq_worker_len","text":"controller controller use.  given (NULL) use controller registered rrq_default_controller_set().","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_len.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Number of active workers — rrq_worker_len","text":"integer","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_len.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Number of active workers — rrq_worker_len","text":"","code":"if (FALSE) { # rrq:::enable_examples(require_queue = \"rrq:example\") obj <- rrq_controller(\"rrq:example\") rrq_worker_len(controller = obj) }"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_list.html","id":null,"dir":"Reference","previous_headings":"","what":"List active workers — rrq_worker_list","title":"List active workers — rrq_worker_list","text":"Returns ids active workers.  include exited workers; use rrq_worker_list_exited() .","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"List active workers — rrq_worker_list","text":"","code":"rrq_worker_list(controller = NULL)"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"List active workers — rrq_worker_list","text":"controller controller use.  given (NULL) use controller registered rrq_default_controller_set().","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"List active workers — rrq_worker_list","text":"character vector worker names","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_list.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"List active workers — rrq_worker_list","text":"","code":"if (FALSE) { # rrq:::enable_examples(require_queue = \"rrq:example\") obj <- rrq_controller(\"rrq:example\") rrq_worker_list(controller = obj) }"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_list_exited.html","id":null,"dir":"Reference","previous_headings":"","what":"List exited workers — rrq_worker_list_exited","title":"List exited workers — rrq_worker_list_exited","text":"Returns ids workers known exited","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_list_exited.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"List exited workers — rrq_worker_list_exited","text":"","code":"rrq_worker_list_exited(controller = NULL)"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_list_exited.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"List exited workers — rrq_worker_list_exited","text":"controller controller use.  given (NULL) use controller registered rrq_default_controller_set().","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_list_exited.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"List exited workers — rrq_worker_list_exited","text":"character vector worker names","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_list_exited.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"List exited workers — rrq_worker_list_exited","text":"","code":"if (FALSE) { # rrq:::enable_examples(require_queue = \"rrq:example\") obj <- rrq_controller(\"rrq:example\")  # At this point you might have an exited worker, depending on # which examples have been run so far! rrq_worker_list_exited(controller = obj)  # Spawn a new worker so that we can stop it: w <- rrq_worker_spawn(1, controller = obj)$id w$id # Stop this worker and see that it appears in the list of exited # workers: rrq_worker_stop(w$id, controller = obj) rrq_worker_list_exited(controller = obj)  # We can delete this exited worker: rrq_worker_delete_exited(w$id, controller = obj)  # After this, it is no longer listed as exited: rrq_worker_list_exited(controller = obj) }"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_load.html","id":null,"dir":"Reference","previous_headings":"","what":"Report on worker load — rrq_worker_load","title":"Report on worker load — rrq_worker_load","text":"Report worker \"load\" (number workers used time). Reruns object class worker_load, mean method exists (function work progress interface may change).","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_load.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Report on worker load — rrq_worker_load","text":"","code":"rrq_worker_load(worker_ids = NULL, controller = NULL)"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_load.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Report on worker load — rrq_worker_load","text":"worker_ids Optional vector worker ids. NULL active workers used. controller controller use.  given (NULL) use controller registered rrq_default_controller_set().","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_load.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Report on worker load — rrq_worker_load","text":"object class \"worker_load\", pretty print method.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_load.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Report on worker load — rrq_worker_load","text":"","code":"if (FALSE) { # rrq:::enable_examples(require_queue = \"rrq:example\") obj <- rrq_controller(\"rrq:example\") mean(rrq_worker_load(controller = obj)) }"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_log_tail.html","id":null,"dir":"Reference","previous_headings":"","what":"Returns the last (few) elements in the worker log, in a programmatically useful format (see Value). — rrq_worker_log_tail","title":"Returns the last (few) elements in the worker log, in a programmatically useful format (see Value). — rrq_worker_log_tail","text":"Returns last () elements worker log, programmatically useful format (see Value).","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_log_tail.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Returns the last (few) elements in the worker log, in a programmatically useful format (see Value). — rrq_worker_log_tail","text":"","code":"rrq_worker_log_tail(worker_ids = NULL, n = 1, controller = NULL)"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_log_tail.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Returns the last (few) elements in the worker log, in a programmatically useful format (see Value). — rrq_worker_log_tail","text":"worker_ids Optional vector worker ids. NULL active workers used. n Number elements select, default single last entry. Use Inf 0 indicate want log entries controller controller use.  given (NULL) use controller registered rrq_default_controller_set().","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_log_tail.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Returns the last (few) elements in the worker log, in a programmatically useful format (see Value). — rrq_worker_log_tail","text":"data.frame columns: worker_id: worker id child: process id, integer, logs come child process task queued separate_process = TRUE time: time Redis event happened; see redux::redis_time convert R time command: command sent worker message: message corresponding command","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_log_tail.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Returns the last (few) elements in the worker log, in a programmatically useful format (see Value). — rrq_worker_log_tail","text":"","code":"if (FALSE) { # rrq:::enable_examples(require_queue = \"rrq:example\") obj <- rrq_controller(\"rrq:example\") rrq_worker_log_tail(n = 10, controller = obj) }"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_process_log.html","id":null,"dir":"Reference","previous_headings":"","what":"Read worker process log — rrq_worker_process_log","title":"Read worker process log — rrq_worker_process_log","text":"Return contents worker's process log, located physical storage (including network storage) controller. generally behave workers started rrq_worker_spawn may require significant care otherwise.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_process_log.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read worker process log — rrq_worker_process_log","text":"","code":"rrq_worker_process_log(worker_id, controller = NULL)"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_process_log.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read worker process log — rrq_worker_process_log","text":"worker_id worker id log required controller controller use.  given (NULL) use controller registered rrq_default_controller_set().","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_process_log.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read worker process log — rrq_worker_process_log","text":"character vector, one line per line log.  logging enabled worker produced logs, empty character vector. logging enabled, function throw.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_process_log.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read worker process log — rrq_worker_process_log","text":"","code":"if (FALSE) { # rrq:::enable_examples(require_queue = \"rrq:example\") obj <- rrq_controller(\"rrq:example\") worker_id <- rrq_worker_list(controller = obj)[[1]] tryCatch(   rrq_worker_process_log(worker_id, controller = obj),   error = identity) }"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_script.html","id":null,"dir":"Reference","previous_headings":"","what":"Write worker runner script — rrq_worker_script","title":"Write worker runner script — rrq_worker_script","text":"Write small script can used launch rrq worker. resulting script takes arguments rrq_worker constructor, command line. See Details.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_script.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write worker runner script — rrq_worker_script","text":"","code":"rrq_worker_script(path, versioned = FALSE)"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_script.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Write worker runner script — rrq_worker_script","text":"path path write . directory (one created yet exist). final script file.path(path, \"rrq_worker\") versioned Logical, indicating write versioned R script use path Rscript running session. FALSE use #!/usr/bin/env Rscript pick Rscript path. may want use versioned script tests multiple R versions installed simultaneously.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_script.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Write worker runner script — rrq_worker_script","text":"Invisibly, path script","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_script.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Write worker runner script — rrq_worker_script","text":"need launch rrq workers script, convenient embed R code like:   error-prone unpleasant quote read. can use function rrq_worker_script write small helper script lets write:   instead. helper script supports arguments [rrq::rrq_worker] constructor: queue_id sole positional argument name_config --config worker_id --worker-id change redis connection settings, set REDIS_URL environment variable (see redux::hiredis() details). example create worker myworker configuration myconfig queue myqueue might use","code":"Rscript -e 'rrq::rrq_worker$new(\"myqueue\")' ./path/rrq_worker myqueue ./rrq_worker --config=myconfig --worker-id=myworker myqueue"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_script.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Write worker runner script — rrq_worker_script","text":"","code":"path <- rrq::rrq_worker_script(tempfile()) readLines(path) #> [1] \"#!/usr/bin/env Rscript\"  \"rrq:::rrq_worker_main()\""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_spawn.html","id":null,"dir":"Reference","previous_headings":"","what":"Spawn a worker — rrq_worker_spawn","title":"Spawn a worker — rrq_worker_spawn","text":"Spawn worker background","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_spawn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spawn a worker — rrq_worker_spawn","text":"","code":"rrq_worker_spawn(   n = 1,   logdir = NULL,   timeout = 600,   name_config = \"localhost\",   worker_id_base = NULL,   time_poll = 0.2,   progress = NULL,   controller = NULL,   offload_path = NULL )"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_spawn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spawn a worker — rrq_worker_spawn","text":"n Number workers spawn logdir Path log directory write worker process log , interpreted relative current working directory timeout Time wait workers appear. 0 wait workers appear (can run wait_alive method returned object run test manually) name_config Name configuration use.  default \"localhost\" configuration used worker_id_base Optional base construct worker ids .  omitted random base used. Actual ids created appending integers base. time_poll Polling period (seconds) waiting workers come . progress Show progress bar waiting workers (timeout least 0) controller controller use.  given (NULL) use controller registered rrq_default_controller_set(). offload_path path create offload store . See rrq_controller details.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_spawn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spawn a worker — rrq_worker_spawn","text":"rrq_worker_manager object fields: id: ids spawned workers wait_alive: method wait workers come alive stop: method stop workers kill: method kill workers abruptly sending signal is_alive: method checks worker currently alive logs: method returns logs single worker methods accept vector worker names, integers, except logs requires single worker id (string integer). methods except logs, default NULL means \"managed workers\".","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_spawn.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Spawn a worker — rrq_worker_spawn","text":"Spawning multiple workers.  n greater one, multiple workers spawned.  happens parallel take n times longer spawning single worker. Beware signals like Ctrl-C passed R instance can still propagate child processes can result dying unexpectedly.  probably safer start processes completely separate session.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_status.html","id":null,"dir":"Reference","previous_headings":"","what":"Worker statuses — rrq_worker_status","title":"Worker statuses — rrq_worker_status","text":"Returns character vector current worker statuses","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_status.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Worker statuses — rrq_worker_status","text":"","code":"rrq_worker_status(worker_ids = NULL, controller = NULL)"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_status.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Worker statuses — rrq_worker_status","text":"worker_ids Optional vector worker ids. NULL active workers used. controller controller use.  given (NULL) use controller registered rrq_default_controller_set().","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_status.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Worker statuses — rrq_worker_status","text":"character vector statuses, named worker","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_status.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Worker statuses — rrq_worker_status","text":"","code":"if (FALSE) { # rrq:::enable_examples(require_queue = \"rrq:example\") obj <- rrq_controller(\"rrq:example\") rrq_worker_status(controller = obj) }"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_stop.html","id":null,"dir":"Reference","previous_headings":"","what":"Stop workers — rrq_worker_stop","title":"Stop workers — rrq_worker_stop","text":"Stop workers, causing exit.  Workers can stopped different ways (see Details), executing function, assume worker targeted longer available work tasks.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_stop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Stop workers — rrq_worker_stop","text":"","code":"rrq_worker_stop(   worker_ids = NULL,   type = \"message\",   timeout = 0,   time_poll = 0.1,   progress = NULL,   controller = NULL )"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_stop.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Stop workers — rrq_worker_stop","text":"worker_ids Optional vector worker ids. NULL active workers stopped. type strategy used stop workers. Can message, kill kill_local (see Details). timeout Optional timeout; greater zero poll response worker many seconds acknowledge message stop (effect type message). timeout greater zero given, message-based stop wait many seconds worker exit. means might wait 2 * timeout seconds function return. time_poll type message timeout greater zero, polling interval used redis calls. Increasing reduces network load decreases ability interrupt process. progress Optional logical indicating progress bar displayed. NULL fall back value global option rrq.progress, unset display progress bar interactive session. controller controller use.  given (NULL) use controller registered rrq_default_controller_set().","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_stop.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Stop workers — rrq_worker_stop","text":"names stopped workers, invisibly.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_stop.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Stop workers — rrq_worker_stop","text":"type parameter indicates strategy used stop workers, interacts parameters. strategies used different values : message, case STOP message sent worker, receive finishing currently running task (RUNNING; IDLE workers stop immediately). kill, case kill signal sent via heartbeat (worker using one). kill worker even currently working task, eventually leaving task status DIED. kill_local, case kill signal sent using operating system signals, requires worker machine controller.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_stop.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Stop workers — rrq_worker_stop","text":"","code":"if (FALSE) { # rrq:::enable_examples(require_queue = \"rrq:example\") obj <- rrq_controller(\"rrq:example\") w <- rrq_worker_spawn(controller = obj) rrq_worker_list(controller = obj) rrq_worker_stop(w$id, timeout = 10, controller = obj) rrq_worker_list(controller = obj) }"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_task_id.html","id":null,"dir":"Reference","previous_headings":"","what":"Current task id for workers — rrq_worker_task_id","title":"Current task id for workers — rrq_worker_task_id","text":"Returns task id worker working , .","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_task_id.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Current task id for workers — rrq_worker_task_id","text":"","code":"rrq_worker_task_id(worker_ids = NULL, controller = NULL)"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_task_id.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Current task id for workers — rrq_worker_task_id","text":"worker_ids Optional vector worker ids. NULL active workers used. controller controller use.  given (NULL) use controller registered rrq_default_controller_set().","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_task_id.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Current task id for workers — rrq_worker_task_id","text":"character vector, NA nothing worked , otherwise corresponding task id.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_task_id.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Current task id for workers — rrq_worker_task_id","text":"","code":"if (FALSE) { # rrq:::enable_examples(require_queue = \"rrq:example\") obj <- rrq_controller(\"rrq:example\") rrq_worker_list(controller = obj)  # This example might be a bit racy: we need to run a task that # sleeps, and then sleep a little bit for the task to be picked up # by a worker.  Typically this happens very quickly but there are # no guarantees. t <- rrq_task_create_expr(Sys.sleep(1), controller = obj) Sys.sleep(.2) rrq_worker_task_id(controller = obj)  # You can always find out which worker did work on a task though: rrq_task_info(t, controller = obj)$worker }"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_wait.html","id":null,"dir":"Reference","previous_headings":"","what":"Wait for workers — rrq_worker_wait","title":"Wait for workers — rrq_worker_wait","text":"Wait workers appear.","code":""},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_wait.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Wait for workers — rrq_worker_wait","text":"","code":"rrq_worker_wait(   worker_ids,   timeout = Inf,   time_poll = 0.2,   is_dead = NULL,   fetch_logs = NULL,   progress = NULL,   controller = NULL )"},{"path":"https://mrc-ide.github.io/rrq/reference/rrq_worker_wait.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Wait for workers — rrq_worker_wait","text":"worker_ids vector worker ids wait timeout Timeout seconds; default wait forever time_poll Poll interval, seconds. Must integer is_dead Optionally, function accept zero arguments return logical vector along worker_ids TRUE worker failed irrecoverably.  case example process died. fetch_logs Optionally, function accept single worker identifier return character vector logs (NULL logs available) progress Optional logical indicating progress bar displayed. NULL fall back value global option rrq.progress, unset display progress bar interactive session. controller controller use.  given (NULL) use controller registered rrq_default_controller_set().","code":""},{"path":"https://mrc-ide.github.io/rrq/news/index.html","id":"rrq-070","dir":"Changelog","previous_headings":"","what":"rrq 0.7.0","title":"rrq 0.7.0","text":"Overhaul worker configuration creation; now worker configuration options (except redis storage control) set named worker configuration; reduces number arguments passed around improves documentation (mrc-4068)","code":""},{"path":"https://mrc-ide.github.io/rrq/news/index.html","id":"rrq-0616","dir":"Changelog","previous_headings":"","what":"rrq 0.6.16","title":"rrq 0.6.16","text":"Extend fault tolerance support enabling tasks retried; creates new task old task points can used seamlessly recover sorts task failure (mrc-2683) Queues print vertically printing worker info (mrc-4114)","code":""},{"path":"https://mrc-ide.github.io/rrq/news/index.html","id":"rrq-0614","dir":"Changelog","previous_headings":"","what":"rrq 0.6.14","title":"rrq 0.6.14","text":"New $task_info method retrieve detailed information task run (mrc-4058)","code":""},{"path":"https://mrc-ide.github.io/rrq/news/index.html","id":"rrq-0613","dir":"Changelog","previous_headings":"","what":"rrq 0.6.13","title":"rrq 0.6.13","text":"collect_timeout bulk functions becomes timeout_task_wait worker_stop_timeout rrq_controller’s destroy method becomes timeout_worker_stop task_timeout queuing task separate process, bulk submission functions becomes timeout_task_run timeout enqueue becomes timeout_task_run","code":""},{"path":"https://mrc-ide.github.io/rrq/news/index.html","id":"rrq-0612","dir":"Changelog","previous_headings":"","what":"rrq 0.6.12","title":"rrq 0.6.12","text":"New argument timeout_task_wait option rrq.timeout_task_wait control default time wait tasks returned task_wait bulk task retrieval methods. default behaviour unchanged (blocking indefinitely) can now easily changed global queue-scoped level.","code":""},{"path":"https://mrc-ide.github.io/rrq/news/index.html","id":"rrq-0611","dir":"Changelog","previous_headings":"","what":"rrq 0.6.11","title":"rrq 0.6.11","text":"Changed argument worker_config_save timeout timeout_idle (mrc-4075)","code":""},{"path":"https://mrc-ide.github.io/rrq/news/index.html","id":"rrq-0610","dir":"Changelog","previous_headings":"","what":"rrq 0.6.10","title":"rrq 0.6.10","text":"now possible (optionally) throw task errors retrieval via task_wait, task_results bulk interfaces. default remains error. Bulk submitted tasks longer auto-delete.","code":""},{"path":"https://mrc-ide.github.io/rrq/news/index.html","id":"rrq-067","dir":"Changelog","previous_headings":"","what":"rrq 0.6.7","title":"rrq 0.6.7","text":"Nicer errors tell contain, particularly stack traces warnings (mrc-1260)","code":""},{"path":"https://mrc-ide.github.io/rrq/news/index.html","id":"rrq-066","dir":"Changelog","previous_headings":"","what":"rrq 0.6.6","title":"rrq 0.6.6","text":"Drop at_front argument (introduced rrq 0.2.14), tasks can longer jump queue (mrc-4069)","code":""},{"path":"https://mrc-ide.github.io/rrq/news/index.html","id":"rrq-065","dir":"Changelog","previous_headings":"","what":"rrq 0.6.5","title":"rrq 0.6.5","text":"Error traces now come rlang much nicer read (mrc-4060)","code":""},{"path":"https://mrc-ide.github.io/rrq/news/index.html","id":"rrq-064","dir":"Changelog","previous_headings":"","what":"rrq 0.6.4","title":"rrq 0.6.4","text":"Make separate process timeouts timeout_poll timeout_die configurable via worker config.","code":""},{"path":"https://mrc-ide.github.io/rrq/news/index.html","id":"rrq-061","dir":"Changelog","previous_headings":"","what":"rrq 0.6.1","title":"rrq 0.6.1","text":"Simplify version information returned worker_info (mrc-2295)","code":""},{"path":"https://mrc-ide.github.io/rrq/news/index.html","id":"rrq-060","dir":"Changelog","previous_headings":"","what":"rrq 0.6.0","title":"rrq 0.6.0","text":"Renamed functions rrq_ prefix; must now use rrq_worker_spawn() (worker_spawn), rrq_worker_wait, rrq_heartbeat rrq_heartbeat_kill (mrc-2682)","code":""},{"path":"https://mrc-ide.github.io/rrq/news/index.html","id":"rrq-041","dir":"Changelog","previous_headings":"","what":"rrq 0.4.1","title":"rrq 0.4.1","text":"Expose rrq::rrq_worker_from_config, simpler way constructing worker objects. worker object (rrq::rrq_worker) loses helper constructor function documented (mrc-2297)","code":""},{"path":"https://mrc-ide.github.io/rrq/news/index.html","id":"rrq-032","dir":"Changelog","previous_headings":"","what":"rrq 0.3.2","title":"rrq 0.3.2","text":"tasks get key can checked blocking wait (mrc-2392)","code":""},{"path":"https://mrc-ide.github.io/rrq/news/index.html","id":"rrq-031","dir":"Changelog","previous_headings":"","what":"rrq 0.3.1","title":"rrq 0.3.1","text":"Direct control environment export $enqueue() new argument export (mrc-2369)","code":""},{"path":"https://mrc-ide.github.io/rrq/news/index.html","id":"rrq-0219","dir":"Changelog","previous_headings":"","what":"rrq 0.2.19","title":"rrq 0.2.19","text":"Add new enqueue_bulk method (previously deleted 0.2.0) (mrc-2261)","code":""},{"path":"https://mrc-ide.github.io/rrq/news/index.html","id":"rrq-0215","dir":"Changelog","previous_headings":"","what":"rrq 0.2.15","title":"rrq 0.2.15","text":"enqueue can add task dependencies .e. tasks must complete task can run via depends_on (mrc-2255)","code":""},{"path":"https://mrc-ide.github.io/rrq/news/index.html","id":"rrq-0214","dir":"Changelog","previous_headings":"","what":"rrq 0.2.14","title":"rrq 0.2.14","text":"enqueue can add task start queue via at_front = TRUE (mrc-2254)","code":""},{"path":"https://mrc-ide.github.io/rrq/news/index.html","id":"rrq-0213","dir":"Changelog","previous_headings":"","what":"rrq 0.2.13","title":"rrq 0.2.13","text":"Run tasks separate process (overhead) new argument separate_process = TRUE $enqueue(). Use ensure isolation tasks (mrc-2068)","code":""},{"path":"https://mrc-ide.github.io/rrq/news/index.html","id":"rrq-0212","dir":"Changelog","previous_headings":"","what":"rrq 0.2.12","title":"rrq 0.2.12","text":"Add task_preceeding function controller list tasks front particular task queue (vimc-4502)","code":""},{"path":"https://mrc-ide.github.io/rrq/news/index.html","id":"rrq-0211","dir":"Changelog","previous_headings":"","what":"rrq 0.2.11","title":"rrq 0.2.11","text":"Support multiple queues, varying priorities. can used create workers listen overlapping queues, “fast” “slow” queues (mrc-2068)","code":""},{"path":"https://mrc-ide.github.io/rrq/news/index.html","id":"rrq-0210","dir":"Changelog","previous_headings":"","what":"rrq 0.2.10","title":"rrq 0.2.10","text":"Gracefully detect multiple killed workers (#22, reported @MartinHanewald)","code":""},{"path":"https://mrc-ide.github.io/rrq/news/index.html","id":"rrq-029","dir":"Changelog","previous_headings":"","what":"rrq 0.2.9","title":"rrq 0.2.9","text":"$lapply friends restored removed refactor version 0.2.0 (mrc-558)","code":""},{"path":"https://mrc-ide.github.io/rrq/news/index.html","id":"rrq-028","dir":"Changelog","previous_headings":"","what":"rrq 0.2.8","title":"rrq 0.2.8","text":"Expand documentation (mrc-1800)","code":""},{"path":"https://mrc-ide.github.io/rrq/news/index.html","id":"rrq-027","dir":"Changelog","previous_headings":"","what":"rrq 0.2.7","title":"rrq 0.2.7","text":"rrq progress now passes fields underlying condition (mrc-1772)","code":""},{"path":"https://mrc-ide.github.io/rrq/news/index.html","id":"rrq-026","dir":"Changelog","previous_headings":"","what":"rrq 0.2.6","title":"rrq 0.2.6","text":"Update worker_spawn work breaking change docopt (mrc-1667)","code":""},{"path":"https://mrc-ide.github.io/rrq/news/index.html","id":"rrq-025","dir":"Changelog","previous_headings":"","what":"rrq 0.2.5","title":"rrq 0.2.5","text":"New $task_data method getting underlying task data (mrc-1304)","code":""},{"path":"https://mrc-ide.github.io/rrq/news/index.html","id":"rrq-024","dir":"Changelog","previous_headings":"","what":"rrq 0.2.4","title":"rrq 0.2.4","text":"Better error message given non-existent task cancelled (mrc-1259)","code":""},{"path":"https://mrc-ide.github.io/rrq/news/index.html","id":"rrq-023","dir":"Changelog","previous_headings":"","what":"rrq 0.2.3","title":"rrq 0.2.3","text":"New $worker_detect_exited detecting exited workers heartbeat used (mrc-1231)","code":""},{"path":"https://mrc-ide.github.io/rrq/news/index.html","id":"rrq-022","dir":"Changelog","previous_headings":"","what":"rrq 0.2.2","title":"rrq 0.2.2","text":"Tasks can now interrupted $task_cancel running heartbeat enabled (mrc-734)","code":""},{"path":"https://mrc-ide.github.io/rrq/news/index.html","id":"rrq-021","dir":"Changelog","previous_headings":"","what":"rrq 0.2.1","title":"rrq 0.2.1","text":"Add support within-task progress updates, using rrq::rrq_task_progress_update function, can called task run rrq queried $task_progress rrq_controller (mrc-600)","code":""},{"path":"https://mrc-ide.github.io/rrq/news/index.html","id":"rrq-020","dir":"Changelog","previous_headings":"","what":"rrq 0.2.0","title":"rrq 0.2.0","text":"Rewrite package simplify queue creation dependency chain (mrc-538 / #9, mrc-519 / #8, mrc-472 / #7)","code":""}]
