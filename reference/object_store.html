<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en-GB"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>rrq object store — object_store • rrq</title><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet"><script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet"><link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet"><script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="rrq object store — object_store"><meta name="description" content="When you create a task with rrq and that task uses local variables
these need to be copied over to the worker that will evaluate the
task. So, if we had
rrq_task_create_expr(f(a, b))

that would be the objects a and b from the context where
rrq_task_create_expr was called. There are a few
considerations here:
The names a and b are only useful in the immediate context
of the controller at the point the task is sent and so we need
to store the values referenced by a and b without
reference to the names - we do this by naming the new values
after their value. That is, the name becomes the hash of the
object, computed by rlang::hash(), as a form of content-addressable storage.
When doing this we note that we might end up using the value
referenced by a or b many times in different tasks so we
should not re-save the data more than needed, and we should not
necessarily delete it when a task is deleted unless nothing else
uses that value.
The objects might tiny or could be large; if small we tend to
care about how quickly they can be resolved (i.e., latency) and
if large we need to be careful not to overfull Redis' database
as it's a memory-based system.


To make this robust and flexible, we use a object_store object,
which will allow objects to be stored either directly in Redis, or
offloaded onto some &quot;large&quot; data store based on their
size. Currently, we provide support only for offloading to disk,
but in future hope to expand this.
When we create a value in the store (or reference a value that
already exists) we assign a tag into the database; this means that
we have for a value with hash abc123 and tag def789
prefix:data[&quot;abc123&quot;] =&amp;gt; [1] f5 26 a5 b7 26 93 b3 41 b7 d0 b0...
(the data stored, serialised into a redis hash by its hash, as a
binary object.
prefix:tag_hash:def789 =&amp;gt; {abc123} (a set of hashes used by our tag)
prefix:hash_tag:abc123 =&amp;gt; {def789} (a set of tags that
reference our hash)


If we also used the value with hash abc123 with tag fed987
this would look like
prefix:data[abc123] =&amp;gt; [1] f5 26 a5 b7 26 93 b3 41 b7 d0 b0...
hash, as a binary object.
prefix:tag_hash:def789 =&amp;gt; {abc123}
prefix:tag_hash:fed987 =&amp;gt; {abc123}
prefix:hash_tag:abc123 =&amp;gt; {def789, fed987}


As tags are dropped, then the references are dropped from the set
prefix:hash_tag:abc123 and when that set becomes empty then we
can delete prefix:data[abc123] as simple form of reference counting.
For rrq we will use task_ids as a tag.
For dealing with large data, we &quot;offload&quot; large data into a
secondary store. This replaces the redis hash of hash =&amp;gt; value
with something else. Currently the only alternative we offer is
object_store_offload_disk which will save the binary
representation of the object at the path &amp;lt;path&amp;gt;/&amp;lt;hash&amp;gt; and will
allow large values to be shared between controller and worker so
long as they share a common filesystem."><meta property="og:description" content="When you create a task with rrq and that task uses local variables
these need to be copied over to the worker that will evaluate the
task. So, if we had
rrq_task_create_expr(f(a, b))

that would be the objects a and b from the context where
rrq_task_create_expr was called. There are a few
considerations here:
The names a and b are only useful in the immediate context
of the controller at the point the task is sent and so we need
to store the values referenced by a and b without
reference to the names - we do this by naming the new values
after their value. That is, the name becomes the hash of the
object, computed by rlang::hash(), as a form of content-addressable storage.
When doing this we note that we might end up using the value
referenced by a or b many times in different tasks so we
should not re-save the data more than needed, and we should not
necessarily delete it when a task is deleted unless nothing else
uses that value.
The objects might tiny or could be large; if small we tend to
care about how quickly they can be resolved (i.e., latency) and
if large we need to be careful not to overfull Redis' database
as it's a memory-based system.


To make this robust and flexible, we use a object_store object,
which will allow objects to be stored either directly in Redis, or
offloaded onto some &quot;large&quot; data store based on their
size. Currently, we provide support only for offloading to disk,
but in future hope to expand this.
When we create a value in the store (or reference a value that
already exists) we assign a tag into the database; this means that
we have for a value with hash abc123 and tag def789
prefix:data[&quot;abc123&quot;] =&amp;gt; [1] f5 26 a5 b7 26 93 b3 41 b7 d0 b0...
(the data stored, serialised into a redis hash by its hash, as a
binary object.
prefix:tag_hash:def789 =&amp;gt; {abc123} (a set of hashes used by our tag)
prefix:hash_tag:abc123 =&amp;gt; {def789} (a set of tags that
reference our hash)


If we also used the value with hash abc123 with tag fed987
this would look like
prefix:data[abc123] =&amp;gt; [1] f5 26 a5 b7 26 93 b3 41 b7 d0 b0...
hash, as a binary object.
prefix:tag_hash:def789 =&amp;gt; {abc123}
prefix:tag_hash:fed987 =&amp;gt; {abc123}
prefix:hash_tag:abc123 =&amp;gt; {def789, fed987}


As tags are dropped, then the references are dropped from the set
prefix:hash_tag:abc123 and when that set becomes empty then we
can delete prefix:data[abc123] as simple form of reference counting.
For rrq we will use task_ids as a tag.
For dealing with large data, we &quot;offload&quot; large data into a
secondary store. This replaces the redis hash of hash =&amp;gt; value
with something else. Currently the only alternative we offer is
object_store_offload_disk which will save the binary
representation of the object at the path &amp;lt;path&amp;gt;/&amp;lt;hash&amp;gt; and will
allow large values to be shared between controller and worker so
long as they share a common filesystem."></head><body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">rrq</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.7.23</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="nav-item"><a class="nav-link" href="../articles/rrq.html">Get started</a></li>
<li class="active nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles"><li><a class="dropdown-item" href="../articles/fault-tolerance.html">Fault tolerance</a></li>
    <li><a class="dropdown-item" href="../articles/messages.html">messages</a></li>
  </ul></li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul><ul class="navbar-nav"><li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json"></form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/mrc-ide/rrq/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul></div>


  </div>
</nav><div class="container template-reference-topic">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>rrq object store</h1>
      <small class="dont-index">Source: <a href="https://github.com/mrc-ide/rrq/blob/master/R/object_store.R" class="external-link"><code>R/object_store.R</code></a></small>
      <div class="d-none name"><code>object_store.Rd</code></div>
    </div>

    <div class="ref-description section level2">
    <p>When you create a task with rrq and that task uses local variables
these need to be copied over to the worker that will evaluate the
task. So, if we had</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">rrq_task_create_expr</span>(<span class="fu">f</span>(a, b))</span></code></pre><p></p></div>
<p>that would be the objects <code>a</code> and <code>b</code> from the context where
<code>rrq_task_create_expr</code> was called. There are a few
considerations here:</p><ul><li><p>The names <code>a</code> and <code>b</code> are only useful in the immediate context
of the controller at the point the task is sent and so we need
to store the <em>values</em> referenced by <code>a</code> and <code>b</code> without
reference to the names - we do this by naming the new values
after their value. That is, the name becomes the hash of the
object, computed by <code><a href="https://rlang.r-lib.org/reference/hash.html" class="external-link">rlang::hash()</a></code>, as a form of <a href="https://en.wikipedia.org/wiki/Content-addressable_storage" class="external-link">content-addressable storage</a>.</p></li>
<li><p>When doing this we note that we might end up using the value
referenced by <code>a</code> or <code>b</code> many times in different tasks so we
should not re-save the data more than needed, and we should not
necessarily delete it when a task is deleted unless nothing else
uses that value.</p></li>
<li><p>The objects might tiny or could be large; if small we tend to
care about how quickly they can be resolved (i.e., latency) and
if large we need to be careful not to overfull Redis' database
as it's a memory-based system.</p></li>
</ul><p>To make this robust and flexible, we use a <code>object_store</code> object,
which will allow objects to be stored either directly in Redis, or
offloaded onto some "large" data store based on their
size. Currently, we provide support only for offloading to disk,
but in future hope to expand this.</p>
<p>When we create a value in the store (or reference a value that
already exists) we assign a tag into the database; this means that
we have for a value with hash <code>abc123</code> and tag <code>def789</code></p><ul><li><p><code>prefix:data["abc123"] =&gt; [1] f5 26 a5 b7 26 93 b3 41 b7 d0 b0...</code>
(the data stored, serialised into a redis hash by its hash, as a
binary object.</p></li>
<li><p><code>prefix:tag_hash:def789 =&gt; {abc123}</code> (a set of hashes used by our tag)</p></li>
<li><p><code>prefix:hash_tag:abc123 =&gt; {def789}</code> (a set of tags that
reference our hash)</p></li>
</ul><p>If we also used the value with hash <code>abc123</code> with tag <code>fed987</code>
this would look like</p><ul><li><p><code>prefix:data[abc123] =&gt; [1] f5 26 a5 b7 26 93 b3 41 b7 d0 b0...</code>
hash, as a binary object.</p></li>
<li><p><code>prefix:tag_hash:def789 =&gt; {abc123}</code></p></li>
<li><p><code>prefix:tag_hash:fed987 =&gt; {abc123}</code></p></li>
<li><p><code>prefix:hash_tag:abc123 =&gt; {def789, fed987}</code></p></li>
</ul><p>As tags are dropped, then the references are dropped from the set
<code>prefix:hash_tag:abc123</code> and when that set becomes empty then we
can delete <code>prefix:data[abc123]</code> as simple form of <a href="https://en.wikipedia.org/wiki/Reference_counting" class="external-link">reference counting</a>.</p>
<p>For <code>rrq</code> we will use <code>task_id</code>s as a tag.</p>
<p>For dealing with large data, we "offload" large data into a
secondary store. This replaces the redis hash of <code>hash =&gt; value</code>
with something else. Currently the only alternative we offer is
<code><a href="object_store_offload_disk.html">object_store_offload_disk</a></code> which will save the binary
representation of the object at the path <code>&lt;path&gt;/&lt;hash&gt;</code> and will
allow large values to be shared between controller and worker so
long as they share a common filesystem.</p>
    </div>


    <div class="section level2">
    <h2 id="details">Details<a class="anchor" aria-label="anchor" href="#details"></a></h2>
    <p>Create an object store. Typically this is not used by end-users,
and is used internally by <a href="rrq_controller.html">rrq_controller</a></p>
    </div>
    <div class="section level2">
    <h2 id="methods">Methods<a class="anchor" aria-label="anchor" href="#methods"></a></h2>

<div class="section">
<h3 id="public-methods">Public methods<a class="anchor" aria-label="anchor" href="#public-methods"></a></h3>

<ul><li><p><a href="#method-object_store-new"><code>object_store$new()</code></a></p></li>
<li><p><a href="#method-object_store-list"><code>object_store$list()</code></a></p></li>
<li><p><a href="#method-object_store-tags"><code>object_store$tags()</code></a></p></li>
<li><p><a href="#method-object_store-get"><code>object_store$get()</code></a></p></li>
<li><p><a href="#method-object_store-mget"><code>object_store$mget()</code></a></p></li>
<li><p><a href="#method-object_store-set"><code>object_store$set()</code></a></p></li>
<li><p><a href="#method-object_store-mset"><code>object_store$mset()</code></a></p></li>
<li><p><a href="#method-object_store-location"><code>object_store$location()</code></a></p></li>
<li><p><a href="#method-object_store-drop"><code>object_store$drop()</code></a></p></li>
<li><p><a href="#method-object_store-destroy"><code>object_store$destroy()</code></a></p></li>
</ul></div><p></p><hr><a id="method-object_store-new"></a><div class="section">
<h3 id="method-new-">Method <code>new()</code><a class="anchor" aria-label="anchor" href="#method-new-"></a></h3>
<p>Create a new object store (or connect to an existing one)</p><div class="section">
<h4 id="usage">Usage<a class="anchor" aria-label="anchor" href="#usage"></a></h4>
<p></p><div class="r"><div class="sourceCode"><pre><code><span><span class="va"><a href="../reference/object_store.html">object_store</a></span><span class="op">$</span><span class="fu">new</span><span class="op">(</span><span class="va">con</span>, <span class="va">prefix</span>, max_size <span class="op">=</span> <span class="cn">Inf</span>, offload <span class="op">=</span> <span class="cn">NULL</span><span class="op">)</span></span></code></pre></div><p></p></div>
</div>

<div class="section">
<h4 id="arguments">Arguments<a class="anchor" aria-label="anchor" href="#arguments"></a></h4>
<p></p><div class="arguments"><dl><dt><code>con</code></dt>
<dd><p>A redis connection object</p></dd>


<dt><code>prefix</code></dt>
<dd><p>A key prefix to use; we will make a number of keys
that start with this prefix.</p></dd>


<dt><code>max_size</code></dt>
<dd><p>The maximum serialised object size, in bytes.
If the serialised object is larger than this size it will
be placed into the offload storage, as provided by the
<code>offload</code> argument. By default this is <code>Inf</code> so all values will
be stored in the redis database.</p></dd>


<dt><code>offload</code></dt>
<dd><p>An offload storage object. We provide one of
these <code><a href="object_store_offload_disk.html">object_store_offload_disk</a></code>, which saves objects
to on disk after serialisation). This interface is
subject to change. If not given but an object exceeds <code>max_size</code>
an error will be thrown.</p></dd>


</dl><p></p></div>
</div>

</div><p></p><hr><a id="method-object_store-list"></a><div class="section">
<h3 id="method-list-">Method <code><a href="https://rdrr.io/r/base/list.html" class="external-link">list()</a></code><a class="anchor" aria-label="anchor" href="#method-list-"></a></h3>
<p>List all hashes of data known to this data store</p><div class="section">
<h4 id="usage-1">Usage<a class="anchor" aria-label="anchor" href="#usage-1"></a></h4>
<p></p><div class="r"><div class="sourceCode"><pre><code><span><span class="va">object_store</span><span class="op">$</span><span class="fu">list</span><span class="op">(</span><span class="op">)</span></span></code></pre></div><p></p></div>
</div>


</div><p></p><hr><a id="method-object_store-tags"></a><div class="section">
<h3 id="method-tags-">Method <code>tags()</code><a class="anchor" aria-label="anchor" href="#method-tags-"></a></h3>
<p>List all tags known to this data store</p><div class="section">
<h4 id="usage-2">Usage<a class="anchor" aria-label="anchor" href="#usage-2"></a></h4>
<p></p><div class="r"><div class="sourceCode"><pre><code><span><span class="va">object_store</span><span class="op">$</span><span class="fu">tags</span><span class="op">(</span><span class="op">)</span></span></code></pre></div><p></p></div>
</div>


</div><p></p><hr><a id="method-object_store-get"></a><div class="section">
<h3 id="method-get-">Method <code><a href="https://rdrr.io/r/base/get.html" class="external-link">get()</a></code><a class="anchor" aria-label="anchor" href="#method-get-"></a></h3>
<p>Get a single object by its hash</p><div class="section">
<h4 id="usage-3">Usage<a class="anchor" aria-label="anchor" href="#usage-3"></a></h4>
<p></p><div class="r"><div class="sourceCode"><pre><code><span><span class="va">object_store</span><span class="op">$</span><span class="fu">get</span><span class="op">(</span><span class="va">hash</span><span class="op">)</span></span></code></pre></div><p></p></div>
</div>

<div class="section">
<h4 id="arguments-1">Arguments<a class="anchor" aria-label="anchor" href="#arguments-1"></a></h4>
<p></p><div class="arguments"><dl><dt><code>hash</code></dt>
<dd><p>a single hash to use</p></dd>


</dl><p></p></div>
</div>

</div><p></p><hr><a id="method-object_store-mget"></a><div class="section">
<h3 id="method-mget-">Method <code><a href="https://rdrr.io/r/base/get.html" class="external-link">mget()</a></code><a class="anchor" aria-label="anchor" href="#method-mget-"></a></h3>
<p>Get a number objects by their hashes. Unlike <code>$get()</code> this
method accepts a vector of hash (length 0, 1, or more than 1)
and returns a list of the same length.</p><div class="section">
<h4 id="usage-4">Usage<a class="anchor" aria-label="anchor" href="#usage-4"></a></h4>
<p></p><div class="r"><div class="sourceCode"><pre><code><span><span class="va">object_store</span><span class="op">$</span><span class="fu">mget</span><span class="op">(</span><span class="va">hash</span><span class="op">)</span></span></code></pre></div><p></p></div>
</div>

<div class="section">
<h4 id="arguments-2">Arguments<a class="anchor" aria-label="anchor" href="#arguments-2"></a></h4>
<p></p><div class="arguments"><dl><dt><code>hash</code></dt>
<dd><p>A vector of object hashes</p></dd>


</dl><p></p></div>
</div>

</div><p></p><hr><a id="method-object_store-set"></a><div class="section">
<h3 id="method-set-">Method <code>set()</code><a class="anchor" aria-label="anchor" href="#method-set-"></a></h3>
<p>Set an object into the object store, returning the hash
of that object.</p><div class="section">
<h4 id="usage-5">Usage<a class="anchor" aria-label="anchor" href="#usage-5"></a></h4>
<p></p><div class="r"><div class="sourceCode"><pre><code><span><span class="va">object_store</span><span class="op">$</span><span class="fu">set</span><span class="op">(</span><span class="va">value</span>, <span class="va">tag</span>, serialize <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div><p></p></div>
</div>

<div class="section">
<h4 id="arguments-3">Arguments<a class="anchor" aria-label="anchor" href="#arguments-3"></a></h4>
<p></p><div class="arguments"><dl><dt><code>value</code></dt>
<dd><p>The object to save</p></dd>


<dt><code>tag</code></dt>
<dd><p>A string used to associate with the object. When
all tags that point to a particular object value have been
removed, then the object will be deleted from the store.</p></dd>


<dt><code>serialize</code></dt>
<dd><p>Logical, indicating if the values should be
serialised first. Typically this should be <code>TRUE</code>, but for
advanced use if you already have a serialised object you can
pass that in and set to <code>FALSE</code>. Note that only objects
serialised with <code><a href="https://rdrr.io/pkg/redux/man/object_to_string.html" class="external-link">redux::object_to_bin</a></code> (or with
<code>serialize(..., xdr = FALSE)</code>) will be accepted.</p></dd>


</dl><p></p></div>
</div>

</div><p></p><hr><a id="method-object_store-mset"></a><div class="section">
<h3 id="method-mset-">Method <code>mset()</code><a class="anchor" aria-label="anchor" href="#method-mset-"></a></h3>
<p>Set a number of objects into the store. Unlike <code>$set()</code>,
this method sets a list of objects into the store at once,
and returns a character vector of hashes the same length as the
list of values.</p><div class="section">
<h4 id="usage-6">Usage<a class="anchor" aria-label="anchor" href="#usage-6"></a></h4>
<p></p><div class="r"><div class="sourceCode"><pre><code><span><span class="va">object_store</span><span class="op">$</span><span class="fu">mset</span><span class="op">(</span><span class="va">value</span>, <span class="va">tag</span>, serialize <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div><p></p></div>
</div>

<div class="section">
<h4 id="arguments-4">Arguments<a class="anchor" aria-label="anchor" href="#arguments-4"></a></h4>
<p></p><div class="arguments"><dl><dt><code>value</code></dt>
<dd><p>A list of objects to save</p></dd>


<dt><code>tag</code></dt>
<dd><p>A string used to associate with the object. When
all tags that point to a particular object value have been
removed, then the object will be deleted from the store.
The same tag is used for all objects.</p></dd>


<dt><code>serialize</code></dt>
<dd><p>Logical, indicating if the values should be
serialised first. Typically this should be <code>TRUE</code>, but for
advanced use if you already have a serialised object you can
pass that in and set to <code>FALSE</code>. Note that only objects
serialised with <code><a href="https://rdrr.io/pkg/redux/man/object_to_string.html" class="external-link">redux::object_to_bin</a></code> (or with
<code>serialize(..., xdr = FALSE)</code>) will be accepted.</p></dd>


</dl><p></p></div>
</div>

</div><p></p><hr><a id="method-object_store-location"></a><div class="section">
<h3 id="method-location-">Method <code>location()</code><a class="anchor" aria-label="anchor" href="#method-location-"></a></h3>
<p>Return the storage locations of a set of hashes. Currently
the location may be <code>redis</code> (stored directly in the redis server),
<code>offload</code> (stored in the offload storage) or <code>NA</code> (if not found,
and if <code>error = FALSE</code>).</p><div class="section">
<h4 id="usage-7">Usage<a class="anchor" aria-label="anchor" href="#usage-7"></a></h4>
<p></p><div class="r"><div class="sourceCode"><pre><code><span><span class="va">object_store</span><span class="op">$</span><span class="fu">location</span><span class="op">(</span><span class="va">hash</span>, error <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div><p></p></div>
</div>

<div class="section">
<h4 id="arguments-5">Arguments<a class="anchor" aria-label="anchor" href="#arguments-5"></a></h4>
<p></p><div class="arguments"><dl><dt><code>hash</code></dt>
<dd><p>A vector of hashes</p></dd>


<dt><code>error</code></dt>
<dd><p>A logical, indicating if we should throw an error if
a hash is unknown</p></dd>


</dl><p></p></div>
</div>

</div><p></p><hr><a id="method-object_store-drop"></a><div class="section">
<h3 id="method-drop-">Method <code><a href="https://rdrr.io/r/base/drop.html" class="external-link">drop()</a></code><a class="anchor" aria-label="anchor" href="#method-drop-"></a></h3>
<p>Delete tags from the store. This will dissociate the
tags from any hashes they references and if that means that no tag
points to a hash then the data at that hash will be removed. We return
(invisibly) a character vector of any dropped hashes.</p><div class="section">
<h4 id="usage-8">Usage<a class="anchor" aria-label="anchor" href="#usage-8"></a></h4>
<p></p><div class="r"><div class="sourceCode"><pre><code><span><span class="va">object_store</span><span class="op">$</span><span class="fu">drop</span><span class="op">(</span><span class="va">tag</span><span class="op">)</span></span></code></pre></div><p></p></div>
</div>

<div class="section">
<h4 id="arguments-6">Arguments<a class="anchor" aria-label="anchor" href="#arguments-6"></a></h4>
<p></p><div class="arguments"><dl><dt><code>tag</code></dt>
<dd><p>Vector of tags to drop</p></dd>


</dl><p></p></div>
</div>

</div><p></p><hr><a id="method-object_store-destroy"></a><div class="section">
<h3 id="method-destroy-">Method <code>destroy()</code><a class="anchor" aria-label="anchor" href="#method-destroy-"></a></h3>
<p>Remove all data from the store, and all the stores
metadata</p><div class="section">
<h4 id="usage-9">Usage<a class="anchor" aria-label="anchor" href="#usage-9"></a></h4>
<p></p><div class="r"><div class="sourceCode"><pre><code><span><span class="va">object_store</span><span class="op">$</span><span class="fu">destroy</span><span class="op">(</span><span class="op">)</span></span></code></pre></div><p></p></div>
</div>


</div>

    </div>

  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside></div>


    <footer><div class="pkgdown-footer-left">
  <p>Developed by Rich FitzJohn, Robert Ashton.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.2.</p>
</div>

    </footer></div>





  </body></html>

